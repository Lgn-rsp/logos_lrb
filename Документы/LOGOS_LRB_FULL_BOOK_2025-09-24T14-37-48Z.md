# LOGOS LRB — FULL BOOK SNAPSHOT
**UTC:** 2025-09-24T14-37-48Z
**Repo:** /root/logos_lrb
**User:** root
**Kernel:** Linux 6.8.0-79-generic x86_64 GNU/Linux
**OS:** Ubuntu 24.04.3 LTS

## Git
**Remotes:**
origin	git@github.com:Lgn-rsp/logos_lrb.git (fetch)
origin	git@github.com:Lgn-rsp/logos_lrb.git (push)
**Branch:** fix/build-stack-axum06-prod-2025-09-21
**HEAD commit:** 2b883ee0cbc9330c6cca17e0e0b05174354d4cf3

## Toolchain
rustc 1.89.0 (29483883e 2025-08-04)
cargo 1.89.0 (c24e10642 2025-06-23)
jq-1.7
tree v2.1.1 © 1996 - 2023 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro

## Inventory (trimmed)
./
├── AUDIT_REPORT.md
├── Cargo.toml
├── configs/
│   ├── archive_ddl.sql
│   ├── archive_indexes.sql
│   ├── archive_view_and_indexes.sql
│   ├── env/
│   │   ├── node-a.env.example
│   │   ├── node-b.env.example
│   │   ├── node-c.env.example
│   │   └── node.env.example
│   ├── genesis.yaml
│   ├── keys.env.example
│   ├── logos_config.yaml
│   └── proxy.env.example
├── core/
│   ├── beta_rollout.yaml
│   ├── offline_resonance.py
│   ├── onboarding_sim.py
│   ├── onboarding_ui.py
│   ├── resonance_analyzer.py
│   ├── rid_builder.py
│   ├── rid_log.json
│   ├── ritual_quest.py
│   └── rLGN_converter.py
├── docs/
│   ├── architecture.md
│   ├── LOGOS_LRB_BOOK/
│   │   └── LOGOS_LRB_BOOK.md
│   ├── LOGOS_LRB_BOOK_2025-09-07T14-13-01Z.txt
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T07-58-28Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T08-05-35Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T08-13-55Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T08-28-23Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T08-38-56Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T08-51-17Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T10-16-59Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T11-37-16Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T12-37-01Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T14-27-33Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-18T16-28-37Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T02-39-45Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T03-25-36Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T03-52-10Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T03-53-25Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T06-47-32Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T06-54-12Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T06-55-06Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T06-56-55Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T07-01-04Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T07-02-36Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T07-03-42Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-19T07-07-15Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-20T14-14-42Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-20T14-24-56Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-20T14-35-44Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-24T12-48-01Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-24T14-36-35Z.md
│   ├── LOGOS_LRB_FULL_BOOK_2025-09-24T14-37-48Z.md
│   ├── LOGOS_LRB_FULL_BOOK.md
│   ├── LRB_FULL_LIVE_2025-09-07.txt
│   ├── LRB_SNAPSHOT_20250904_1426.txt
│   ├── MODULES_INVENTORY_2025-09-18T08-17-49Z.csv
│   ├── MODULES_INVENTORY_2025-09-18T08-17-49Z.json
│   ├── MODULES_INVENTORY_2025-09-18T08-17-49Z.txt
│   ├── MODULES_INVENTORY_2025-09-18T08-20-54Z.csv
│   ├── MODULES_INVENTORY_2025-09-18T08-20-54Z.json
│   ├── MODULES_INVENTORY_2025-09-18T08-20-54Z.txt
│   ├── MODULES_INVENTORY_2025-09-18T08-25-35Z.csv
│   ├── MODULES_INVENTORY_2025-09-18T08-25-35Z.json
│   ├── MODULES_INVENTORY_2025-09-18T08-25-35Z.txt
│   ├── MODULES_INVENTORY_2025-09-18T08-26-33Z.csv
│   ├── MODULES_INVENTORY_2025-09-18T08-26-33Z.json
│   ├── MODULES_INVENTORY_2025-09-18T08-26-33Z.txt
│   ├── snapshots/
│   │   └── LRB_FULL_LIVE_20250905_1218.txt
│   └── WORKFLOW.md
├── .gitignore
├── infra/
│   ├── nginx/
│   │   ├── logos-api-lb.conf.example
│   │   ├── lrb_wallet.conf
│   │   └── lrb_wallet.conf.sample
│   └── systemd/
│       ├── exec.conf
│       ├── keys.conf
│       ├── keys.env.example
│       ├── logos-healthcheck.service
│       ├── logos-healthcheck.timer
│       ├── logos-node@.service
│       ├── logos-node.service.sample
│       ├── logos-snapshot.service
│       ├── logos-snapshot.timer
│       ├── lrb-proxy.service
│       ├── lrb-proxy.service.sample
│       ├── lrb-scanner.service
│       ├── lrb-scanner.service.sample
│       ├── override.conf
│       ├── runas.conf
│       ├── security.conf
│       ├── tuning.conf
│       ├── zz-consensus.conf
│       ├── zz-keys.conf
│       └── zz-logging.conf
├── ledger.rs
├── LOGOS_LRB_FULL_BOOK.md
├── lrb_core/
│   ├── Cargo.toml
│   └── src/
│       ├── anti_replay.rs*
│       ├── beacon.rs*
│       ├── crypto.rs*
│       ├── dynamic_balance.rs*
│       ├── engine.rs
│       ├── heartbeat.rs*
│       ├── ledger.rs
│       ├── ledger.rs:24:5
│       ├── ledger.rs:29:5
│       ├── lib.rs
│       ├── nano.114024.save
│       ├── phase_consensus.rs
│       ├── phase_filters/
│       ├── phase_integrity.rs*
│       ├── quorum.rs*
│       ├── rcp_engine.rs*
│       ├── resonance.rs*
│       ├── sigpool.rs*
│       ├── spam_guard.rs*
│       └── types.rs
├── modules/
│   ├── beacon_emitter.rs
│   ├── env_impact_tracker.py
│   ├── external_phase_broadcaster.rs
│   ├── external_phase_link.rs
│   ├── genesis_fragment_seeds.rs
│   ├── go_to_market.yaml
│   ├── heartbeat_monitor.rs
│   ├── legacy_migrator.rs
│   ├── maintenance_strategy.yaml
│   ├── resonance_analytics_frontend.tsx
│   ├── resonance_emergency_plan.yaml
│   ├── resonance_meshmap.yaml
│   ├── resonance_tutor.py
│   ├── ritual_engine.rs
│   ├── symbolic_parser.py
│   ├── uplink_controller.rs
│   └── uplink_router.rs
├── node/
│   ├── build.rs
│   ├── build.rs.bak.20250921T152855Z
│   ├── Cargo.toml
│   ├── Cargo.toml.bak.124637
│   ├── Cargo.toml.bak.141054
│   ├── Cargo.toml.bak.141744
│   ├── Cargo.toml.bak.20250921T133102Z
│   ├── Cargo.toml.bak.20250921T135301Z
│   ├── Cargo.toml.bak.20250921T152031Z
│   ├── Cargo.toml.bak.20250921T152838Z
│   ├── Cargo.toml.bak.20250921T165322Z
│   ├── Cargo.toml.bak.20250922T021131Z
│   ├── Cargo.toml.bak.20250922T042246Z
│   ├── openapi/
│   │   └── openapi.json
│   └── src/
│       ├── admin.rs
│       ├── api/
│       ├── api.rs:10:5
│       ├── api.rs:108:5
│       ├── api.rs:59:39
│       ├── archive/
│       ├── archive_ingest.rs
│       ├── auth.rs
│       ├── auth.rs:37:5
│       ├── auth.rs:69:15
│       ├── bin/
│       ├── bridge_journal.rs
│       ├── bridge.rs
│       ├── fork.rs
│       ├── gossip.rs
│       ├── guard.rs
│       ├── health.rs
│       ├── history_sled.rs
│       ├── JSON
│       ├── LE
│       ├── lib.rs
│       ├── main.rs
│       ├── main.rs:15:5
│       ├── main.rs:73:25
│       ├── main.rs.bak.093626
│       ├── main.rs.bak.102422
│       ├── main.rs.bak.102926
│       ├── main.rs.bak.115338
│       ├── main.rs.bak.115808
│       ├── main.rs.bak.120849
│       ├── main.rs.bak.121503
│       ├── main.rs.bak.122015
│       ├── main.rs.bak.122520
│       ├── main.rs.bak.123043
│       ├── main.rs.bak.124637
│       ├── main.rs.bak.125221
│       ├── main.rs.bak.125641
│       ├── main.rs.bak.131403
│       ├── main.rs.bak.132240
│       ├── main.rs.bak.133009
│       ├── main.rs.bak.134537
│       ├── main.rs.bak.135012
│       ├── main.rs.bak.135356
│       ├── main.rs.bak.20250922T042341Z
│       ├── main.rs.bak.20250922T044532Z
│       ├── metrics.rs
│       ├── openapi/
│       ├── openapi.json
│       ├── openapi.rs
│       ├── payout_adapter.rs
│       ├── peers.rs
│       ├── producer.rs
│       ├── stake_api.rs
│       ├── stake_claim.rs
│       ├── stake.rs
│       ├── staking.rs
│       ├── state.rs
│       ├── storage.rs
│       ├── types.rs
│       ├── version.rs
│       └── wallet.rs
├── py_err.log
├── README.md
├── scripts/
│   ├── bootstrap_node.sh*
│   ├── collect_and_push.sh*
│   └── logos_healthcheck.sh*
├── src/
│   ├── bin/
│   │   ├── ai_signal_listener.rs
│   │   ├── orchestration_control.rs
│   │   ├── rcp_engine.rs
│   │   ├── resonance_mesh.rs
│   │   ├── resonance_sync.rs
│   │   ├── sigma_t.rs
│   │   └── Λ0.rs
│   ├── core/
│   │   ├── biosphere_scanner.rs
│   │   ├── dao.rs
│   │   ├── logos_self.rs
│   │   ├── phase.rs
│   │   ├── resonance.rs
│   │   └── tx_spam_guard.rs
│   ├── lib.rs
│   └── utils/
│       ├── filters.rs
│       ├── frequency.rs
│       ├── math.rs
│       └── types.rs
├── tools/
│   ├── admin_cli.sh*
│   ├── batch.json
│   ├── bench/
│   │   └── go/
│   ├── book_make.sh*
│   ├── book_restore.sh*
│   ├── gen_full_codemap.py*
│   ├── go_test/
│   │   ├── go.mod
│   │   ├── go.sum
│   │   ├── main.go
│   │   └── two_rids.go
│   ├── k6_smoke.js
│   ├── load/
│   │   ├── go.mod
│   │   ├── go.sum
│   │   └── load_submit_tx.go
│   ├── load_healthz.sh*
│   ├── lrb_audit.sh*
│   ├── make_book_and_push.sh*
│   ├── make_book_and_push.shy
│   ├── make_book_and_push_v2.sh*
│   ├── make_codebook.sh*
│   ├── make_full_book.sh*
│   ├── make_full_book_v2.sh*
│   ├── make_full_snapshot_live.sh*
│   ├── make_tx.rs
│   ├── prepare_payer.sh*
│   ├── repo_audit.sh*
│   ├── scan_modules.sh*
│   ├── sdk/
│   │   ├── go/
│   │   └── ts/
│   ├── sdk_go/
│   ├── sdk_rust/
│   ├── seed_balance/
│   │   ├── Cargo.toml
│   │   └── src/
│   ├── targets.jsonl
│   ├── test_tx.sh*
│   ├── tx_load.sh*
│   ├── tx_one.sh*
│   ├── vegeta_submit_live.sh*
│   └── vegeta_submit.sh*
├── wallet-proxy/
│   ├── app.py
│   ├── requirements.txt
│   └── scanner.py
└── www/
    ├── explorer/
    │   ├── explorer.css
    │   ├── explorer.js
    │   └── index.html
    ├── index.html
    ├── wallet/
    │   ├── app.html
    │   ├── app.js
    │   ├── app.v2.js
    │   ├── app.v3.js
    │   ├── auth.js
    │   ├── index.html
    │   ├── login.html
    │   ├── staking.js
    │   ├── wallet.css
    │   └── wallet.js
    ├── wallet3/
    │   ├── app.v3.js
    │   └── index.html
    └── wallet.js

43 directories, 281 files

## Files

## FILE: /root/logos_lrb/Cargo.toml  (size=1493b)
```toml
[workspace]
members  = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition      = "2021"
rust-version = "1.78"

[workspace.dependencies]
axum       = { version = "0.7.9", features = ["macros", "json"] }
tower      = "0.4.13"
tower-http = { version = "0.5.2", features = ["trace", "cors", "compression-full"] }
tokio      = { version = "1.40", features = ["full"] }
reqwest    = { version = "0.12", default-features = false, features = ["rustls-tls", "http2", "json"] }

serde               = { version = "1.0", features = ["derive"] }
serde_json          = "1.0"
anyhow              = "1.0"
thiserror           = "1.0"
once_cell           = "1.19"
dashmap             = "5.5"
tracing             = "0.1"
tracing-subscriber  = { version = "0.3", features = ["env-filter", "fmt"] }
bytes               = "1.6"

hex              = "0.4"
base64           = "0.21"
bs58             = "0.4"
sha2             = "0.10"
blake3           = "1.5"
ed25519-dalek    = { version = "2.2", features = ["std", "alloc", "signature", "rand_core"] }
rand             = "0.8"
ring             = "0.17"
uuid             = { version = "1.8", features = ["v4"] }
bincode          = "1.3"
jsonwebtoken     = "9"

sled             = "0.34"
deadpool-postgres= "0.12"
tokio-postgres   = { version = "0.7", features = ["with-uuid-1"] }
rusqlite         = { version = "0.32", features = ["bundled"] }
r2d2_sqlite      = "0.25"

parking_lot = "0.12"
ipnet       = "2.9"
prometheus  = "0.13"
lazy_static = "1.5"

```

## FILE: /root/logos_lrb/configs/archive_ddl.sql  (size=938b)
```sql
-- Таблица tx под канон (если нет)
CREATE TABLE IF NOT EXISTS tx (
  id       bigserial PRIMARY KEY,
  txid     text UNIQUE NOT NULL,
  rid_from text NOT NULL,
  rid_to   text NOT NULL,
  amount   bigint NOT NULL,
  nonce    bigint DEFAULT 0,
  ts_sec   bigint NOT NULL,
  height   bigint
);

-- Представление для стабильного API
CREATE OR REPLACE VIEW tx_std AS
SELECT
  txid::text   AS tx_id,
  rid_from     AS from_rid,
  rid_to       AS to_rid,
  amount::bigint AS amount,
  ts_sec::bigint AS ts_sec,
  height::bigint AS height
FROM tx;

-- Индексы под историю
CREATE INDEX IF NOT EXISTS idx_tx_from   ON tx (rid_from);
CREATE INDEX IF NOT EXISTS idx_tx_to     ON tx (rid_to);
CREATE INDEX IF NOT EXISTS idx_tx_txid   ON tx (txid);
CREATE INDEX IF NOT EXISTS idx_tx_height ON tx (height DESC);
CREATE INDEX IF NOT EXISTS idx_tx_tssec  ON tx (ts_sec DESC);
ANALYZE tx;

```

## FILE: /root/logos_lrb/configs/archive_indexes.sql  (size=831b)
```sql
-- Оптимизация истории LOGOS LRB
-- Запускается один раз в psql

-- Индексы для быстрых выборок по RID
CREATE INDEX IF NOT EXISTS idx_tx_from_rid ON tx (from_rid);
CREATE INDEX IF NOT EXISTS idx_tx_to_rid   ON tx (to_rid);

-- Часто в WHERE используется OR (from_rid=$1 OR to_rid=$1)
-- Лучший вариант: составной индекс с выражением
CREATE INDEX IF NOT EXISTS idx_tx_rid_pair ON tx (from_rid, to_rid);

-- Индекс по времени для сортировки DESC
CREATE INDEX IF NOT EXISTS idx_tx_ts ON tx (ts DESC);

-- Дополнительно по id если у тебя id SERIAL
CREATE INDEX IF NOT EXISTS idx_tx_id ON tx (id DESC);

-- Анализ для оптимизатора
ANALYZE tx;

```

## FILE: /root/logos_lrb/configs/archive_view_and_indexes.sql  (size=826b)
```sql
-- Стандартизированное представление истории (под твою схему tx)
CREATE OR REPLACE VIEW tx_std AS
SELECT
    txid::text              AS tx_id,
    rid_from::text          AS from_rid,
    rid_to::text            AS to_rid,
    amount::bigint          AS amount,
    ts_sec::bigint          AS ts_sec,
    height::bigint          AS height
FROM tx;

-- Индексы под типовые запросы (если ещё не созданы)
CREATE INDEX IF NOT EXISTS idx_tx_from_rid    ON tx (rid_from);
CREATE INDEX IF NOT EXISTS idx_tx_to_rid      ON tx (rid_to);
CREATE INDEX IF NOT EXISTS idx_tx_txid        ON tx (txid);
CREATE INDEX IF NOT EXISTS idx_tx_height_desc ON tx (height DESC);
CREATE INDEX IF NOT EXISTS idx_tx_ts_sec_desc ON tx (ts_sec DESC);

ANALYZE tx;

```

## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/configs/env/node.env.example  (size=2576b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/configs/genesis.yaml  (size=1322b)
```yaml
# LOGOS LRB — GENESIS (full-mainnet ready)
l0_symbol: "Λ0"

sigma:
  f1: 7.83
  f2: 1.618
  harmonics: [432, 864, 3456]

emission:
  total_lgn: 81000000
  cap_micro: 81000000000000
  allocations:
    - { rid: "Λ0@7.83Hzφ0.0000", micro: 1000000000 } # 1000 LGN для технологических нужд

consensus:
  producer_slot_ms: 1000
  bft:
    enabled: true
    # список валидаторов (RID или валидатор-ID, как у тебя заведено)
    validators:
      - "val1_rid_base58"
      - "val2_rid_base58"
      - "val3_rid_base58"
    # 2/3 финализация: автоматически вычисляется из числа валидаторов
    view_timeout_ms: 3000       # таймаут смены раунда (view)
    max_round_skew: 3           # макс. допуск «скоса» раунда при лаге
    equivocation_slash: true    # на будущее: реакция на двойное голосование
  fork_choice: "LMD-GHOST"      # стратегия выбора ветки

bridge:
  max_per_tx_micro: 10000000

guard:
  rate_limit_qps: 500
  rate_limit_burst: 1000

limits:
  mempool_cap: 200000
  max_block_tx: 20000

phase:
  enabled: true
  freqs_hz: [7.83, 1.618, 432]
  min_score: -0.2

explorer:
  page_size: 50

```

## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/configs/logos_config.yaml  (size=448b)
```yaml
# LOGOS LRB — Node Config (prod)

node:
  listen: "0.0.0.0:8080"
  data_path: "/var/lib/logos/data.sled"
  node_key_path: "/var/lib/logos/node_key"

limits:
  mempool_cap: 200000
  max_block_tx: 20000
  slot_ms: 1000

guard:
  rate_limit_qps: 500
  rate_limit_burst: 1000
  cidr_bypass: ["127.0.0.1/32","::1/128"]

phase:
  enabled: true
  freqs_hz: [7.83, 1.618, 432]
  min_score: -0.2

bridge:
  max_per_tx: 10000000

explorer:
  page_size: 50

```

## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/docs/architecture.md  (size=10559b)
```markdown
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```

## FILE: /root/logos_lrb/docs/LOGOS_LRB_BOOK_2025-09-07T14-13-01Z.txt  (size=2986953b)
(SKIPPED, >2000000 bytes)

## FILE: /root/logos_lrb/docs/LOGOS_LRB_BOOK/LOGOS_LRB_BOOK.md  (size=6534b)
```markdown
# LOGOS LRB — Книга системы

---

## Глава 1. Архитектура репозитория

### 1. Дерево `/root/logos_lrb`
/root/logos_lrb
├── Cargo.toml / README.md
├── lrb_core/                  # Rust-ядро L1
│   └── src/{ledger.rs, rcp_engine.rs, phase_integrity.rs,
│            dynamic_balance.rs, spam_guard.rs, resonance.rs,
│            phase_consensus.rs, phase_filters.rs, quorum.rs, types.rs,…}
├── node/                      # Узел (Axum REST + gossip + метрики)
│   ├── Cargo.toml
│   ├── openapi/openapi.json
│   └── src/{main.rs, api.rs, admin.rs, bridge.rs, guard.rs,
│            gossip.rs, state.rs, peers.rs, fork.rs, metrics.rs, …}
├── modules/                   # uplink_*, external_phase_*, parser/…
├── www/
│   ├── wallet/                # Web Wallet (IndexedDB+WebCrypto)
│   └── explorer/              # Explorer (inline-JS, самодостаточный)
├── tools/                     # bench v4, e2e/load, SDK (TS)
├── scripts/                   # bootstrap_node.sh, healthcheck.sh, …
├── core/                      # аналитика/симуляции (py)
├── wallet-proxy/              # вспомогательные утилиты (py)
└── configs/                   # env-шаблоны, genesis.yaml

### 2. Роли директорий
- **lrb_core/** — ядро L1: ledger (sled), mempool, spam_guard, dynamic_balance, фазовые фильтры, Σ(t), финализация quorum=1.
- **node/** — REST-узел: `/healthz`, `/head`, `/balance/:rid`, `/submit_tx`, `/submit_tx_batch`, `/bridge/*`, `/economy`, `/history/:rid`, `/openapi.json`.
- **modules/** — uplink, external_phase, ritual_engine, analytics.
- **www/wallet/** — кошелёк: RID+пароль, AES-GCM (PBKDF2), Ed25519 (WebCrypto), batch-tx.
- **www/explorer/** — explorer: поиск RID/блока/nonce, история, последние блоки, автообновление.
- **tools/** — bench v4 (~10k tx/s), SDK (TS), e2e/load.
- **scripts/** — утилиты запуска/снапшотов.
- **configs/** — env и genesis.

---

## Глава 2. Инфраструктура (вне репозитория)

### 2.1 Пути/данные
/opt/logos/www/                 # прод-статика (wallet, explorer)  
/var/lib/logos/data.sled        # база блокчейна (sled)  
/var/lib/logos/node_key         # ключ ноды (если используется)  

### 2.2 systemd
/etc/systemd/system/logos-node.service  
/etc/systemd/system/logos-node.service.d/  
  ├─ data.conf        # LRB_DATA_PATH=/var/lib/logos/data.sled  
  ├─ zz-keys.conf     # ключи / ENV  
  ├─ ratelimit.conf   # лимиты QPS/Burst, bypass localhost  
  ├─ runas.conf       # user/group logos  
  ├─ security.conf    # ProtectSystem, NoNewPrivileges  
  └─ override.conf    # расширения  

### 2.3 nginx + TLS
/etc/nginx/conf.d/  
  ├─ 00_redirect_80.conf   # redirect 80→443  
  └─ 10_lrb_https.conf     # HTTPS, CSP, /api, /wallet, /explorer  

TLS: /etc/letsencrypt/live/<домен>/{fullchain.pem, privkey.pem}  

**CSP**:  
`default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'`  

**/explorer/**:  
`Cache-Control: no-store, no-cache, must-revalidate, max-age=0`  
`Pragma: no-cache`  
`Expires: 0`  

### 2.4 Мониторинг
- Prometheus: /etc/prometheus/prometheus.yml  
- Rules: /etc/prometheus/rules/lrb_core.yml  
- Alertmanager: /etc/alertmanager/alertmanager.yml (+ secrets.env: TELEGRAM_BOT_TOKEN, CHAT_ID)  
- Grafana: /etc/grafana/provisioning/{datasources,dashboards}/  
- Dashboards: /var/lib/grafana/dashboards/lrb_core.json  
- NodeExporter: 9100, Prometheus:9094, Alertmanager:9093, Grafana:3000  

### 2.5 Порты
| Компонент    | Порт | Комментарий           |
|--------------|------|-----------------------|
| nginx HTTPS  | 443  | wallet, explorer, API |
| nginx HTTP   | 80   | redirect → 443        |
| logos_node   | 8080 | REST (за nginx)       |
| prometheus   | 9094 |                       |
| alertmanager | 9093 |                       |
| node_exporter| 9100 |                       |
| grafana      | 3000 |                       |

---

## Глава 3. Функционал

- **Ledger**: sled, mempool, spam_guard, dynamic_balance.  
- **Consensus**: Σ(t), slot producer, финализация (quorum=1).  
- **Filters**: фазовые, phase_integrity.  
- **Crypto**: XChaCha20-Poly1305 (AEAD).  
- **REST**: healthz, head, balance, submit_tx, bridge, economy, history, openapi.json.  
- **Bridge**: idempotency, tickets, verify.  
- **Gossip**: блоки, голоса, Σ-подписи.  
- **Wallet**: WebCrypto, IndexedDB, batch-tx.  
- **Explorer**: история, поиск RID/блока, автообновление.  
- **Monitoring**: Prometheus/Grafana, alerting → Telegram.  
- **Bench v4**: ~10.6k tx/s.  

---

## Глава 4. Что работает сейчас

✔ Ядро (ledger, mempool, spam_guard, dynamic_balance).  
✔ REST-узел Axum 0.7 (все базовые маршруты).  
✔ Gossip, Σ(t) подписи.  
✔ rToken-мост (боевой, idempotent).  
✔ Экономика: hard-cap 81M, supply= minted−burned.  
✔ Инфра: systemd sandbox, nginx+TLS, healthcheck.timer.  
✔ Web Wallet (MVP), Explorer (inline-JS).  
✔ Prometheus+Grafana+Alertmanager+Telegram.  
✔ Bench v4: 10.6k tx/s.  

---

## Глава 5. Доработки до продакшена

1. Кворум >1, распределённый fork-choice.  
2. История блоков/tx (архив, индексы, полный explorer).  
3. Unit/chaos-тесты ядра.  
4. Мобильный кошелёк (Flutter).  
5. Web Wallet → WebCrypto+IndexedDB полностью.  
6. OpenAPI/SDK автоген (Go/Rust).  
7. Grafana-дашборды и оповещения.  
8. REST-защита: ACL/DoS guard с логированием атак.  

---

⚡ **Цель**: LOGOS LRB — резонансный блокчейн продакшен-уровня, готовый к миллионам пользователей, с web/mobile кошельком, безопасный и масштабируемый.

```

## FILE: /root/logos_lrb/docs/LOGOS_LRB_FULL_BOOK.md  (size=1443638b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/docs/LRB_FULL_LIVE_2025-09-07.txt  (size=7688b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/docs/LRB_SNAPSHOT_20250904_1426.txt  (size=384296b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-17-49Z.csv  (size=11481b)
```text
path,ext,size_bytes,lines,sha256
lrb_core/Cargo.toml,toml,864,32,8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012
lrb_core/src/anti_replay.rs,rs,980,35,b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5
lrb_core/src/beacon.rs,rs,1821,61,3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6
lrb_core/src/crypto.rs,rs,1929,48,4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2
lrb_core/src/dynamic_balance.rs,rs,609,18,f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4
lrb_core/src/engine.rs,rs,6769,153,094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64
lrb_core/src/heartbeat.rs,rs,2166,78,03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9
lrb_core/src/ledger.rs,rs,10076,227,9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05
lrb_core/src/lib.rs,rs,499,12,01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b
lrb_core/src/phase_consensus.rs,rs,1806,52,804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43
lrb_core/src/phase_filters/mod.rs,rs,249,8,b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29
lrb_core/src/phase_integrity.rs,rs,1695,38,1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e
lrb_core/src/quorum.rs,rs,2031,51,8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2
lrb_core/src/rcp_engine.rs,rs,1622,47,7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836
lrb_core/src/resonance.rs,rs,1146,38,3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9
lrb_core/src/sigpool.rs,rs,1072,33,9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175
lrb_core/src/spam_guard.rs,rs,839,33,592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e
lrb_core/src/types.rs,rs,1173,43,ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96
node/Cargo.toml,toml,2162,75,d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b
node/build.rs,rs,1722,43,65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf
node/src/admin.rs,rs,2800,45,8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4
node/src/api_extra.rs,rs,1886,37,a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c
node/src/api.rs,rs,8182,185,eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9
node/src/archive_ingest.rs,rs,1219,35,d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/auth.rs,rs,2349,63,cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
node/src/bridge.rs,rs,3551,89,0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186
node/src/fork.rs,rs,1328,40,d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b
node/src/gossip.rs,rs,1539,45,6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5
node/src/guard.rs,rs,3418,77,aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399
node/src/history_sled.rs,rs,1044,30,1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9
node/src/lib.rs,rs,831,24,7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb
node/src/main.rs,rs,3027,88,b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76
node/src/metrics.rs,rs,3597,103,54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846
node/src/openapi.rs,rs,441,14,184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b
node/src/peers.rs,rs,4932,158,8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63
node/src/producer.rs,rs,1704,44,fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e
node/src/stake_api.rs,rs,2668,52,53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536
node/src/stake.rs,rs,7692,162,8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8
node/src/staking.rs,rs,339,9,e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01
node/src/state.rs,rs,1182,35,621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5
node/src/storage.rs,rs,1031,31,12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7
node/src/types.rs,rs,430,17,33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0
node/src/version.rs,rs,495,21,2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e
node/src/wallet.rs,rs,913,26,c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
modules/beacon_emitter.rs,rs,4455,139,34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd
modules/external_phase_broadcaster.rs,rs,1588,44,788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb
modules/external_phase_link.rs,rs,997,33,56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91
modules/genesis_fragment_seeds.rs,rs,1423,25,829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b
modules/heartbeat_monitor.rs,rs,1489,26,ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf
modules/legacy_migrator.rs,rs,1432,25,2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8
modules/ritual_engine.rs,rs,1460,25,b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef
modules/uplink_controller.rs,rs,1571,43,520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1
modules/uplink_router.rs,rs,1551,43,ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49
modules/go_to_market.yaml,yaml,3633,118,e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f
modules/maintenance_strategy.yaml,yaml,2361,85,a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9
modules/resonance_emergency_plan.yaml,yaml,3420,91,ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd
modules/resonance_meshmap.yaml,yaml,1877,89,8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6
modules/env_impact_tracker.py,py,5447,132,b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb
modules/resonance_tutor.py,py,6414,135,42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f
modules/symbolic_parser.py,py,4615,110,99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8
www/explorer/index.html,html,1880,36,1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a
www/index.html,html,4902,124,7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b
www/wallet3/index.html,html,3528,88,16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717
www/wallet/app.html,html,3367,74,634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2
www/wallet/index.html,html,4490,104,e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde
www/wallet/login.html,html,2647,56,3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76
www/explorer/explorer.js,js,3977,82,bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b
www/wallet3/app.v3.js,js,6763,107,2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349
www/wallet/app.js,js,7641,148,a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9
www/wallet/app.v2.js,js,7526,136,e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2
www/wallet/app.v3.js,js,6952,117,e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b
www/wallet/auth.js,js,6002,117,fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a
www/wallet.js,js,5287,137,8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc
www/wallet/staking.js,js,2843,42,ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80
www/wallet/wallet.js,js,9153,168,5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c
www/explorer/explorer.css,css,898,10,0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba
www/wallet/wallet.css,css,2693,73,1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad
configs/genesis.yaml,yaml,811,30,a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972
configs/logos_config.yaml,yaml,448,27,6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b
configs/env/node-a.env.example,example,254,8,cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f
configs/env/node-b.env.example,example,254,8,91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3
configs/env/node-c.env.example,example,254,8,448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290
scripts/bootstrap_node.sh,sh,1556,38,6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c
scripts/collect_and_push.sh,sh,3118,104,9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a
scripts/logos_healthcheck.sh,sh,1689,52,ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec
infra/systemd/logos-healthcheck.service,service,217,9,32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81
infra/systemd/logos-node.service,service,369,19,464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95
infra/systemd/logos-node@.service,service,412,23,9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb
infra/systemd/logos-snapshot.service,service,271,8,1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1
infra/systemd/lrb-proxy.service,service,395,16,008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed
infra/systemd/lrb-scanner.service,service,378,16,35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260
infra/systemd/exec.conf,conf,85,4,cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a
infra/systemd/keys.conf,conf,226,7,82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2
infra/systemd/override.conf,conf,575,16,0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6
infra/systemd/runas.conf,conf,143,5,8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c
infra/systemd/security.conf,conf,337,14,da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914
infra/systemd/tuning.conf,conf,156,5,d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8
infra/systemd/zz-consensus.conf,conf,137,4,b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171
infra/systemd/zz-keys.conf,conf,417,9,4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87
infra/systemd/zz-logging.conf,conf,36,2,d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a
infra/nginx/lrb_wallet.conf,conf,3062,88,c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-17-49Z.json  (size=16694b)
```json
{"generated":"2025-09-18T08-17-49Z","files":[
{"path":"lrb_core/Cargo.toml","ext":"toml","size":864,"lines":32,"sha256":"8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012"},
{"path":"lrb_core/src/anti_replay.rs","ext":"rs","size":980,"lines":35,"sha256":"b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5"},
{"path":"lrb_core/src/beacon.rs","ext":"rs","size":1821,"lines":61,"sha256":"3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6"},
{"path":"lrb_core/src/crypto.rs","ext":"rs","size":1929,"lines":48,"sha256":"4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2"},
{"path":"lrb_core/src/dynamic_balance.rs","ext":"rs","size":609,"lines":18,"sha256":"f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4"},
{"path":"lrb_core/src/engine.rs","ext":"rs","size":6769,"lines":153,"sha256":"094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64"},
{"path":"lrb_core/src/heartbeat.rs","ext":"rs","size":2166,"lines":78,"sha256":"03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9"},
{"path":"lrb_core/src/ledger.rs","ext":"rs","size":10076,"lines":227,"sha256":"9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05"},
{"path":"lrb_core/src/lib.rs","ext":"rs","size":499,"lines":12,"sha256":"01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b"},
{"path":"lrb_core/src/phase_consensus.rs","ext":"rs","size":1806,"lines":52,"sha256":"804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43"},
{"path":"lrb_core/src/phase_filters/mod.rs","ext":"rs","size":249,"lines":8,"sha256":"b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29"},
{"path":"lrb_core/src/phase_integrity.rs","ext":"rs","size":1695,"lines":38,"sha256":"1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e"},
{"path":"lrb_core/src/quorum.rs","ext":"rs","size":2031,"lines":51,"sha256":"8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2"},
{"path":"lrb_core/src/rcp_engine.rs","ext":"rs","size":1622,"lines":47,"sha256":"7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836"},
{"path":"lrb_core/src/resonance.rs","ext":"rs","size":1146,"lines":38,"sha256":"3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9"},
{"path":"lrb_core/src/sigpool.rs","ext":"rs","size":1072,"lines":33,"sha256":"9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175"},
{"path":"lrb_core/src/spam_guard.rs","ext":"rs","size":839,"lines":33,"sha256":"592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e"},
{"path":"lrb_core/src/types.rs","ext":"rs","size":1173,"lines":43,"sha256":"ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96"},
{"path":"node/Cargo.toml","ext":"toml","size":2162,"lines":75,"sha256":"d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b"},
{"path":"node/build.rs","ext":"rs","size":1722,"lines":43,"sha256":"65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf"},
{"path":"node/src/admin.rs","ext":"rs","size":2800,"lines":45,"sha256":"8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4"},
{"path":"node/src/api_extra.rs","ext":"rs","size":1886,"lines":37,"sha256":"a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c"},
{"path":"node/src/api.rs","ext":"rs","size":8182,"lines":185,"sha256":"eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9"},
{"path":"node/src/archive_ingest.rs","ext":"rs","size":1219,"lines":35,"sha256":"d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/auth.rs","ext":"rs","size":2349,"lines":63,"sha256":"cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"node/src/bridge.rs","ext":"rs","size":3551,"lines":89,"sha256":"0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186"},
{"path":"node/src/fork.rs","ext":"rs","size":1328,"lines":40,"sha256":"d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b"},
{"path":"node/src/gossip.rs","ext":"rs","size":1539,"lines":45,"sha256":"6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5"},
{"path":"node/src/guard.rs","ext":"rs","size":3418,"lines":77,"sha256":"aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399"},
{"path":"node/src/history_sled.rs","ext":"rs","size":1044,"lines":30,"sha256":"1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9"},
{"path":"node/src/lib.rs","ext":"rs","size":831,"lines":24,"sha256":"7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb"},
{"path":"node/src/main.rs","ext":"rs","size":3027,"lines":88,"sha256":"b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76"},
{"path":"node/src/metrics.rs","ext":"rs","size":3597,"lines":103,"sha256":"54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846"},
{"path":"node/src/openapi.rs","ext":"rs","size":441,"lines":14,"sha256":"184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b"},
{"path":"node/src/peers.rs","ext":"rs","size":4932,"lines":158,"sha256":"8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63"},
{"path":"node/src/producer.rs","ext":"rs","size":1704,"lines":44,"sha256":"fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e"},
{"path":"node/src/stake_api.rs","ext":"rs","size":2668,"lines":52,"sha256":"53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536"},
{"path":"node/src/stake.rs","ext":"rs","size":7692,"lines":162,"sha256":"8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8"},
{"path":"node/src/staking.rs","ext":"rs","size":339,"lines":9,"sha256":"e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01"},
{"path":"node/src/state.rs","ext":"rs","size":1182,"lines":35,"sha256":"621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5"},
{"path":"node/src/storage.rs","ext":"rs","size":1031,"lines":31,"sha256":"12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7"},
{"path":"node/src/types.rs","ext":"rs","size":430,"lines":17,"sha256":"33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0"},
{"path":"node/src/version.rs","ext":"rs","size":495,"lines":21,"sha256":"2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e"},
{"path":"node/src/wallet.rs","ext":"rs","size":913,"lines":26,"sha256":"c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"modules/beacon_emitter.rs","ext":"rs","size":4455,"lines":139,"sha256":"34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd"},
{"path":"modules/external_phase_broadcaster.rs","ext":"rs","size":1588,"lines":44,"sha256":"788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb"},
{"path":"modules/external_phase_link.rs","ext":"rs","size":997,"lines":33,"sha256":"56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91"},
{"path":"modules/genesis_fragment_seeds.rs","ext":"rs","size":1423,"lines":25,"sha256":"829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b"},
{"path":"modules/heartbeat_monitor.rs","ext":"rs","size":1489,"lines":26,"sha256":"ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf"},
{"path":"modules/legacy_migrator.rs","ext":"rs","size":1432,"lines":25,"sha256":"2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8"},
{"path":"modules/ritual_engine.rs","ext":"rs","size":1460,"lines":25,"sha256":"b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef"},
{"path":"modules/uplink_controller.rs","ext":"rs","size":1571,"lines":43,"sha256":"520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1"},
{"path":"modules/uplink_router.rs","ext":"rs","size":1551,"lines":43,"sha256":"ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49"},
{"path":"modules/go_to_market.yaml","ext":"yaml","size":3633,"lines":118,"sha256":"e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f"},
{"path":"modules/maintenance_strategy.yaml","ext":"yaml","size":2361,"lines":85,"sha256":"a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9"},
{"path":"modules/resonance_emergency_plan.yaml","ext":"yaml","size":3420,"lines":91,"sha256":"ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd"},
{"path":"modules/resonance_meshmap.yaml","ext":"yaml","size":1877,"lines":89,"sha256":"8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6"},
{"path":"modules/env_impact_tracker.py","ext":"py","size":5447,"lines":132,"sha256":"b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb"},
{"path":"modules/resonance_tutor.py","ext":"py","size":6414,"lines":135,"sha256":"42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f"},
{"path":"modules/symbolic_parser.py","ext":"py","size":4615,"lines":110,"sha256":"99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8"},
{"path":"www/explorer/index.html","ext":"html","size":1880,"lines":36,"sha256":"1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a"},
{"path":"www/index.html","ext":"html","size":4902,"lines":124,"sha256":"7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b"},
{"path":"www/wallet3/index.html","ext":"html","size":3528,"lines":88,"sha256":"16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717"},
{"path":"www/wallet/app.html","ext":"html","size":3367,"lines":74,"sha256":"634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2"},
{"path":"www/wallet/index.html","ext":"html","size":4490,"lines":104,"sha256":"e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde"},
{"path":"www/wallet/login.html","ext":"html","size":2647,"lines":56,"sha256":"3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76"},
{"path":"www/explorer/explorer.js","ext":"js","size":3977,"lines":82,"sha256":"bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b"},
{"path":"www/wallet3/app.v3.js","ext":"js","size":6763,"lines":107,"sha256":"2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349"},
{"path":"www/wallet/app.js","ext":"js","size":7641,"lines":148,"sha256":"a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9"},
{"path":"www/wallet/app.v2.js","ext":"js","size":7526,"lines":136,"sha256":"e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2"},
{"path":"www/wallet/app.v3.js","ext":"js","size":6952,"lines":117,"sha256":"e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b"},
{"path":"www/wallet/auth.js","ext":"js","size":6002,"lines":117,"sha256":"fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a"},
{"path":"www/wallet.js","ext":"js","size":5287,"lines":137,"sha256":"8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc"},
{"path":"www/wallet/staking.js","ext":"js","size":2843,"lines":42,"sha256":"ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80"},
{"path":"www/wallet/wallet.js","ext":"js","size":9153,"lines":168,"sha256":"5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c"},
{"path":"www/explorer/explorer.css","ext":"css","size":898,"lines":10,"sha256":"0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba"},
{"path":"www/wallet/wallet.css","ext":"css","size":2693,"lines":73,"sha256":"1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad"},
{"path":"configs/genesis.yaml","ext":"yaml","size":811,"lines":30,"sha256":"a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972"},
{"path":"configs/logos_config.yaml","ext":"yaml","size":448,"lines":27,"sha256":"6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b"},
{"path":"configs/env/node-a.env.example","ext":"example","size":254,"lines":8,"sha256":"cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f"},
{"path":"configs/env/node-b.env.example","ext":"example","size":254,"lines":8,"sha256":"91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3"},
{"path":"configs/env/node-c.env.example","ext":"example","size":254,"lines":8,"sha256":"448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290"},
{"path":"scripts/bootstrap_node.sh","ext":"sh","size":1556,"lines":38,"sha256":"6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c"},
{"path":"scripts/collect_and_push.sh","ext":"sh","size":3118,"lines":104,"sha256":"9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a"},
{"path":"scripts/logos_healthcheck.sh","ext":"sh","size":1689,"lines":52,"sha256":"ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec"},
{"path":"infra/systemd/logos-healthcheck.service","ext":"service","size":217,"lines":9,"sha256":"32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81"},
{"path":"infra/systemd/logos-node.service","ext":"service","size":369,"lines":19,"sha256":"464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95"},
{"path":"infra/systemd/logos-node@.service","ext":"service","size":412,"lines":23,"sha256":"9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb"},
{"path":"infra/systemd/logos-snapshot.service","ext":"service","size":271,"lines":8,"sha256":"1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1"},
{"path":"infra/systemd/lrb-proxy.service","ext":"service","size":395,"lines":16,"sha256":"008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed"},
{"path":"infra/systemd/lrb-scanner.service","ext":"service","size":378,"lines":16,"sha256":"35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260"},
{"path":"infra/systemd/exec.conf","ext":"conf","size":85,"lines":4,"sha256":"cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a"},
{"path":"infra/systemd/keys.conf","ext":"conf","size":226,"lines":7,"sha256":"82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2"},
{"path":"infra/systemd/override.conf","ext":"conf","size":575,"lines":16,"sha256":"0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6"},
{"path":"infra/systemd/runas.conf","ext":"conf","size":143,"lines":5,"sha256":"8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c"},
{"path":"infra/systemd/security.conf","ext":"conf","size":337,"lines":14,"sha256":"da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914"},
{"path":"infra/systemd/tuning.conf","ext":"conf","size":156,"lines":5,"sha256":"d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8"},
{"path":"infra/systemd/zz-consensus.conf","ext":"conf","size":137,"lines":4,"sha256":"b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171"},
{"path":"infra/systemd/zz-keys.conf","ext":"conf","size":417,"lines":9,"sha256":"4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87"},
{"path":"infra/systemd/zz-logging.conf","ext":"conf","size":36,"lines":2,"sha256":"d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a"},
{"path":"infra/nginx/lrb_wallet.conf","ext":"conf","size":3062,"lines":88,"sha256":"c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126"}
]}

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-17-49Z.txt  (size=1146b)
```text
# LOGOS LRB — modules inventory (UTC 2025-09-18T08-17-49Z)

ROOT: /root/logos_lrb

## CORE (lrb_core)

## NODE (node)

## MODULES (service modules)

## WWW (wallet/explorer static)

## CONFIGS

## SCRIPTS

## INFRA (systemd/nginx templates)


## SUMMARY
files_total: 113
lines_total: 6609
size_total_bytes: 269284
## CONSISTENCY CHECKS

main.rs -> module presence:
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)
  MISS:  => node/src/.rs (not found)

openapi.rs -> include_str! payloads:
  MISS: node/src/openapi/openapi.json (not found)

DIR OK: lrb_core/src
DIR OK: node/src
DIR OK: modules
DIR OK: www
DIR OK: configs
DIR OK: scripts

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-20-54Z.csv  (size=11481b)
```text
path,ext,size_bytes,lines,sha256
lrb_core/Cargo.toml,toml,864,32,8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012
lrb_core/src/anti_replay.rs,rs,980,35,b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5
lrb_core/src/beacon.rs,rs,1821,61,3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6
lrb_core/src/crypto.rs,rs,1929,48,4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2
lrb_core/src/dynamic_balance.rs,rs,609,18,f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4
lrb_core/src/engine.rs,rs,6769,153,094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64
lrb_core/src/heartbeat.rs,rs,2166,78,03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9
lrb_core/src/ledger.rs,rs,10076,227,9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05
lrb_core/src/lib.rs,rs,499,12,01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b
lrb_core/src/phase_consensus.rs,rs,1806,52,804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43
lrb_core/src/phase_filters/mod.rs,rs,249,8,b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29
lrb_core/src/phase_integrity.rs,rs,1695,38,1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e
lrb_core/src/quorum.rs,rs,2031,51,8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2
lrb_core/src/rcp_engine.rs,rs,1622,47,7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836
lrb_core/src/resonance.rs,rs,1146,38,3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9
lrb_core/src/sigpool.rs,rs,1072,33,9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175
lrb_core/src/spam_guard.rs,rs,839,33,592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e
lrb_core/src/types.rs,rs,1173,43,ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96
node/Cargo.toml,toml,2162,75,d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b
node/build.rs,rs,1722,43,65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf
node/src/admin.rs,rs,2800,45,8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4
node/src/api_extra.rs,rs,1886,37,a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c
node/src/api.rs,rs,8182,185,eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9
node/src/archive_ingest.rs,rs,1219,35,d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/auth.rs,rs,2349,63,cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
node/src/bridge.rs,rs,3551,89,0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186
node/src/fork.rs,rs,1328,40,d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b
node/src/gossip.rs,rs,1539,45,6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5
node/src/guard.rs,rs,3418,77,aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399
node/src/history_sled.rs,rs,1044,30,1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9
node/src/lib.rs,rs,831,24,7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb
node/src/main.rs,rs,3027,88,b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76
node/src/metrics.rs,rs,3597,103,54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846
node/src/openapi.rs,rs,441,14,184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b
node/src/peers.rs,rs,4932,158,8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63
node/src/producer.rs,rs,1704,44,fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e
node/src/stake_api.rs,rs,2668,52,53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536
node/src/stake.rs,rs,7692,162,8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8
node/src/staking.rs,rs,339,9,e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01
node/src/state.rs,rs,1182,35,621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5
node/src/storage.rs,rs,1031,31,12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7
node/src/types.rs,rs,430,17,33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0
node/src/version.rs,rs,495,21,2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e
node/src/wallet.rs,rs,913,26,c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
modules/beacon_emitter.rs,rs,4455,139,34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd
modules/external_phase_broadcaster.rs,rs,1588,44,788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb
modules/external_phase_link.rs,rs,997,33,56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91
modules/genesis_fragment_seeds.rs,rs,1423,25,829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b
modules/heartbeat_monitor.rs,rs,1489,26,ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf
modules/legacy_migrator.rs,rs,1432,25,2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8
modules/ritual_engine.rs,rs,1460,25,b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef
modules/uplink_controller.rs,rs,1571,43,520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1
modules/uplink_router.rs,rs,1551,43,ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49
modules/go_to_market.yaml,yaml,3633,118,e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f
modules/maintenance_strategy.yaml,yaml,2361,85,a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9
modules/resonance_emergency_plan.yaml,yaml,3420,91,ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd
modules/resonance_meshmap.yaml,yaml,1877,89,8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6
modules/env_impact_tracker.py,py,5447,132,b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb
modules/resonance_tutor.py,py,6414,135,42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f
modules/symbolic_parser.py,py,4615,110,99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8
www/explorer/index.html,html,1880,36,1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a
www/index.html,html,4902,124,7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b
www/wallet3/index.html,html,3528,88,16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717
www/wallet/app.html,html,3367,74,634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2
www/wallet/index.html,html,4490,104,e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde
www/wallet/login.html,html,2647,56,3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76
www/explorer/explorer.js,js,3977,82,bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b
www/wallet3/app.v3.js,js,6763,107,2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349
www/wallet/app.js,js,7641,148,a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9
www/wallet/app.v2.js,js,7526,136,e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2
www/wallet/app.v3.js,js,6952,117,e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b
www/wallet/auth.js,js,6002,117,fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a
www/wallet.js,js,5287,137,8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc
www/wallet/staking.js,js,2843,42,ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80
www/wallet/wallet.js,js,9153,168,5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c
www/explorer/explorer.css,css,898,10,0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba
www/wallet/wallet.css,css,2693,73,1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad
configs/genesis.yaml,yaml,811,30,a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972
configs/logos_config.yaml,yaml,448,27,6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b
configs/env/node-a.env.example,example,254,8,cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f
configs/env/node-b.env.example,example,254,8,91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3
configs/env/node-c.env.example,example,254,8,448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290
scripts/bootstrap_node.sh,sh,1556,38,6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c
scripts/collect_and_push.sh,sh,3118,104,9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a
scripts/logos_healthcheck.sh,sh,1689,52,ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec
infra/systemd/logos-healthcheck.service,service,217,9,32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81
infra/systemd/logos-node.service,service,369,19,464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95
infra/systemd/logos-node@.service,service,412,23,9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb
infra/systemd/logos-snapshot.service,service,271,8,1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1
infra/systemd/lrb-proxy.service,service,395,16,008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed
infra/systemd/lrb-scanner.service,service,378,16,35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260
infra/systemd/exec.conf,conf,85,4,cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a
infra/systemd/keys.conf,conf,226,7,82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2
infra/systemd/override.conf,conf,575,16,0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6
infra/systemd/runas.conf,conf,143,5,8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c
infra/systemd/security.conf,conf,337,14,da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914
infra/systemd/tuning.conf,conf,156,5,d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8
infra/systemd/zz-consensus.conf,conf,137,4,b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171
infra/systemd/zz-keys.conf,conf,417,9,4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87
infra/systemd/zz-logging.conf,conf,36,2,d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a
infra/nginx/lrb_wallet.conf,conf,3062,88,c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-20-54Z.json  (size=16694b)
```json
{"generated":"2025-09-18T08-20-54Z","files":[
{"path":"lrb_core/Cargo.toml","ext":"toml","size":864,"lines":32,"sha256":"8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012"},
{"path":"lrb_core/src/anti_replay.rs","ext":"rs","size":980,"lines":35,"sha256":"b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5"},
{"path":"lrb_core/src/beacon.rs","ext":"rs","size":1821,"lines":61,"sha256":"3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6"},
{"path":"lrb_core/src/crypto.rs","ext":"rs","size":1929,"lines":48,"sha256":"4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2"},
{"path":"lrb_core/src/dynamic_balance.rs","ext":"rs","size":609,"lines":18,"sha256":"f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4"},
{"path":"lrb_core/src/engine.rs","ext":"rs","size":6769,"lines":153,"sha256":"094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64"},
{"path":"lrb_core/src/heartbeat.rs","ext":"rs","size":2166,"lines":78,"sha256":"03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9"},
{"path":"lrb_core/src/ledger.rs","ext":"rs","size":10076,"lines":227,"sha256":"9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05"},
{"path":"lrb_core/src/lib.rs","ext":"rs","size":499,"lines":12,"sha256":"01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b"},
{"path":"lrb_core/src/phase_consensus.rs","ext":"rs","size":1806,"lines":52,"sha256":"804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43"},
{"path":"lrb_core/src/phase_filters/mod.rs","ext":"rs","size":249,"lines":8,"sha256":"b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29"},
{"path":"lrb_core/src/phase_integrity.rs","ext":"rs","size":1695,"lines":38,"sha256":"1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e"},
{"path":"lrb_core/src/quorum.rs","ext":"rs","size":2031,"lines":51,"sha256":"8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2"},
{"path":"lrb_core/src/rcp_engine.rs","ext":"rs","size":1622,"lines":47,"sha256":"7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836"},
{"path":"lrb_core/src/resonance.rs","ext":"rs","size":1146,"lines":38,"sha256":"3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9"},
{"path":"lrb_core/src/sigpool.rs","ext":"rs","size":1072,"lines":33,"sha256":"9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175"},
{"path":"lrb_core/src/spam_guard.rs","ext":"rs","size":839,"lines":33,"sha256":"592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e"},
{"path":"lrb_core/src/types.rs","ext":"rs","size":1173,"lines":43,"sha256":"ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96"},
{"path":"node/Cargo.toml","ext":"toml","size":2162,"lines":75,"sha256":"d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b"},
{"path":"node/build.rs","ext":"rs","size":1722,"lines":43,"sha256":"65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf"},
{"path":"node/src/admin.rs","ext":"rs","size":2800,"lines":45,"sha256":"8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4"},
{"path":"node/src/api_extra.rs","ext":"rs","size":1886,"lines":37,"sha256":"a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c"},
{"path":"node/src/api.rs","ext":"rs","size":8182,"lines":185,"sha256":"eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9"},
{"path":"node/src/archive_ingest.rs","ext":"rs","size":1219,"lines":35,"sha256":"d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/auth.rs","ext":"rs","size":2349,"lines":63,"sha256":"cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"node/src/bridge.rs","ext":"rs","size":3551,"lines":89,"sha256":"0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186"},
{"path":"node/src/fork.rs","ext":"rs","size":1328,"lines":40,"sha256":"d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b"},
{"path":"node/src/gossip.rs","ext":"rs","size":1539,"lines":45,"sha256":"6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5"},
{"path":"node/src/guard.rs","ext":"rs","size":3418,"lines":77,"sha256":"aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399"},
{"path":"node/src/history_sled.rs","ext":"rs","size":1044,"lines":30,"sha256":"1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9"},
{"path":"node/src/lib.rs","ext":"rs","size":831,"lines":24,"sha256":"7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb"},
{"path":"node/src/main.rs","ext":"rs","size":3027,"lines":88,"sha256":"b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76"},
{"path":"node/src/metrics.rs","ext":"rs","size":3597,"lines":103,"sha256":"54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846"},
{"path":"node/src/openapi.rs","ext":"rs","size":441,"lines":14,"sha256":"184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b"},
{"path":"node/src/peers.rs","ext":"rs","size":4932,"lines":158,"sha256":"8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63"},
{"path":"node/src/producer.rs","ext":"rs","size":1704,"lines":44,"sha256":"fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e"},
{"path":"node/src/stake_api.rs","ext":"rs","size":2668,"lines":52,"sha256":"53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536"},
{"path":"node/src/stake.rs","ext":"rs","size":7692,"lines":162,"sha256":"8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8"},
{"path":"node/src/staking.rs","ext":"rs","size":339,"lines":9,"sha256":"e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01"},
{"path":"node/src/state.rs","ext":"rs","size":1182,"lines":35,"sha256":"621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5"},
{"path":"node/src/storage.rs","ext":"rs","size":1031,"lines":31,"sha256":"12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7"},
{"path":"node/src/types.rs","ext":"rs","size":430,"lines":17,"sha256":"33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0"},
{"path":"node/src/version.rs","ext":"rs","size":495,"lines":21,"sha256":"2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e"},
{"path":"node/src/wallet.rs","ext":"rs","size":913,"lines":26,"sha256":"c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"modules/beacon_emitter.rs","ext":"rs","size":4455,"lines":139,"sha256":"34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd"},
{"path":"modules/external_phase_broadcaster.rs","ext":"rs","size":1588,"lines":44,"sha256":"788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb"},
{"path":"modules/external_phase_link.rs","ext":"rs","size":997,"lines":33,"sha256":"56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91"},
{"path":"modules/genesis_fragment_seeds.rs","ext":"rs","size":1423,"lines":25,"sha256":"829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b"},
{"path":"modules/heartbeat_monitor.rs","ext":"rs","size":1489,"lines":26,"sha256":"ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf"},
{"path":"modules/legacy_migrator.rs","ext":"rs","size":1432,"lines":25,"sha256":"2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8"},
{"path":"modules/ritual_engine.rs","ext":"rs","size":1460,"lines":25,"sha256":"b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef"},
{"path":"modules/uplink_controller.rs","ext":"rs","size":1571,"lines":43,"sha256":"520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1"},
{"path":"modules/uplink_router.rs","ext":"rs","size":1551,"lines":43,"sha256":"ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49"},
{"path":"modules/go_to_market.yaml","ext":"yaml","size":3633,"lines":118,"sha256":"e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f"},
{"path":"modules/maintenance_strategy.yaml","ext":"yaml","size":2361,"lines":85,"sha256":"a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9"},
{"path":"modules/resonance_emergency_plan.yaml","ext":"yaml","size":3420,"lines":91,"sha256":"ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd"},
{"path":"modules/resonance_meshmap.yaml","ext":"yaml","size":1877,"lines":89,"sha256":"8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6"},
{"path":"modules/env_impact_tracker.py","ext":"py","size":5447,"lines":132,"sha256":"b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb"},
{"path":"modules/resonance_tutor.py","ext":"py","size":6414,"lines":135,"sha256":"42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f"},
{"path":"modules/symbolic_parser.py","ext":"py","size":4615,"lines":110,"sha256":"99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8"},
{"path":"www/explorer/index.html","ext":"html","size":1880,"lines":36,"sha256":"1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a"},
{"path":"www/index.html","ext":"html","size":4902,"lines":124,"sha256":"7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b"},
{"path":"www/wallet3/index.html","ext":"html","size":3528,"lines":88,"sha256":"16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717"},
{"path":"www/wallet/app.html","ext":"html","size":3367,"lines":74,"sha256":"634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2"},
{"path":"www/wallet/index.html","ext":"html","size":4490,"lines":104,"sha256":"e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde"},
{"path":"www/wallet/login.html","ext":"html","size":2647,"lines":56,"sha256":"3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76"},
{"path":"www/explorer/explorer.js","ext":"js","size":3977,"lines":82,"sha256":"bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b"},
{"path":"www/wallet3/app.v3.js","ext":"js","size":6763,"lines":107,"sha256":"2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349"},
{"path":"www/wallet/app.js","ext":"js","size":7641,"lines":148,"sha256":"a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9"},
{"path":"www/wallet/app.v2.js","ext":"js","size":7526,"lines":136,"sha256":"e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2"},
{"path":"www/wallet/app.v3.js","ext":"js","size":6952,"lines":117,"sha256":"e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b"},
{"path":"www/wallet/auth.js","ext":"js","size":6002,"lines":117,"sha256":"fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a"},
{"path":"www/wallet.js","ext":"js","size":5287,"lines":137,"sha256":"8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc"},
{"path":"www/wallet/staking.js","ext":"js","size":2843,"lines":42,"sha256":"ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80"},
{"path":"www/wallet/wallet.js","ext":"js","size":9153,"lines":168,"sha256":"5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c"},
{"path":"www/explorer/explorer.css","ext":"css","size":898,"lines":10,"sha256":"0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba"},
{"path":"www/wallet/wallet.css","ext":"css","size":2693,"lines":73,"sha256":"1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad"},
{"path":"configs/genesis.yaml","ext":"yaml","size":811,"lines":30,"sha256":"a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972"},
{"path":"configs/logos_config.yaml","ext":"yaml","size":448,"lines":27,"sha256":"6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b"},
{"path":"configs/env/node-a.env.example","ext":"example","size":254,"lines":8,"sha256":"cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f"},
{"path":"configs/env/node-b.env.example","ext":"example","size":254,"lines":8,"sha256":"91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3"},
{"path":"configs/env/node-c.env.example","ext":"example","size":254,"lines":8,"sha256":"448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290"},
{"path":"scripts/bootstrap_node.sh","ext":"sh","size":1556,"lines":38,"sha256":"6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c"},
{"path":"scripts/collect_and_push.sh","ext":"sh","size":3118,"lines":104,"sha256":"9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a"},
{"path":"scripts/logos_healthcheck.sh","ext":"sh","size":1689,"lines":52,"sha256":"ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec"},
{"path":"infra/systemd/logos-healthcheck.service","ext":"service","size":217,"lines":9,"sha256":"32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81"},
{"path":"infra/systemd/logos-node.service","ext":"service","size":369,"lines":19,"sha256":"464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95"},
{"path":"infra/systemd/logos-node@.service","ext":"service","size":412,"lines":23,"sha256":"9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb"},
{"path":"infra/systemd/logos-snapshot.service","ext":"service","size":271,"lines":8,"sha256":"1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1"},
{"path":"infra/systemd/lrb-proxy.service","ext":"service","size":395,"lines":16,"sha256":"008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed"},
{"path":"infra/systemd/lrb-scanner.service","ext":"service","size":378,"lines":16,"sha256":"35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260"},
{"path":"infra/systemd/exec.conf","ext":"conf","size":85,"lines":4,"sha256":"cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a"},
{"path":"infra/systemd/keys.conf","ext":"conf","size":226,"lines":7,"sha256":"82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2"},
{"path":"infra/systemd/override.conf","ext":"conf","size":575,"lines":16,"sha256":"0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6"},
{"path":"infra/systemd/runas.conf","ext":"conf","size":143,"lines":5,"sha256":"8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c"},
{"path":"infra/systemd/security.conf","ext":"conf","size":337,"lines":14,"sha256":"da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914"},
{"path":"infra/systemd/tuning.conf","ext":"conf","size":156,"lines":5,"sha256":"d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8"},
{"path":"infra/systemd/zz-consensus.conf","ext":"conf","size":137,"lines":4,"sha256":"b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171"},
{"path":"infra/systemd/zz-keys.conf","ext":"conf","size":417,"lines":9,"sha256":"4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87"},
{"path":"infra/systemd/zz-logging.conf","ext":"conf","size":36,"lines":2,"sha256":"d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a"},
{"path":"infra/nginx/lrb_wallet.conf","ext":"conf","size":3062,"lines":88,"sha256":"c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126"}
]}

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-20-54Z.txt  (size=1121b)
```text
# LOGOS LRB — modules inventory (UTC 2025-09-18T08-20-54Z)
ROOT: /root/logos_lrb

## CORE (lrb_core)

## NODE (node)

## MODULES (service modules)

## WWW (wallet/explorer static)

## CONFIGS

## SCRIPTS

## INFRA (systemd/nginx templates)


## SUMMARY
files_total: 113
lines_total: 6609
size_total_bytes: 269284
## CONSISTENCY CHECKS

main.rs -> module presence:
  OK: admin => node/src/admin.rs
  OK: api => node/src/api.rs
  MISS: archive => node/src/archive.rs (not found)
  OK: auth => node/src/auth.rs
  OK: bridge => node/src/bridge.rs
  OK: gossip => node/src/gossip.rs
  OK: guard => node/src/guard.rs
  OK: metrics => node/src/metrics.rs
  OK: openapi => node/src/openapi.rs
  OK: peers => node/src/peers.rs
  OK: producer => node/src/producer.rs
  OK: stake => node/src/stake.rs
  OK: state => node/src/state.rs
  OK: storage => node/src/storage.rs
  OK: version => node/src/version.rs
  OK: wallet => node/src/wallet.rs

openapi.rs -> include_str! payloads:
  MISS: node/src/openapi/openapi.json (not found)

DIR OK: lrb_core/src
DIR OK: node/src
DIR OK: modules
DIR OK: www
DIR OK: configs
DIR OK: scripts

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-25-35Z.csv  (size=11481b)
```text
path,ext,size_bytes,lines,sha256
lrb_core/Cargo.toml,toml,864,32,8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012
lrb_core/src/anti_replay.rs,rs,980,35,b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5
lrb_core/src/beacon.rs,rs,1821,61,3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6
lrb_core/src/crypto.rs,rs,1929,48,4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2
lrb_core/src/dynamic_balance.rs,rs,609,18,f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4
lrb_core/src/engine.rs,rs,6769,153,094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64
lrb_core/src/heartbeat.rs,rs,2166,78,03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9
lrb_core/src/ledger.rs,rs,10076,227,9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05
lrb_core/src/lib.rs,rs,499,12,01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b
lrb_core/src/phase_consensus.rs,rs,1806,52,804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43
lrb_core/src/phase_filters/mod.rs,rs,249,8,b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29
lrb_core/src/phase_integrity.rs,rs,1695,38,1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e
lrb_core/src/quorum.rs,rs,2031,51,8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2
lrb_core/src/rcp_engine.rs,rs,1622,47,7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836
lrb_core/src/resonance.rs,rs,1146,38,3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9
lrb_core/src/sigpool.rs,rs,1072,33,9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175
lrb_core/src/spam_guard.rs,rs,839,33,592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e
lrb_core/src/types.rs,rs,1173,43,ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96
node/Cargo.toml,toml,2162,75,d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b
node/build.rs,rs,1722,43,65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf
node/src/admin.rs,rs,2800,45,8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4
node/src/api_extra.rs,rs,1886,37,a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c
node/src/api.rs,rs,8182,185,eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9
node/src/archive_ingest.rs,rs,1219,35,d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/auth.rs,rs,2349,63,cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
node/src/bridge.rs,rs,3551,89,0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186
node/src/fork.rs,rs,1328,40,d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b
node/src/gossip.rs,rs,1539,45,6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5
node/src/guard.rs,rs,3418,77,aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399
node/src/history_sled.rs,rs,1044,30,1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9
node/src/lib.rs,rs,831,24,7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb
node/src/main.rs,rs,3027,88,b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76
node/src/metrics.rs,rs,3597,103,54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846
node/src/openapi.rs,rs,441,14,184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b
node/src/peers.rs,rs,4932,158,8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63
node/src/producer.rs,rs,1704,44,fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e
node/src/stake_api.rs,rs,2668,52,53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536
node/src/stake.rs,rs,7692,162,8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8
node/src/staking.rs,rs,339,9,e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01
node/src/state.rs,rs,1182,35,621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5
node/src/storage.rs,rs,1031,31,12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7
node/src/types.rs,rs,430,17,33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0
node/src/version.rs,rs,495,21,2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e
node/src/wallet.rs,rs,913,26,c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
modules/beacon_emitter.rs,rs,4455,139,34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd
modules/external_phase_broadcaster.rs,rs,1588,44,788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb
modules/external_phase_link.rs,rs,997,33,56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91
modules/genesis_fragment_seeds.rs,rs,1423,25,829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b
modules/heartbeat_monitor.rs,rs,1489,26,ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf
modules/legacy_migrator.rs,rs,1432,25,2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8
modules/ritual_engine.rs,rs,1460,25,b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef
modules/uplink_controller.rs,rs,1571,43,520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1
modules/uplink_router.rs,rs,1551,43,ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49
modules/go_to_market.yaml,yaml,3633,118,e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f
modules/maintenance_strategy.yaml,yaml,2361,85,a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9
modules/resonance_emergency_plan.yaml,yaml,3420,91,ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd
modules/resonance_meshmap.yaml,yaml,1877,89,8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6
modules/env_impact_tracker.py,py,5447,132,b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb
modules/resonance_tutor.py,py,6414,135,42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f
modules/symbolic_parser.py,py,4615,110,99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8
www/explorer/index.html,html,1880,36,1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a
www/index.html,html,4902,124,7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b
www/wallet3/index.html,html,3528,88,16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717
www/wallet/app.html,html,3367,74,634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2
www/wallet/index.html,html,4490,104,e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde
www/wallet/login.html,html,2647,56,3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76
www/explorer/explorer.js,js,3977,82,bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b
www/wallet3/app.v3.js,js,6763,107,2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349
www/wallet/app.js,js,7641,148,a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9
www/wallet/app.v2.js,js,7526,136,e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2
www/wallet/app.v3.js,js,6952,117,e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b
www/wallet/auth.js,js,6002,117,fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a
www/wallet.js,js,5287,137,8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc
www/wallet/staking.js,js,2843,42,ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80
www/wallet/wallet.js,js,9153,168,5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c
www/explorer/explorer.css,css,898,10,0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba
www/wallet/wallet.css,css,2693,73,1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad
configs/genesis.yaml,yaml,811,30,a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972
configs/logos_config.yaml,yaml,448,27,6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b
configs/env/node-a.env.example,example,254,8,cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f
configs/env/node-b.env.example,example,254,8,91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3
configs/env/node-c.env.example,example,254,8,448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290
scripts/bootstrap_node.sh,sh,1556,38,6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c
scripts/collect_and_push.sh,sh,3118,104,9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a
scripts/logos_healthcheck.sh,sh,1689,52,ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec
infra/systemd/logos-healthcheck.service,service,217,9,32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81
infra/systemd/logos-node.service,service,369,19,464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95
infra/systemd/logos-node@.service,service,412,23,9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb
infra/systemd/logos-snapshot.service,service,271,8,1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1
infra/systemd/lrb-proxy.service,service,395,16,008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed
infra/systemd/lrb-scanner.service,service,378,16,35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260
infra/systemd/exec.conf,conf,85,4,cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a
infra/systemd/keys.conf,conf,226,7,82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2
infra/systemd/override.conf,conf,575,16,0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6
infra/systemd/runas.conf,conf,143,5,8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c
infra/systemd/security.conf,conf,337,14,da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914
infra/systemd/tuning.conf,conf,156,5,d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8
infra/systemd/zz-consensus.conf,conf,137,4,b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171
infra/systemd/zz-keys.conf,conf,417,9,4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87
infra/systemd/zz-logging.conf,conf,36,2,d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a
infra/nginx/lrb_wallet.conf,conf,3062,88,c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-25-35Z.json  (size=16694b)
```json
{"generated":"2025-09-18T08-25-35Z","files":[
{"path":"lrb_core/Cargo.toml","ext":"toml","size":864,"lines":32,"sha256":"8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012"},
{"path":"lrb_core/src/anti_replay.rs","ext":"rs","size":980,"lines":35,"sha256":"b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5"},
{"path":"lrb_core/src/beacon.rs","ext":"rs","size":1821,"lines":61,"sha256":"3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6"},
{"path":"lrb_core/src/crypto.rs","ext":"rs","size":1929,"lines":48,"sha256":"4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2"},
{"path":"lrb_core/src/dynamic_balance.rs","ext":"rs","size":609,"lines":18,"sha256":"f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4"},
{"path":"lrb_core/src/engine.rs","ext":"rs","size":6769,"lines":153,"sha256":"094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64"},
{"path":"lrb_core/src/heartbeat.rs","ext":"rs","size":2166,"lines":78,"sha256":"03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9"},
{"path":"lrb_core/src/ledger.rs","ext":"rs","size":10076,"lines":227,"sha256":"9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05"},
{"path":"lrb_core/src/lib.rs","ext":"rs","size":499,"lines":12,"sha256":"01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b"},
{"path":"lrb_core/src/phase_consensus.rs","ext":"rs","size":1806,"lines":52,"sha256":"804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43"},
{"path":"lrb_core/src/phase_filters/mod.rs","ext":"rs","size":249,"lines":8,"sha256":"b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29"},
{"path":"lrb_core/src/phase_integrity.rs","ext":"rs","size":1695,"lines":38,"sha256":"1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e"},
{"path":"lrb_core/src/quorum.rs","ext":"rs","size":2031,"lines":51,"sha256":"8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2"},
{"path":"lrb_core/src/rcp_engine.rs","ext":"rs","size":1622,"lines":47,"sha256":"7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836"},
{"path":"lrb_core/src/resonance.rs","ext":"rs","size":1146,"lines":38,"sha256":"3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9"},
{"path":"lrb_core/src/sigpool.rs","ext":"rs","size":1072,"lines":33,"sha256":"9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175"},
{"path":"lrb_core/src/spam_guard.rs","ext":"rs","size":839,"lines":33,"sha256":"592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e"},
{"path":"lrb_core/src/types.rs","ext":"rs","size":1173,"lines":43,"sha256":"ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96"},
{"path":"node/Cargo.toml","ext":"toml","size":2162,"lines":75,"sha256":"d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b"},
{"path":"node/build.rs","ext":"rs","size":1722,"lines":43,"sha256":"65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf"},
{"path":"node/src/admin.rs","ext":"rs","size":2800,"lines":45,"sha256":"8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4"},
{"path":"node/src/api_extra.rs","ext":"rs","size":1886,"lines":37,"sha256":"a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c"},
{"path":"node/src/api.rs","ext":"rs","size":8182,"lines":185,"sha256":"eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9"},
{"path":"node/src/archive_ingest.rs","ext":"rs","size":1219,"lines":35,"sha256":"d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/auth.rs","ext":"rs","size":2349,"lines":63,"sha256":"cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"node/src/bridge.rs","ext":"rs","size":3551,"lines":89,"sha256":"0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186"},
{"path":"node/src/fork.rs","ext":"rs","size":1328,"lines":40,"sha256":"d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b"},
{"path":"node/src/gossip.rs","ext":"rs","size":1539,"lines":45,"sha256":"6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5"},
{"path":"node/src/guard.rs","ext":"rs","size":3418,"lines":77,"sha256":"aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399"},
{"path":"node/src/history_sled.rs","ext":"rs","size":1044,"lines":30,"sha256":"1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9"},
{"path":"node/src/lib.rs","ext":"rs","size":831,"lines":24,"sha256":"7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb"},
{"path":"node/src/main.rs","ext":"rs","size":3027,"lines":88,"sha256":"b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76"},
{"path":"node/src/metrics.rs","ext":"rs","size":3597,"lines":103,"sha256":"54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846"},
{"path":"node/src/openapi.rs","ext":"rs","size":441,"lines":14,"sha256":"184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b"},
{"path":"node/src/peers.rs","ext":"rs","size":4932,"lines":158,"sha256":"8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63"},
{"path":"node/src/producer.rs","ext":"rs","size":1704,"lines":44,"sha256":"fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e"},
{"path":"node/src/stake_api.rs","ext":"rs","size":2668,"lines":52,"sha256":"53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536"},
{"path":"node/src/stake.rs","ext":"rs","size":7692,"lines":162,"sha256":"8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8"},
{"path":"node/src/staking.rs","ext":"rs","size":339,"lines":9,"sha256":"e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01"},
{"path":"node/src/state.rs","ext":"rs","size":1182,"lines":35,"sha256":"621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5"},
{"path":"node/src/storage.rs","ext":"rs","size":1031,"lines":31,"sha256":"12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7"},
{"path":"node/src/types.rs","ext":"rs","size":430,"lines":17,"sha256":"33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0"},
{"path":"node/src/version.rs","ext":"rs","size":495,"lines":21,"sha256":"2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e"},
{"path":"node/src/wallet.rs","ext":"rs","size":913,"lines":26,"sha256":"c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"modules/beacon_emitter.rs","ext":"rs","size":4455,"lines":139,"sha256":"34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd"},
{"path":"modules/external_phase_broadcaster.rs","ext":"rs","size":1588,"lines":44,"sha256":"788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb"},
{"path":"modules/external_phase_link.rs","ext":"rs","size":997,"lines":33,"sha256":"56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91"},
{"path":"modules/genesis_fragment_seeds.rs","ext":"rs","size":1423,"lines":25,"sha256":"829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b"},
{"path":"modules/heartbeat_monitor.rs","ext":"rs","size":1489,"lines":26,"sha256":"ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf"},
{"path":"modules/legacy_migrator.rs","ext":"rs","size":1432,"lines":25,"sha256":"2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8"},
{"path":"modules/ritual_engine.rs","ext":"rs","size":1460,"lines":25,"sha256":"b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef"},
{"path":"modules/uplink_controller.rs","ext":"rs","size":1571,"lines":43,"sha256":"520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1"},
{"path":"modules/uplink_router.rs","ext":"rs","size":1551,"lines":43,"sha256":"ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49"},
{"path":"modules/go_to_market.yaml","ext":"yaml","size":3633,"lines":118,"sha256":"e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f"},
{"path":"modules/maintenance_strategy.yaml","ext":"yaml","size":2361,"lines":85,"sha256":"a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9"},
{"path":"modules/resonance_emergency_plan.yaml","ext":"yaml","size":3420,"lines":91,"sha256":"ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd"},
{"path":"modules/resonance_meshmap.yaml","ext":"yaml","size":1877,"lines":89,"sha256":"8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6"},
{"path":"modules/env_impact_tracker.py","ext":"py","size":5447,"lines":132,"sha256":"b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb"},
{"path":"modules/resonance_tutor.py","ext":"py","size":6414,"lines":135,"sha256":"42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f"},
{"path":"modules/symbolic_parser.py","ext":"py","size":4615,"lines":110,"sha256":"99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8"},
{"path":"www/explorer/index.html","ext":"html","size":1880,"lines":36,"sha256":"1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a"},
{"path":"www/index.html","ext":"html","size":4902,"lines":124,"sha256":"7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b"},
{"path":"www/wallet3/index.html","ext":"html","size":3528,"lines":88,"sha256":"16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717"},
{"path":"www/wallet/app.html","ext":"html","size":3367,"lines":74,"sha256":"634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2"},
{"path":"www/wallet/index.html","ext":"html","size":4490,"lines":104,"sha256":"e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde"},
{"path":"www/wallet/login.html","ext":"html","size":2647,"lines":56,"sha256":"3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76"},
{"path":"www/explorer/explorer.js","ext":"js","size":3977,"lines":82,"sha256":"bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b"},
{"path":"www/wallet3/app.v3.js","ext":"js","size":6763,"lines":107,"sha256":"2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349"},
{"path":"www/wallet/app.js","ext":"js","size":7641,"lines":148,"sha256":"a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9"},
{"path":"www/wallet/app.v2.js","ext":"js","size":7526,"lines":136,"sha256":"e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2"},
{"path":"www/wallet/app.v3.js","ext":"js","size":6952,"lines":117,"sha256":"e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b"},
{"path":"www/wallet/auth.js","ext":"js","size":6002,"lines":117,"sha256":"fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a"},
{"path":"www/wallet.js","ext":"js","size":5287,"lines":137,"sha256":"8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc"},
{"path":"www/wallet/staking.js","ext":"js","size":2843,"lines":42,"sha256":"ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80"},
{"path":"www/wallet/wallet.js","ext":"js","size":9153,"lines":168,"sha256":"5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c"},
{"path":"www/explorer/explorer.css","ext":"css","size":898,"lines":10,"sha256":"0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba"},
{"path":"www/wallet/wallet.css","ext":"css","size":2693,"lines":73,"sha256":"1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad"},
{"path":"configs/genesis.yaml","ext":"yaml","size":811,"lines":30,"sha256":"a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972"},
{"path":"configs/logos_config.yaml","ext":"yaml","size":448,"lines":27,"sha256":"6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b"},
{"path":"configs/env/node-a.env.example","ext":"example","size":254,"lines":8,"sha256":"cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f"},
{"path":"configs/env/node-b.env.example","ext":"example","size":254,"lines":8,"sha256":"91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3"},
{"path":"configs/env/node-c.env.example","ext":"example","size":254,"lines":8,"sha256":"448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290"},
{"path":"scripts/bootstrap_node.sh","ext":"sh","size":1556,"lines":38,"sha256":"6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c"},
{"path":"scripts/collect_and_push.sh","ext":"sh","size":3118,"lines":104,"sha256":"9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a"},
{"path":"scripts/logos_healthcheck.sh","ext":"sh","size":1689,"lines":52,"sha256":"ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec"},
{"path":"infra/systemd/logos-healthcheck.service","ext":"service","size":217,"lines":9,"sha256":"32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81"},
{"path":"infra/systemd/logos-node.service","ext":"service","size":369,"lines":19,"sha256":"464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95"},
{"path":"infra/systemd/logos-node@.service","ext":"service","size":412,"lines":23,"sha256":"9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb"},
{"path":"infra/systemd/logos-snapshot.service","ext":"service","size":271,"lines":8,"sha256":"1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1"},
{"path":"infra/systemd/lrb-proxy.service","ext":"service","size":395,"lines":16,"sha256":"008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed"},
{"path":"infra/systemd/lrb-scanner.service","ext":"service","size":378,"lines":16,"sha256":"35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260"},
{"path":"infra/systemd/exec.conf","ext":"conf","size":85,"lines":4,"sha256":"cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a"},
{"path":"infra/systemd/keys.conf","ext":"conf","size":226,"lines":7,"sha256":"82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2"},
{"path":"infra/systemd/override.conf","ext":"conf","size":575,"lines":16,"sha256":"0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6"},
{"path":"infra/systemd/runas.conf","ext":"conf","size":143,"lines":5,"sha256":"8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c"},
{"path":"infra/systemd/security.conf","ext":"conf","size":337,"lines":14,"sha256":"da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914"},
{"path":"infra/systemd/tuning.conf","ext":"conf","size":156,"lines":5,"sha256":"d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8"},
{"path":"infra/systemd/zz-consensus.conf","ext":"conf","size":137,"lines":4,"sha256":"b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171"},
{"path":"infra/systemd/zz-keys.conf","ext":"conf","size":417,"lines":9,"sha256":"4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87"},
{"path":"infra/systemd/zz-logging.conf","ext":"conf","size":36,"lines":2,"sha256":"d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a"},
{"path":"infra/nginx/lrb_wallet.conf","ext":"conf","size":3062,"lines":88,"sha256":"c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126"}
]}

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-25-35Z.txt  (size=1111b)
```text
# LOGOS LRB — modules inventory (UTC 2025-09-18T08-25-35Z)
ROOT: /root/logos_lrb

## CORE (lrb_core)

## NODE (node)

## MODULES (service modules)

## WWW (wallet/explorer static)

## CONFIGS

## SCRIPTS

## INFRA (systemd/nginx templates)


## SUMMARY
files_total: 113
lines_total: 6609
size_total_bytes: 269284
## CONSISTENCY CHECKS

main.rs -> module presence:
  OK: admin => node/src/admin.rs
  OK: api => node/src/api.rs
  OK: archive => node/src/archive/mod.rs
  OK: auth => node/src/auth.rs
  OK: bridge => node/src/bridge.rs
  OK: gossip => node/src/gossip.rs
  OK: guard => node/src/guard.rs
  OK: metrics => node/src/metrics.rs
  OK: openapi => node/src/openapi.rs
  OK: peers => node/src/peers.rs
  OK: producer => node/src/producer.rs
  OK: stake => node/src/stake.rs
  OK: state => node/src/state.rs
  OK: storage => node/src/storage.rs
  OK: version => node/src/version.rs
  OK: wallet => node/src/wallet.rs

openapi.rs -> include_str! payloads:
  MISS: node/src/openapi/openapi.json (not found)

DIR OK: lrb_core/src
DIR OK: node/src
DIR OK: modules
DIR OK: www
DIR OK: configs
DIR OK: scripts

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-26-33Z.csv  (size=11589b)
```text
path,ext,size_bytes,lines,sha256
lrb_core/Cargo.toml,toml,864,32,8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012
lrb_core/src/anti_replay.rs,rs,980,35,b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5
lrb_core/src/beacon.rs,rs,1821,61,3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6
lrb_core/src/crypto.rs,rs,1929,48,4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2
lrb_core/src/dynamic_balance.rs,rs,609,18,f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4
lrb_core/src/engine.rs,rs,6769,153,094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64
lrb_core/src/heartbeat.rs,rs,2166,78,03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9
lrb_core/src/ledger.rs,rs,10076,227,9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05
lrb_core/src/lib.rs,rs,499,12,01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b
lrb_core/src/phase_consensus.rs,rs,1806,52,804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43
lrb_core/src/phase_filters/mod.rs,rs,249,8,b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29
lrb_core/src/phase_integrity.rs,rs,1695,38,1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e
lrb_core/src/quorum.rs,rs,2031,51,8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2
lrb_core/src/rcp_engine.rs,rs,1622,47,7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836
lrb_core/src/resonance.rs,rs,1146,38,3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9
lrb_core/src/sigpool.rs,rs,1072,33,9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175
lrb_core/src/spam_guard.rs,rs,839,33,592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e
lrb_core/src/types.rs,rs,1173,43,ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96
node/Cargo.toml,toml,2162,75,d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b
node/build.rs,rs,1722,43,65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf
node/src/admin.rs,rs,2800,45,8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4
node/src/api_extra.rs,rs,1886,37,a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c
node/src/api.rs,rs,8182,185,eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9
node/src/archive_ingest.rs,rs,1219,35,d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/auth.rs,rs,2349,63,cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
node/src/bridge.rs,rs,3551,89,0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186
node/src/fork.rs,rs,1328,40,d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b
node/src/gossip.rs,rs,1539,45,6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5
node/src/guard.rs,rs,3418,77,aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399
node/src/history_sled.rs,rs,1044,30,1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9
node/src/lib.rs,rs,831,24,7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb
node/src/main.rs,rs,3027,88,b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76
node/src/metrics.rs,rs,3597,103,54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846
node/src/openapi.rs,rs,441,14,184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b
node/src/peers.rs,rs,4932,158,8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63
node/src/producer.rs,rs,1704,44,fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e
node/src/stake_api.rs,rs,2668,52,53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536
node/src/stake.rs,rs,7692,162,8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8
node/src/staking.rs,rs,339,9,e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01
node/src/state.rs,rs,1182,35,621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5
node/src/storage.rs,rs,1031,31,12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7
node/src/types.rs,rs,430,17,33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0
node/src/version.rs,rs,495,21,2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e
node/src/wallet.rs,rs,913,26,c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48
node/src/archive/mod.rs,rs,4350,98,c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78
node/src/archive/pg.rs,rs,4790,126,062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10
node/src/archive/sqlite.rs,rs,3556,70,c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248
node/src/bin/bench_burst.rs,rs,1186,32,0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41
node/src/bin/make_tx.rs,rs,1149,30,6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650
node/src/bin/mint.rs,rs,756,20,91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8
node/src/openapi/openapi.json,json,3057,68,6a40c7f16988b7a8a01d94eb0ecbf2af55b1c7ff733239024687738fc166a159
modules/beacon_emitter.rs,rs,4455,139,34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd
modules/external_phase_broadcaster.rs,rs,1588,44,788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb
modules/external_phase_link.rs,rs,997,33,56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91
modules/genesis_fragment_seeds.rs,rs,1423,25,829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b
modules/heartbeat_monitor.rs,rs,1489,26,ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf
modules/legacy_migrator.rs,rs,1432,25,2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8
modules/ritual_engine.rs,rs,1460,25,b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef
modules/uplink_controller.rs,rs,1571,43,520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1
modules/uplink_router.rs,rs,1551,43,ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49
modules/go_to_market.yaml,yaml,3633,118,e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f
modules/maintenance_strategy.yaml,yaml,2361,85,a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9
modules/resonance_emergency_plan.yaml,yaml,3420,91,ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd
modules/resonance_meshmap.yaml,yaml,1877,89,8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6
modules/env_impact_tracker.py,py,5447,132,b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb
modules/resonance_tutor.py,py,6414,135,42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f
modules/symbolic_parser.py,py,4615,110,99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8
www/explorer/index.html,html,1880,36,1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a
www/index.html,html,4902,124,7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b
www/wallet3/index.html,html,3528,88,16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717
www/wallet/app.html,html,3367,74,634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2
www/wallet/index.html,html,4490,104,e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde
www/wallet/login.html,html,2647,56,3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76
www/explorer/explorer.js,js,3977,82,bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b
www/wallet3/app.v3.js,js,6763,107,2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349
www/wallet/app.js,js,7641,148,a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9
www/wallet/app.v2.js,js,7526,136,e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2
www/wallet/app.v3.js,js,6952,117,e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b
www/wallet/auth.js,js,6002,117,fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a
www/wallet.js,js,5287,137,8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc
www/wallet/staking.js,js,2843,42,ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80
www/wallet/wallet.js,js,9153,168,5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c
www/explorer/explorer.css,css,898,10,0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba
www/wallet/wallet.css,css,2693,73,1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad
configs/genesis.yaml,yaml,811,30,a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972
configs/logos_config.yaml,yaml,448,27,6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b
configs/env/node-a.env.example,example,254,8,cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f
configs/env/node-b.env.example,example,254,8,91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3
configs/env/node-c.env.example,example,254,8,448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290
scripts/bootstrap_node.sh,sh,1556,38,6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c
scripts/collect_and_push.sh,sh,3118,104,9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a
scripts/logos_healthcheck.sh,sh,1689,52,ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec
infra/systemd/logos-healthcheck.service,service,217,9,32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81
infra/systemd/logos-node.service,service,369,19,464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95
infra/systemd/logos-node@.service,service,412,23,9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb
infra/systemd/logos-snapshot.service,service,271,8,1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1
infra/systemd/lrb-proxy.service,service,395,16,008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed
infra/systemd/lrb-scanner.service,service,378,16,35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260
infra/systemd/exec.conf,conf,85,4,cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a
infra/systemd/keys.conf,conf,226,7,82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2
infra/systemd/override.conf,conf,575,16,0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6
infra/systemd/runas.conf,conf,143,5,8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c
infra/systemd/security.conf,conf,337,14,da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914
infra/systemd/tuning.conf,conf,156,5,d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8
infra/systemd/zz-consensus.conf,conf,137,4,b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171
infra/systemd/zz-keys.conf,conf,417,9,4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87
infra/systemd/zz-logging.conf,conf,36,2,d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a
infra/nginx/lrb_wallet.conf,conf,3062,88,c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-26-33Z.json  (size=16848b)
```json
{"generated":"2025-09-18T08-26-33Z","files":[
{"path":"lrb_core/Cargo.toml","ext":"toml","size":864,"lines":32,"sha256":"8d8d444d0960f25fd84527b75a4ef54c1f061f16fe69702e0052e51e099cf012"},
{"path":"lrb_core/src/anti_replay.rs","ext":"rs","size":980,"lines":35,"sha256":"b7d311bbe5d88feb3da028a2c136623732a3b176e66b7dfdc62e2ade36751ae5"},
{"path":"lrb_core/src/beacon.rs","ext":"rs","size":1821,"lines":61,"sha256":"3813280a6e1d160fa634be2db9d1ef1999206dfccf4117bdd6ac29208423bda6"},
{"path":"lrb_core/src/crypto.rs","ext":"rs","size":1929,"lines":48,"sha256":"4e688346943bd3be5b083d9f1410b3caa8f228456468b5988600411dff6e9fd2"},
{"path":"lrb_core/src/dynamic_balance.rs","ext":"rs","size":609,"lines":18,"sha256":"f8bca3f6cb35ba98df19818b6dcec81b8b2148625fd408c497db6feeab39adc4"},
{"path":"lrb_core/src/engine.rs","ext":"rs","size":6769,"lines":153,"sha256":"094a276864b7454adb158ea6087acc185ec3a85b23882ac4ae6b25ff64ed1c64"},
{"path":"lrb_core/src/heartbeat.rs","ext":"rs","size":2166,"lines":78,"sha256":"03b9cfce2b9c2a66c1c87ef9ea1af7c35e06013b02d4947e68b9ce93519cdea9"},
{"path":"lrb_core/src/ledger.rs","ext":"rs","size":10076,"lines":227,"sha256":"9aef9ea93e21d221f7e363aaf3f12d66019230f1a31128c7103e91b6b148dc05"},
{"path":"lrb_core/src/lib.rs","ext":"rs","size":499,"lines":12,"sha256":"01da15d8cfa16f22e7eb2ddbdfe475014c497ed51bd51adac196709abeffd41b"},
{"path":"lrb_core/src/phase_consensus.rs","ext":"rs","size":1806,"lines":52,"sha256":"804a40259086b632308a21ac02688cadf787007e176a6f9a916e324d28caed43"},
{"path":"lrb_core/src/phase_filters/mod.rs","ext":"rs","size":249,"lines":8,"sha256":"b6568f459346f022ccd795681c81cbb3188a16176978aa033bdd84ab67480e29"},
{"path":"lrb_core/src/phase_integrity.rs","ext":"rs","size":1695,"lines":38,"sha256":"1c3f64105bb73cf42ea1f9f52f492432006b60d98d0416ea13d2d5de9d7b521e"},
{"path":"lrb_core/src/quorum.rs","ext":"rs","size":2031,"lines":51,"sha256":"8c06ce2da8a488445a2ec1018b1efd610312d5d8d2db561f640019785128eda2"},
{"path":"lrb_core/src/rcp_engine.rs","ext":"rs","size":1622,"lines":47,"sha256":"7d75a5b8e5838d8f8adeb780feec32cf31b2e75fbb5f095078e604744a91d836"},
{"path":"lrb_core/src/resonance.rs","ext":"rs","size":1146,"lines":38,"sha256":"3c93138def86bd1aaed64659d18940a10f1900a4953f5a801dd4c14106eee6d9"},
{"path":"lrb_core/src/sigpool.rs","ext":"rs","size":1072,"lines":33,"sha256":"9bcf2a1e516273d2f2db8f25a15c43a2d8749de48bf0020f8797706fd5cd1175"},
{"path":"lrb_core/src/spam_guard.rs","ext":"rs","size":839,"lines":33,"sha256":"592c4ca322a2123dab83b7cfce8951787329efe8a049ee4cfb324137ed27797e"},
{"path":"lrb_core/src/types.rs","ext":"rs","size":1173,"lines":43,"sha256":"ebafbb2df419dd019a25c68fc2f9f08b439e3acca429e5d2521f557bf3f91d96"},
{"path":"node/Cargo.toml","ext":"toml","size":2162,"lines":75,"sha256":"d7dc43dca977f5d6aeb50e9cc631bef90998ca9a5e03942bde0c156284db6e0b"},
{"path":"node/build.rs","ext":"rs","size":1722,"lines":43,"sha256":"65eed239d7dcf1b8845647c5f90733530fee162b0b4a9fd963d859d7840c7cbf"},
{"path":"node/src/admin.rs","ext":"rs","size":2800,"lines":45,"sha256":"8af924670730778ca64c304a8abf781ec07426850801b1b88840af7fd15c9fd4"},
{"path":"node/src/api_extra.rs","ext":"rs","size":1886,"lines":37,"sha256":"a70bb133d40f9533b859a8d3af626de17ec851a64f7bab0bed85a75026ec3a2c"},
{"path":"node/src/api.rs","ext":"rs","size":8182,"lines":185,"sha256":"eb62fc5bdffda0a604b4b388c333ab527519da68c93fc6255815abfcabe398a9"},
{"path":"node/src/archive_ingest.rs","ext":"rs","size":1219,"lines":35,"sha256":"d15cfbdea8f97a3a7d122fce511076478cdd1cc1d610912a889df2ae603dda33"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/auth.rs","ext":"rs","size":2349,"lines":63,"sha256":"cffeb320432f9074e14887aa47afb13c77efd48151fd5dbdb9fe941b85d06842"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"node/src/bridge.rs","ext":"rs","size":3551,"lines":89,"sha256":"0a3c61d3cbed3b78928fa6c253e0dc47197dc0606ea09a683823b91226262186"},
{"path":"node/src/fork.rs","ext":"rs","size":1328,"lines":40,"sha256":"d053e80c063b2b543cfd4587e18ead7b183d04e92cb70e368e2802b3ef02bf7b"},
{"path":"node/src/gossip.rs","ext":"rs","size":1539,"lines":45,"sha256":"6b05c312189015932893d92d9b6d5ee26f02fbc00831084e95a895b3a9f04bd5"},
{"path":"node/src/guard.rs","ext":"rs","size":3418,"lines":77,"sha256":"aa6b3bdec5ba1adcc629443ee35faa27c28e01747593396bbbdc91ee7c770399"},
{"path":"node/src/history_sled.rs","ext":"rs","size":1044,"lines":30,"sha256":"1428f8ac8b036fc8b65b3f98a226d0fcbb9fb52a3ad3f92d145d8c74098570b9"},
{"path":"node/src/lib.rs","ext":"rs","size":831,"lines":24,"sha256":"7172bc202f529c5f56655bea73251288cbdee4e55ef93128bd054734cb5d1fcb"},
{"path":"node/src/main.rs","ext":"rs","size":3027,"lines":88,"sha256":"b8576da34b52397da9801d820615420b412b23e61b6b98cd21ab9cf86467df76"},
{"path":"node/src/metrics.rs","ext":"rs","size":3597,"lines":103,"sha256":"54b658270372c91acbf3a5f1a50eadf18b260c3f16991ab26a469ed0a8357846"},
{"path":"node/src/openapi.rs","ext":"rs","size":441,"lines":14,"sha256":"184a8c540dfe113ce3ef2fec78413379c73d03bf14cdc8805fd6fbd39d17728b"},
{"path":"node/src/peers.rs","ext":"rs","size":4932,"lines":158,"sha256":"8b9ca55a6d6ddab34546fc7b43174fcf8cd24ab67fdc25c70ac3d287be7b1c63"},
{"path":"node/src/producer.rs","ext":"rs","size":1704,"lines":44,"sha256":"fac0c1e2cc2ede5fbcfde96f90c41e8fb501a45b166b08e9a0d8d08f4c787a1e"},
{"path":"node/src/stake_api.rs","ext":"rs","size":2668,"lines":52,"sha256":"53206ba4dde73430a42996a07de4730856a5e317b9f7ed0105c1790916115536"},
{"path":"node/src/stake.rs","ext":"rs","size":7692,"lines":162,"sha256":"8de7243c5faa10a6ecfd7fd25e62146e5ae5280b5ca95aa296627c9f4ed2cbe8"},
{"path":"node/src/staking.rs","ext":"rs","size":339,"lines":9,"sha256":"e9bd3c2adc7c1b3af55dfd8af70a94748d53f10b6c77b84ec295a0a0e7463f01"},
{"path":"node/src/state.rs","ext":"rs","size":1182,"lines":35,"sha256":"621c2b6a36386a54941806c380c2db0e6efa078d9bd6bda461b119e8af20b1a5"},
{"path":"node/src/storage.rs","ext":"rs","size":1031,"lines":31,"sha256":"12e29b796828ff626f2d2db1cbe0298a7efb458d1d0fa55507f55ee5b02034c7"},
{"path":"node/src/types.rs","ext":"rs","size":430,"lines":17,"sha256":"33a0ef4e2958882ebd98c9516825005d9b400a3b15c3e6486457ac93a77a38a0"},
{"path":"node/src/version.rs","ext":"rs","size":495,"lines":21,"sha256":"2a453f1ee5a9581676990dc06d32bfbaed0852961607dac9e0b60f955338740e"},
{"path":"node/src/wallet.rs","ext":"rs","size":913,"lines":26,"sha256":"c78465df8ec4d42a92c6a9725940e99e425706315e8c8451c5e1eb7ffe552f48"},
{"path":"node/src/archive/mod.rs","ext":"rs","size":4350,"lines":98,"sha256":"c53da54c0c32a24d900a45de4258f3fbdb71763984ce69f3c915f0f748e67d78"},
{"path":"node/src/archive/pg.rs","ext":"rs","size":4790,"lines":126,"sha256":"062671ccb441afda3f1d6bb163d46ad51db42bd3f1bf771a685fd3baa83f2e10"},
{"path":"node/src/archive/sqlite.rs","ext":"rs","size":3556,"lines":70,"sha256":"c36ba9c1e065f67393e159c6fc14aa5284afe4ecff607b97c4d6b8d3763ad248"},
{"path":"node/src/bin/bench_burst.rs","ext":"rs","size":1186,"lines":32,"sha256":"0fa294e2becfed929619fe39a03ec6618140e661b937250b72ecd7d8872eff41"},
{"path":"node/src/bin/make_tx.rs","ext":"rs","size":1149,"lines":30,"sha256":"6a1b61de1c9682e58d5b25ce44ab8e6b786a760cc42dcef0655fa3fc7c920650"},
{"path":"node/src/bin/mint.rs","ext":"rs","size":756,"lines":20,"sha256":"91c25e9b0dcdc1b99ded222c59ff712e8be80fc8000a0fe1dbdb2c765a1080a8"},
{"path":"node/src/openapi/openapi.json","ext":"json","size":3057,"lines":68,"sha256":"6a40c7f16988b7a8a01d94eb0ecbf2af55b1c7ff733239024687738fc166a159"},
{"path":"modules/beacon_emitter.rs","ext":"rs","size":4455,"lines":139,"sha256":"34170e03fac8b43574d442bf568552de96ef47b6e85232e53db83430963b88cd"},
{"path":"modules/external_phase_broadcaster.rs","ext":"rs","size":1588,"lines":44,"sha256":"788401613ebf0fc005475edceb86960fca39e801de521c65bc2ecde20a1135eb"},
{"path":"modules/external_phase_link.rs","ext":"rs","size":997,"lines":33,"sha256":"56c1e9a0ee099647ec36a51d910d2fb709caeaa0b6cda3fe732008c2fdf42f91"},
{"path":"modules/genesis_fragment_seeds.rs","ext":"rs","size":1423,"lines":25,"sha256":"829f6fe801f2cc32b9b0878c0b37e4c0650a1b10c5e71d3d976b6984a7ffc53b"},
{"path":"modules/heartbeat_monitor.rs","ext":"rs","size":1489,"lines":26,"sha256":"ad9d27971651638d85666fd3ec138b017eedaa58261ed2a2e910c1791ef904bf"},
{"path":"modules/legacy_migrator.rs","ext":"rs","size":1432,"lines":25,"sha256":"2a4c2faf1612c9c1bde357e7b7f18da2643a04e4ac05381ab19e5a8aa3194fd8"},
{"path":"modules/ritual_engine.rs","ext":"rs","size":1460,"lines":25,"sha256":"b5cf9fa8c6da04c11644314d04853bb7304964db620523b43ad96b32685369ef"},
{"path":"modules/uplink_controller.rs","ext":"rs","size":1571,"lines":43,"sha256":"520ac6a3d22e634417bd962846c3339125096095d1039848d5c1c2482c5be9f1"},
{"path":"modules/uplink_router.rs","ext":"rs","size":1551,"lines":43,"sha256":"ee765812ca7bcefcf543016c82f07681d1fbd21cdd0261ebecd0600fb674fe49"},
{"path":"modules/go_to_market.yaml","ext":"yaml","size":3633,"lines":118,"sha256":"e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f"},
{"path":"modules/maintenance_strategy.yaml","ext":"yaml","size":2361,"lines":85,"sha256":"a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9"},
{"path":"modules/resonance_emergency_plan.yaml","ext":"yaml","size":3420,"lines":91,"sha256":"ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd"},
{"path":"modules/resonance_meshmap.yaml","ext":"yaml","size":1877,"lines":89,"sha256":"8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6"},
{"path":"modules/env_impact_tracker.py","ext":"py","size":5447,"lines":132,"sha256":"b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb"},
{"path":"modules/resonance_tutor.py","ext":"py","size":6414,"lines":135,"sha256":"42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f"},
{"path":"modules/symbolic_parser.py","ext":"py","size":4615,"lines":110,"sha256":"99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8"},
{"path":"www/explorer/index.html","ext":"html","size":1880,"lines":36,"sha256":"1e9562ffa3c56927884004223020f4043f7948b058d85ecbc37336dccd02031a"},
{"path":"www/index.html","ext":"html","size":4902,"lines":124,"sha256":"7b221738e7141fef03f789011836fe01f6eb51d9b305f0a525dbffd7b57d7c8b"},
{"path":"www/wallet3/index.html","ext":"html","size":3528,"lines":88,"sha256":"16003569d375db6705f3ef3ef95cc6bada61364a55382823e7f25af1a7dd8717"},
{"path":"www/wallet/app.html","ext":"html","size":3367,"lines":74,"sha256":"634d3867f77eaeb5b11e7c03a6f23a7891bd1ec3cadede0b0ed29aec5eb8d0d2"},
{"path":"www/wallet/index.html","ext":"html","size":4490,"lines":104,"sha256":"e3229b0baa5c875c0c0340c3ef6ae83124f5cf99a843af9195773011aef58cde"},
{"path":"www/wallet/login.html","ext":"html","size":2647,"lines":56,"sha256":"3ca5265f2e0466f2eff556f4dba96f74b7eb273d46c7e80f40a4ed2c5cf89f76"},
{"path":"www/explorer/explorer.js","ext":"js","size":3977,"lines":82,"sha256":"bfc2b03314887fd05ebaacab69042e7e97a9c48c1ea194fc5c7d90d090b1712b"},
{"path":"www/wallet3/app.v3.js","ext":"js","size":6763,"lines":107,"sha256":"2c33a6e556cae1e08ac3a6e41d53f83b0a4b8c0d046e06ae942715202d4cb349"},
{"path":"www/wallet/app.js","ext":"js","size":7641,"lines":148,"sha256":"a301fedea06feff7c9c43f1fd80e19f66355711e7a300310854392fdb5a50ea9"},
{"path":"www/wallet/app.v2.js","ext":"js","size":7526,"lines":136,"sha256":"e9acf520c904ab392b74518030f6f81c0da9b43d938f7d408f374468f168d7c2"},
{"path":"www/wallet/app.v3.js","ext":"js","size":6952,"lines":117,"sha256":"e9f7272b2a65262b3713102884f515e82b1b3b52f9fb10de54a46f778ebe409b"},
{"path":"www/wallet/auth.js","ext":"js","size":6002,"lines":117,"sha256":"fefed14c6d58709cc481ccb34378dc5240a2f76c0b5d315328b0706527c7cc3a"},
{"path":"www/wallet.js","ext":"js","size":5287,"lines":137,"sha256":"8e79f33a2ed1b3822055ee06fc13e6e02a74e76132f1ea500728cc605e162cdc"},
{"path":"www/wallet/staking.js","ext":"js","size":2843,"lines":42,"sha256":"ca94693b752e5a374ec8cba2b8021aac7980bfca2fa709085e42cd7a883eab80"},
{"path":"www/wallet/wallet.js","ext":"js","size":9153,"lines":168,"sha256":"5249fd53f7d4a5ad1031f904ae24a52041c26cc90599a9d42e2ae6ff1c0bb80c"},
{"path":"www/explorer/explorer.css","ext":"css","size":898,"lines":10,"sha256":"0952db5465ce69b04c3559e658e4c6d575e01c8a26d28e022f1987a6d4f8ddba"},
{"path":"www/wallet/wallet.css","ext":"css","size":2693,"lines":73,"sha256":"1413b79b9823910371cf973a3a7cb70c20d73be37196ca319d58a36298be85ad"},
{"path":"configs/genesis.yaml","ext":"yaml","size":811,"lines":30,"sha256":"a705b8e49e2fe626d32e0f3138989883fa9b771583a20ead6b51d5c7e8d5d972"},
{"path":"configs/logos_config.yaml","ext":"yaml","size":448,"lines":27,"sha256":"6d07e2a513c4b06a560cd9140f7d02fb9fc2e2665142c41e6ec1ca3f88aa893b"},
{"path":"configs/env/node-a.env.example","ext":"example","size":254,"lines":8,"sha256":"cb83475584a000e853819ba7891b71256dcf884edaa4f085e203a8cac2fd248f"},
{"path":"configs/env/node-b.env.example","ext":"example","size":254,"lines":8,"sha256":"91543071ff9a5d27fa7a5ba5dce34fd44ec39e348181960785a4b431ee3738f3"},
{"path":"configs/env/node-c.env.example","ext":"example","size":254,"lines":8,"sha256":"448bad3fd806cc7eeb31a0c1f3c57165d4130108ab8b6b9cb0d0db3a7ffd5290"},
{"path":"scripts/bootstrap_node.sh","ext":"sh","size":1556,"lines":38,"sha256":"6431ede28fd4eb1d13b09480ff5bb266edea2360250c39f05ca2ac3f2d6ad08c"},
{"path":"scripts/collect_and_push.sh","ext":"sh","size":3118,"lines":104,"sha256":"9e9fe8edb228417a48bf279b09b23f8e38823f1eb67315d6d0fed84c13d8db4a"},
{"path":"scripts/logos_healthcheck.sh","ext":"sh","size":1689,"lines":52,"sha256":"ecaab512c7312474d799bf55cb3b7e14287b51eb6f050c04065035e94519c6ec"},
{"path":"infra/systemd/logos-healthcheck.service","ext":"service","size":217,"lines":9,"sha256":"32eafbea10ab428d54c3afd418f00e9ce2f047bffaa529e8fe585efca58afd81"},
{"path":"infra/systemd/logos-node.service","ext":"service","size":369,"lines":19,"sha256":"464c28fba29b923ab523aa8799d91519056211ff842396f76066d8ef4f144d95"},
{"path":"infra/systemd/logos-node@.service","ext":"service","size":412,"lines":23,"sha256":"9d4bdac8bb272f81e970eb5470d46113efa2b6b0e097ffd0543fd9cfeb0934eb"},
{"path":"infra/systemd/logos-snapshot.service","ext":"service","size":271,"lines":8,"sha256":"1e1999a9184073503629bd566ab8a66e9a1f55a97c76c500edbdba4ed12429b1"},
{"path":"infra/systemd/lrb-proxy.service","ext":"service","size":395,"lines":16,"sha256":"008a54ec09d2166ef931ca63217e135d2607554612bf3728349e5ed51acdd2ed"},
{"path":"infra/systemd/lrb-scanner.service","ext":"service","size":378,"lines":16,"sha256":"35cc469a929a0f5f0f25595eb54597cce9af8ac33fc8dc7b6da82dc62cf8c260"},
{"path":"infra/systemd/exec.conf","ext":"conf","size":85,"lines":4,"sha256":"cc92438891b488f37b6f05578dae88b2c69b73f4450ae163de87688fc9061d9a"},
{"path":"infra/systemd/keys.conf","ext":"conf","size":226,"lines":7,"sha256":"82f1958078e22711f6abf3ee5add0caa747de2d2690ed6c1af486debc0b68dc2"},
{"path":"infra/systemd/override.conf","ext":"conf","size":575,"lines":16,"sha256":"0d036f73e5e65b5723140e526b5918a9472f94c189e5b035d43e792199d575b6"},
{"path":"infra/systemd/runas.conf","ext":"conf","size":143,"lines":5,"sha256":"8dc99211f18ceb1045e0db9971faeff365c272e77667993c5cfa9432effe865c"},
{"path":"infra/systemd/security.conf","ext":"conf","size":337,"lines":14,"sha256":"da30d79d4b724ece37f539917bd3dc57ff1d190930bf0bba2fd1d7094bfeb914"},
{"path":"infra/systemd/tuning.conf","ext":"conf","size":156,"lines":5,"sha256":"d03eb3adbde72a82bbef22d1c4ad513448ce9422cf5ca3499e6d832b9ab7dfb8"},
{"path":"infra/systemd/zz-consensus.conf","ext":"conf","size":137,"lines":4,"sha256":"b5bb0d5d3fcee9162090d395888b3a58ba4a23cbc9df33fe6b2e8f66249a0171"},
{"path":"infra/systemd/zz-keys.conf","ext":"conf","size":417,"lines":9,"sha256":"4f009e6905ffb373e07e503878ba0f96e888b51fa4647b60f897983852fa2f87"},
{"path":"infra/systemd/zz-logging.conf","ext":"conf","size":36,"lines":2,"sha256":"d1d5df1f9060b3a5ee6ac0fa40f8532cdc3aa3a6cc7c5424a7567db4d751bf7a"},
{"path":"infra/nginx/lrb_wallet.conf","ext":"conf","size":3062,"lines":88,"sha256":"c4e899700462a9383193c75c0525fd50b02a5dc3202b13e390fb9ebead2dc126"}
]}

```

## FILE: /root/logos_lrb/docs/MODULES_INVENTORY_2025-09-18T08-26-33Z.txt  (size=1097b)
```text
# LOGOS LRB — modules inventory (UTC 2025-09-18T08-26-33Z)
ROOT: /root/logos_lrb

## CORE (lrb_core)

## NODE (node)

## MODULES (service modules)

## WWW (wallet/explorer static)

## CONFIGS

## SCRIPTS

## INFRA (systemd/nginx templates)


## SUMMARY
files_total: 114
lines_total: 6677
size_total_bytes: 272341
## CONSISTENCY CHECKS

main.rs -> module presence:
  OK: admin => node/src/admin.rs
  OK: api => node/src/api.rs
  OK: archive => node/src/archive/mod.rs
  OK: auth => node/src/auth.rs
  OK: bridge => node/src/bridge.rs
  OK: gossip => node/src/gossip.rs
  OK: guard => node/src/guard.rs
  OK: metrics => node/src/metrics.rs
  OK: openapi => node/src/openapi.rs
  OK: peers => node/src/peers.rs
  OK: producer => node/src/producer.rs
  OK: stake => node/src/stake.rs
  OK: state => node/src/state.rs
  OK: storage => node/src/storage.rs
  OK: version => node/src/version.rs
  OK: wallet => node/src/wallet.rs

openapi.rs -> include_str! payloads:
  OK: node/src/openapi/openapi.json

DIR OK: lrb_core/src
DIR OK: node/src
DIR OK: modules
DIR OK: www
DIR OK: configs
DIR OK: scripts

```

## FILE: /root/logos_lrb/docs/snapshots/LRB_FULL_LIVE_20250905_1218.txt  (size=496424b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/docs/WORKFLOW.md  (size=5440b)
```markdown
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```

## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```text
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=3062b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки ---
    add_header X-Frame-Options        SAMEORIGIN       always;
    add_header X-Content-Type-Options nosniff          always;
    add_header Referrer-Policy        strict-origin-when-cross-origin always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # CSP: только self, без inline/CDN. Разрешаем data: для иконок/картинок в UI.
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```text
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```text
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```text
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```text
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=837b)
```text
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
EnvironmentFile=/etc/logos/node-%i.env
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/bin/logos_node
Restart=always
RestartSec=1s
StartLimitIntervalSec=0
LimitNOFILE=1048576

# sandbox
AmbientCapabilities=
CapabilityBoundingSet=
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectKernelLogs=true
ProtectKernelModules=true
ProtectKernelTunables=true
ProtectControlGroups=true
ProtectClock=true
ProtectHostname=true
RestrictSUIDSGID=true
RestrictRealtime=true
LockPersonality=true
MemoryDenyWriteExecute=true
ReadWritePaths=/var/lib/logos /etc/logos
ProtectSystem=strict

# лог (journalctl -u logos-node@<inst>)
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```text
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```text
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```text
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```text
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```text
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```text
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```text
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```text
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```text
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```

## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```text
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```text
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```

## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```text
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```text
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```text
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/lrb_core/Cargo.toml  (size=945b)
```toml
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"
description = "LOGOS LRB core: ledger + engine + types"
license = "Apache-2.0"

[dependencies]
anyhow = "1"
thiserror = "1"

# крипта/хэш
ed25519-dalek = { version = "2.1.1", default-features = false, features = ["alloc", "std"] }
blake3 = "1.5"
sha2 = "0.10"          # ← НУЖЕН ДЛЯ ledger.rs (txid = sha256)

# кодеки/утилиты
base64 = "0.22"
hex = "0.4"            # ← НУЖЕН ДЛЯ ledger.rs
bs58 = "0.4"
uuid  = { version = "1", features = ["v4"] }

# хранилище/сериализация
sled = "0.34"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
once_cell = "1"

# движок/асинхронщина/логгинг
tokio = { version = "1", features = ["rt-multi-thread", "macros", "sync", "time"] }
tracing = "0.1"
parking_lot = "0.12"
lazy_static = "1.5.0"
prometheus.workspace = true
rand.workspace = true

```

## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```rust
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```rust
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```

## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1929b)
```rust
//! Безопасные AEAD-примитивы с уникальным nonce per message.
//! Использование:
//!   let (ct, nonce) = seal_aes_gcm(&key32, aad, &plain)?;
//!   let pt = open_aes_gcm(&key32, aad, nonce, &ct)?;

use anyhow::{anyhow, Result};
use rand::rngs::OsRng;
use rand::RngCore;
use ring::aead::{self, Aad, LessSafeKey, Nonce, UnboundKey};

/// 96-битный nonce для AES-GCM (RFC 5116). Генерируется на каждое сообщение.
#[derive(Clone, Copy, Debug)]
pub struct Nonce96(pub [u8; 12]);

impl Nonce96 {
    #[inline]
    pub fn random() -> Self {
        let mut n = [0u8; 12];
        OsRng.fill_bytes(&mut n);
        Self(n)
    }
}

/// Шифрование AES-256-GCM: возвращает (ciphertext||tag, nonce)
pub fn seal_aes_gcm(key32: &[u8; 32], aad: &[u8], plaintext: &[u8]) -> Result<(Vec<u8>, [u8; 12])> {
    let unbound = UnboundKey::new(&aead::AES_256_GCM, key32)
        .map_err(|e| anyhow!("ring UnboundKey::new failed: {:?}", e))?;
    let key = LessSafeKey::new(unbound);
    let nonce = Nonce96::random();

    let mut inout = plaintext.to_vec();
    key.seal_in_place_append_tag(Nonce::assume_unique_for_key(nonce.0), Aad::from(aad), &mut inout)
        .map_err(|_| anyhow!("AEAD seal failed"))?;
    Ok((inout, nonce.0))
}

/// Расшифрование AES-256-GCM: принимает nonce и (ciphertext||tag)
pub fn open_aes_gcm(key32: &[u8; 32], aad: &[u8], nonce: [u8; 12], ciphertext_and_tag: &[u8]) -> Result<Vec<u8>> {
    let unbound = UnboundKey::new(&aead::AES_256_GCM, key32)
        .map_err(|e| anyhow!("ring UnboundKey::new failed: {:?}", e))?;
    let key = LessSafeKey::new(unbound);

    let mut buf = ciphertext_and_tag.to_vec();
    let plain = key
        .open_in_place(Nonce::assume_unique_for_key(nonce), Aad::from(aad), &mut buf)
        .map_err(|_| anyhow!("AEAD open failed"))?;
    Ok(plain.to_vec())
}

```

## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```rust
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/engine.rs  (size=2235b)
```rust
use crate::ledger::Ledger;
use crate::types::{Block, BlockHash, ValidatorSet, Vote};
use anyhow::Result;
use ed25519_dalek::{VerifyingKey, Signature};
use lazy_static::lazy_static;
use prometheus::{register_gauge_vec, GaugeVec};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::info;

lazy_static! {
    static ref BLOCK_HEIGHT: GaugeVec = register_gauge_vec!("logos_block_height", "Block height by type", &["type"]).unwrap();
}

pub struct Engine {
    ledger: Arc<RwLock<Ledger>>,
    validators: ValidatorSet,
    latest_votes: HashMap<BlockHash, HashMap<VerifyingKey, Signature>>,
    head: BlockHash,
}

impl Engine {
    pub async fn new(ledger: Arc<RwLock<Ledger>>, validators: ValidatorSet) -> Result<Self> {
        let head = ledger.read().await.load_head();
        Ok(Self {
            ledger,
            validators,
            latest_votes: HashMap::new(),
            head,
        })
    }

    pub async fn ingest_block(&mut self, block: Block) -> Result<()> {
        let ledger = self.ledger.write().await;
        ledger.commit_block(&block.hash, block.height);
        Ok(())
    }

    pub async fn on_vote(&mut self, vote: Vote) -> Result<()> {
        let block_hash = vote.block.clone();
        let dummy_pk = VerifyingKey::from_bytes(&[0u8; 32])?;
        let dummy_sig = Signature::try_from([0u8; 64])?;
        self.latest_votes.entry(block_hash.clone()).or_insert_with(HashMap::new).insert(dummy_pk, dummy_sig);
        if self.latest_votes.get(&block_hash).unwrap().len() >= self.validators.two_thirds() {
            let ledger = self.ledger.write().await;
            ledger.commit_block(&block_hash, vote.height);
            BLOCK_HEIGHT.with_label_values(&["finalized"]).set(ledger.load_head_height() as f64);
            info!("Finalized block with quorum");
        }
        Ok(())
    }

    pub async fn produce_and_ingest(&mut self) -> Result<()> {
        let height = self.ledger.read().await.load_head_height() + 1;
        let block = Block { height, hash: BlockHash([0u8; 32]), txs: vec![], ts_ms: 0 };
        self.ingest_block(block).await
    }

    pub async fn head(&self) -> BlockHash {
        self.ledger.read().await.load_head()
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```rust
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=9126b)
```rust
use sled::{Db, Tree};
use anyhow::Result;
use serde::{Serialize, Deserialize};
use hex::{FromHex, ToHex};
use blake3::Hasher;
use std::time::{SystemTime, UNIX_EPOCH};
use std::convert::TryInto;

use crate::types::BlockHash;

// ===== helpers / keys =====
pub fn now_ms() -> u64 {
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis() as u64
}
fn be64(v: u64) -> [u8;8] { v.to_be_bytes() }
fn from_be64(v: &[u8]) -> u64 { u64::from_be_bytes(v.try_into().unwrap()) }

const H_H:  &str = "h";   // head height (u64 be)
const H_HH: &str = "hh";  // head hash (hex)
const H_FIN:&str = "fin"; // finalized height (u64 be)
const H_M:  &str = "mint";
const H_B:  &str = "burn";

fn k_block_by_height(h: u64) -> String { format!("b|{}", h) } // -> StoredBlock(JSON)
fn k_bh(hex: &str) -> String          { format!("bh|{}", hex) } // -> be64(height)
fn k_tx(txid: &str) -> String         { format!("t|{}", txid) } // -> StoredTx(JSON)

fn k_bal(rid: &str)   -> String { format!("bal|{}", rid) }    // u64
fn k_nonce(rid: &str) -> String { format!("nonce|{}", rid) }  // u64

fn k_acct(rid: &str, h: u64, idx: u32) -> String { format!("a|{}|{}|{}", rid, h, idx) }
fn acct_prefix(rid: &str) -> String { format!("a|{}|", rid) }

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash:   String,   // hex
    pub ts_ms:  u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub txid:   String,
    pub from:   String,
    pub to:     String,
    pub amount: u64,
    pub nonce:  u64,
    pub height: u64,
    pub index:  u32,
    /// время в мс — именно `ts`, как ждёт node (он делает stx.ts/1000)
    pub ts:     u64,
    /// мемо опционально; node может передать
    pub memo:   Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct BlockHeaderView { pub block_hash: String }

// ===== Ledger =====
#[derive(Clone)]
pub struct Ledger {
    db: Db,
    head:   Tree,   // meta
    blocks: Tree,   // b|<h>     -> StoredBlock(JSON)
    bh:     Tree,   // bh|<hex>  -> be64(height)
    txs:    Tree,   // t|<txid>  -> StoredTx(JSON)
    acct:   Tree,   // a|rid|h|idx -> txid
    bal:    Tree,   // bal|rid   -> be64(balance)
    nonces: Tree,   // nonce|rid -> be64(nonce)
}

impl Ledger {
    pub fn open(path: &str) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self {
            head:   db.open_tree("head")?,
            blocks: db.open_tree("blocks")?,
            bh:     db.open_tree("bh_index")?,
            txs:    db.open_tree("txs")?,
            acct:   db.open_tree("acct_txs")?,
            bal:    db.open_tree("balances")?,
            nonces: db.open_tree("nonces")?,
            db,
        })
    }

    // ===== Совместимость с node: head/height API =====
    pub fn load_head(&self) -> BlockHash {
        let hh_hex = self.head.get(H_HH).ok().flatten()
            .and_then(|v| String::from_utf8(v.to_vec()).ok()).unwrap_or_default();
        <[u8;32]>::from_hex(hh_hex).map(BlockHash).unwrap_or(BlockHash([0u8;32]))
    }
    pub fn load_head_height(&self) -> u64 {
        self.head.get(H_H).ok().flatten().map(|v| from_be64(&v)).unwrap_or(0)
    }
    pub fn height(&self) -> Result<u64> { Ok(self.load_head_height()) }
    pub fn head_height(&self) -> Result<u64> { self.height() }
    pub fn height_u64(&self) -> u64 { self.load_head_height() }

    pub fn set_head(&self, h: u64, hash_hex: &str) -> Result<()> {
        self.head.insert(H_H,  &be64(h))?;
        self.head.insert(H_HH, hash_hex.as_bytes())?;
        Ok(())
    }
    pub fn set_finalized(&self, h: u64) -> Result<()> {
        self.head.insert(H_FIN, &be64(h))?;
        Ok(())
    }

    pub fn get_block_by_height(&self, h: u64) -> Result<BlockHeaderView> {
        let key = k_block_by_height(h);
        if let Some(v) = self.blocks.get(key)? {
            let sb: StoredBlock = serde_json::from_slice(&v)?;
            Ok(BlockHeaderView { block_hash: sb.hash })
        } else {
            let hh = self.head.get(H_HH)?
                .map(|v| String::from_utf8(v.to_vec()).unwrap())
                .unwrap_or_default();
            Ok(BlockHeaderView { block_hash: hh })
        }
    }

    /// Быстрый поиск высоты по hash (для Engine/BFT)
    pub fn lookup_height(&self, b: &BlockHash) -> Option<u64> {
        let hex = b.0.encode_hex::<String>();
        self.bh.get(k_bh(&hex)).ok().flatten().map(|iv| from_be64(&iv))
    }

    /// Коммит блока (без применения tx)
    pub fn commit_block(&self, b: &BlockHash, h: u64) {
        let hex = b.0.encode_hex::<String>();
        let sb = StoredBlock { height: h, hash: hex.clone(), ts_ms: now_ms() as u128, tx_ids: vec![] };
        self.blocks.insert(k_block_by_height(h), serde_json::to_vec(&sb).unwrap()).unwrap();
        self.bh.insert(k_bh(&hex), &be64(h)).unwrap();
        self.head.insert(H_H, &be64(h)).unwrap();
        self.head.insert(H_HH, hex.as_bytes()).unwrap();
    }

    pub fn db(&self) -> &Db { &self.db }

    // ===== Балансы / нонсы / supply =====
    pub fn get_balance(&self, rid: &str) -> Result<u64> {
        Ok(self.bal.get(k_bal(rid))?.map(|v| from_be64(&v)).unwrap_or(0))
    }
    pub fn set_balance(&self, rid: &str, v: u128) -> Result<()> {
        let clipped = if v > u128::from(u64::MAX) { u64::MAX } else { v as u64 };
        self.bal.insert(k_bal(rid), &be64(clipped))?;
        Ok(())
    }
    pub fn get_nonce(&self, rid: &str) -> Result<u64> {
        Ok(self.nonces.get(k_nonce(rid))?.map(|v| from_be64(&v)).unwrap_or(0))
    }
    pub fn set_nonce(&self, rid: &str, value: u64) -> Result<()> {
        self.nonces.insert(k_nonce(rid), &be64(value))?;
        Ok(())
    }
    pub fn bump_nonce(&self, rid: &str) -> Result<u64> {
        let n = self.get_nonce(rid)? + 1;
        self.set_nonce(rid, n)?;
        Ok(n)
    }

    pub fn add_minted(&self, amount: u64) -> Result<u64> {
        let cur = self.head.get(H_M)?.map(|v| from_be64(&v)).unwrap_or(0);
        let new = cur.saturating_add(amount);
        self.head.insert(H_M, &be64(new))?;
        Ok(new.saturating_sub(self.head.get(H_B)?.map(|v| from_be64(&v)).unwrap_or(0)))
    }
    pub fn add_burned(&self, amount: u64) -> Result<u64> {
        let cur = self.head.get(H_B)?.map(|v| from_be64(&v)).unwrap_or(0);
        let new = cur.saturating_add(amount);
        self.head.insert(H_B, &be64(new))?;
        Ok(self.head.get(H_M)?.map(|v| from_be64(&v)).unwrap_or(0).saturating_sub(new))
    }
    pub fn supply(&self) -> Result<(u64,u64)> {
        Ok((
            self.head.get(H_M)?.map(|v| from_be64(&v)).unwrap_or(0),
            self.head.get(H_B)?.map(|v| from_be64(&v)).unwrap_or(0),
        ))
    }

    // ===== Транзакции / история аккаунта =====
    pub fn get_tx(&self, txid: &str) -> Result<Option<StoredTx>> {
        Ok(self.txs.get(k_tx(txid))?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    pub fn account_txs_page(&self, rid: &str, _cursor: u64, limit: u64) -> Result<Vec<StoredTx>> {
        let mut out = Vec::new();
        let prefix = acct_prefix(rid).into_bytes();
        for kv in self.acct.scan_prefix(prefix).take(limit as usize) {
            let (_k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap();
            if let Some(stx) = self.get_tx(&txid)? {
                out.push(stx);
            }
        }
        Ok(out)
    }

    // ===== Простой приём tx (возвращаем StoredTx и принимаем memo) =====
    pub fn submit_tx_simple(&self, from: &str, to: &str, amount: u64, nonce: u64, memo: Option<String>) -> Result<StoredTx> {
        // проверка nonce
        let prev = self.get_nonce(from)?;
        if nonce != prev + 1 && nonce <= prev { anyhow::bail!("bad nonce"); }

        // балансы
        let bf = self.get_balance(from)?;
        if bf < amount { anyhow::bail!("insufficient balance"); }
        self.set_balance(from, (bf - amount) as u128)?;
        let bt = self.get_balance(to)?;
        self.set_balance(to, (bt.saturating_add(amount)) as u128)?;
        self.set_nonce(from, nonce)?;

        // txid
        let mut h = Hasher::new();
        h.update(from.as_bytes());
        h.update(to.as_bytes());
        h.update(&be64(amount));
        h.update(&be64(nonce));
        let txid = h.finalize().to_hex().to_string();

        // индексируем на высоте head+1
        let h_now = self.load_head_height();
        let h_tx  = h_now + 1;
        let ts    = now_ms();

        let stx = StoredTx {
            txid: txid.clone(), from: from.to_string(), to: to.to_string(),
            amount, nonce, height: h_tx, index: 0, ts, memo,
        };

        self.txs.insert(k_tx(&txid), serde_json::to_vec(&stx)?)?;
        self.acct.insert(k_acct(from, h_tx, 0), txid.as_bytes())?;
        self.acct.insert(k_acct(to,   h_tx, 0), txid.as_bytes())?;

        Ok(stx)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs:24:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs:29:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=326b)
```rust
pub mod types;
pub mod ledger;
pub mod phase_consensus;
pub mod engine;
pub mod phase_filters;

// Полный ре-экспорт, чтобы узел видел все публичные методы/типы без рассинхрона
pub use types::*;
pub use ledger::*;
pub use engine::*;
pub use phase_consensus::*;

```

## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```text
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=3906b)
```rust
use crate::types::*;
use std::collections::{BTreeMap, BTreeSet};
use std::time::{Duration, Instant};

#[derive(Clone, Debug)]
pub struct Quorum { pub vs: ValidatorSet }
impl Quorum {
    pub fn new(vs: ValidatorSet) -> Self { Self { vs } }
    pub fn threshold(&self) -> usize { self.vs.two_thirds() }
}

#[derive(Clone, Debug)]
pub struct RoundState {
    pub height: u64,
    pub round:  u64,
    pub step:   BftStep,
    pub locked_qc:  Option<QuorumCert>,
    pub justify_qc: Option<QuorumCert>,
    pub votes_prepare:    BTreeMap<BlockHash, BTreeSet<ValidatorId>>,
    pub votes_precommit:  BTreeMap<BlockHash, BTreeSet<ValidatorId>>,
    pub votes_commit:     BTreeMap<BlockHash, BTreeSet<ValidatorId>>,
    pub last_tick: Instant,
    pub view_timeout: Duration,
}
impl RoundState {
    pub fn new(height: u64, round: u64, view_timeout: Duration) -> Self {
        Self {
            height, round, step: BftStep::Prepare,
            locked_qc: None, justify_qc: None,
            votes_prepare: BTreeMap::new(),
            votes_precommit: BTreeMap::new(),
            votes_commit: BTreeMap::new(),
            last_tick: Instant::now(),
            view_timeout,
        }
    }
}

#[derive(Clone, Debug)]
pub struct BftCore { pub quorum: Quorum, pub state: RoundState }

impl BftCore {
    pub fn new(quorum: Quorum, height: u64, round: u64, view_timeout_ms: u64) -> Self {
        Self { quorum, state: RoundState::new(height, round, Duration::from_millis(view_timeout_ms)) }
    }

    pub fn on_vote(&mut self, v: Vote) -> Option<QuorumCert> {
        if v.height != self.state.height || v.round < self.state.round { return None; }
        if !self.quorum.vs.contains(&v.validator) { return None; }

        match v.step {
            BftStep::Prepare => {
                self.state.votes_prepare.entry(v.block.clone()).or_default().insert(v.validator);
                self.try_qc(&v.block, BftStep::Prepare)
            }
            BftStep::PreCommit => {
                self.state.votes_precommit.entry(v.block.clone()).or_default().insert(v.validator);
                self.try_qc(&v.block, BftStep::PreCommit)
            }
            BftStep::Commit => {
                self.state.votes_commit.entry(v.block.clone()).or_default().insert(v.validator);
                self.try_qc(&v.block, BftStep::Commit)
            }
        }
    }

    fn try_qc(&mut self, block: &BlockHash, step: BftStep) -> Option<QuorumCert> {
        let map = match step {
            BftStep::Prepare => &self.state.votes_prepare,
            BftStep::PreCommit => &self.state.votes_precommit,
            BftStep::Commit => &self.state.votes_commit,
        };
        let voters = map.get(block)?;
        if voters.len() >= self.quorum.threshold() {
            let qc = QuorumCert {
                block: block.clone(), height: self.state.height, round: self.state.round,
                step, voters: voters.clone(),
            };
            match step {
                BftStep::Prepare   => { self.state.justify_qc = Some(qc.clone()); self.state.step = BftStep::PreCommit; }
                BftStep::PreCommit => { self.state.locked_qc  = Some(qc.clone()); self.state.step = BftStep::Commit; }
                BftStep::Commit    => { /* финализация будет в Engine */ }
            }
            return Some(qc);
        }
        None
    }

    pub fn on_tick(&mut self) -> Option<(u64, Option<QuorumCert>)> {
        if self.state.last_tick.elapsed() >= self.state.view_timeout {
            self.state.round += 1;
            self.state.step = BftStep::Prepare;
            self.state.votes_prepare.clear();
            self.state.votes_precommit.clear();
            self.state.votes_commit.clear();
            self.state.last_tick = std::time::Instant::now();
            return Some((self.state.round, self.state.locked_qc.clone()));
        }
        None
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_filters/mod.rs  (size=249b)
```rust
// lrb_core/src/phase_filters/mod.rs
use crate::types::Block;

/// Проходной фазовый фильтр (место для реальной логики Σ(t)/фаз).
#[inline]
pub fn block_passes_phase(_blk: &Block) -> bool {
    true
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=1695b)
```rust
use anyhow::{anyhow, Result};
use ed25519_dalek::{Signature, VerifyingKey, Verifier};
use hex::FromHex;
use bs58;

use crate::types::Transaction;

/// b"LOGOS|" + pk_from + "|" + pk_to + "|" + amount_be + "|" + nonce_be
fn canonical_message(from_vk: &VerifyingKey, to_vk: &VerifyingKey, amount: u64, nonce: u64) -> Vec<u8> {
    let mut v = Vec::with_capacity(8 + 32 + 32 + 8 + 8);
    v.extend_from_slice(b"LOGOS|");
    v.extend_from_slice(&from_vk.to_bytes());
    v.push(b'|');
    v.extend_from_slice(&to_vk.to_bytes());
    v.push(b'|');
    v.extend_from_slice(&amount.to_be_bytes());
    v.push(b'|');
    v.extend_from_slice(&nonce.to_be_bytes());
    v
}

pub fn verify_tx_signature(tx: &Transaction) -> Result<()> {
    let from_pk: [u8; 32] = bs58::decode(&tx.from.0).into_vec().map_err(|_| anyhow!("rid decode failed"))?
        .as_slice().try_into().map_err(|_| anyhow!("bad from pk length"))?;
    let to_pk: [u8; 32]   = bs58::decode(&tx.to.0).into_vec().map_err(|_| anyhow!("rid decode failed"))?
        .as_slice().try_into().map_err(|_| anyhow!("bad to pk length"))?;

    let from_vk = VerifyingKey::from_bytes(&from_pk).map_err(|_| anyhow!("bad from pubkey"))?;
    let to_vk   = VerifyingKey::from_bytes(&to_pk).map_err(|_| anyhow!("bad to pubkey"))?;

    let sig_bytes: Vec<u8> = Vec::from_hex(&tx.sig).map_err(|_| anyhow!("sig hex decode"))?;
    let sig = Signature::from_slice(sig_bytes.as_slice().try_into().map_err(|_| anyhow!("bad sig length"))?)
        .map_err(|_| anyhow!("sig parse"))?;

    let msg = canonical_message(&from_vk, &to_vk, tx.amount.0, tx.nonce.0);
    from_vk.verify(&msg, &sig).map_err(|_| anyhow!("signature verify failed"))?;
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=2031b)
```rust
use anyhow::{anyhow, Result};
use base64::{engine::general_purpose::STANDARD as B64, Engine};
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub sigma_hex: String,     // Σ-дайджест (hex)
    pub block_hash: String,    // хеш блока (hex/строка)
    pub height: u64,           // высота
    pub voter_pk_b58: String,  // base58(pubkey)
    pub sig_b64: String,       // base64(signature)
    pub nonce_ms: u128,        // анти-реплей, миллисекунды
}

/// Проверка подписи голоса.
/// Каноника сообщения: concat( sigma_hex | block_hash | height(le) | nonce_ms(le) )
pub fn verify_vote(v: &Vote) -> Result<()> {
    // 1) pubkey = base58 → [u8;32] → VerifyingKey
    let pk_bytes = bs58::decode(&v.voter_pk_b58)
        .into_vec()
        .map_err(|_| anyhow!("bad voter pk b58"))?;
    let arr: [u8; 32] = pk_bytes
        .try_into()
        .map_err(|_| anyhow!("bad pubkey len"))?;
    let vk = VerifyingKey::from_bytes(&arr)
        .map_err(|_| anyhow!("bad ed25519 pubkey"))?;

    // 2) sig = base64 → [u8;64] → Signature
    let sig_bytes = B64
        .decode(v.sig_b64.as_bytes())
        .map_err(|_| anyhow!("bad sig b64"))?;
    let sig_arr: [u8; 64] = sig_bytes
        .as_slice()
        .try_into()
        .map_err(|_| anyhow!("bad sig len"))?;
    let sig = Signature::from_bytes(&sig_arr);

    // 3) payload (строковая каноника + числа в LE)
    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    // 4) verify
    vk.verify(&payload, &sig)
        .map_err(|e| anyhow!("verify failed: {e}"))?;
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=1622b)
```rust
use std::sync::Arc;
use anyhow::Result;
use tokio::time::{sleep, Duration};
use tracing::info;

use crate::ledger::{Block, Ledger, Tx};

pub struct RcpEngine {
    pub ledger: Arc<Ledger>,
    // тут могут быть поля сети/коммуникаций — опущено в этом минимале
}

impl RcpEngine {
    pub fn new(ledger: Arc<Ledger>) -> Self {
        Self { ledger }
    }

    pub async fn run(mut self) -> Result<()> {
        // простейший цикл: финализация quorum=1 + тик
        loop {
            self.tick_once().await?;
            sleep(Duration::from_millis(500)).await;
        }
    }

    async fn tick_once(&mut self) -> Result<()> {
        // пример: читаем текущую высоту, проверяем, что блок доступен
        let h = self.ledger.head_height();
        if let Ok(Some(b)) = self.ledger.get_block_by_height(h) {
            // в нашем минимале id блока — «хеш»
            let voted_hash = b.id.clone();
            // финализируем (quorum=1)
            let fin = self.ledger.finalized_height();
            if h > fin {
                self.ledger.set_finalized(h)?;
                info!("finalized #{} id={}", h, voted_hash);
            }
        }
        Ok(())
    }

    /// Коммитим готовый блок (например, собранный из mempool в другом месте)
    pub fn commit_block(&self, txs: Vec<Tx>) -> Result<bool> {
        let b = Block::new_from_txs(&txs);
        self.ledger.commit_block(b)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```rust
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```

## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```rust
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```

## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```rust
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=2197b)
```rust
use serde::{Deserialize, Serialize};
use std::fmt::{Display, Formatter};
use std::collections::BTreeSet;
use hex::ToHex;

// === Базовые типы, которые ждут другие модули ===
pub type Nonce  = u64;
pub type Amount = u64;

#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
pub struct Rid(pub String);

#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
pub struct BlockHash(pub [u8; 32]);

impl Display for BlockHash {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0.encode_hex::<String>())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Transaction {
    pub from: Rid,
    pub to:   Rid,
    pub amount: Amount,
    pub nonce:  Nonce,
    pub memo:   Option<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Block {
    pub hash:   BlockHash,
    pub height: u64,
    pub txs:    Vec<Transaction>,
    pub ts_ms:  u128,
}

// === Валидаторы / BFT ===
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
pub struct ValidatorId(pub String);

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ValidatorSet {
    pub validators: Vec<ValidatorId>,
}
impl ValidatorSet {
    pub fn total(&self) -> usize { self.validators.len() }
    pub fn two_thirds(&self) -> usize { (self.validators.len() * 2 + 2) / 3 } // ceil(2N/3)
    pub fn contains(&self, v: &ValidatorId) -> bool { self.validators.iter().any(|x| x == v) }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum BftStep { Prepare, PreCommit, Commit }

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub round:  u64,
    pub step:   BftStep,
    pub block:  BlockHash,
    pub validator: ValidatorId,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct QuorumCert {
    pub block:  BlockHash,
    pub height: u64,
    pub round:  u64,
    pub step:   BftStep,
    pub voters: BTreeSet<ValidatorId>,
}
impl QuorumCert { pub fn weight(&self) -> usize { self.voters.len() } }

```

## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```python
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```

## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```rust
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=997b)
```rust
//! Безопасная версия external_phase_link без unsafe-кастов.
//! Состояние защищено через RwLock. Однопоточная производительность сохраняется.

use std::sync::{Arc, RwLock};
use anyhow::Result;

#[derive(Default, Clone, Debug)]
pub struct PhaseState {
    pub last_tick_ms: u64,
    pub phase_strength: f32,
}

#[derive(Clone)]
pub struct ExternalPhaseLink {
    state: Arc<RwLock<PhaseState>>,
}

impl ExternalPhaseLink {
    pub fn new() -> Self {
        Self { state: Arc::new(RwLock::new(PhaseState::default())) }
    }

    pub fn tick(&self, now_ms: u64, input_strength: f32) -> Result<()> {
        let mut st = self.state.write().expect("rwlock poisoned");
        st.last_tick_ms = now_ms;
        st.phase_strength = 0.9 * st.phase_strength + 0.1 * input_strength;
        Ok(())
    }

    pub fn snapshot(&self) -> PhaseState {
        self.state.read().expect("rwlock poisoned").clone()
    }
}

```

## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```rust
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```yaml
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```

## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```rust
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```rust
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```yaml
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```

## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```tsx
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```

## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```yaml
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```

## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```yaml
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```

## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```python
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```

## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```rust
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```python
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```

## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```rust
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```rust
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/node/build.rs  (size=2370b)
```rust
use std::{
    env, fs,
    path::PathBuf,
    process::Command,
    time::{UNIX_EPOCH, Duration},
};

fn ts_rfc3339() -> String {
    // Репродьюс билды: уважаем SOURCE_DATE_EPOCH
    if let Ok(val) = env::var("SOURCE_DATE_EPOCH") {
        if let Ok(secs) = val.parse::<u64>() {
            let dt = chrono::DateTime::<chrono::Utc>::from(UNIX_EPOCH + Duration::from_secs(secs));
            return dt.to_rfc3339();
        }
    }
    chrono::Utc::now().to_rfc3339()
}

fn git_short() -> String {
    Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|o| if o.status.success() {
            Some(String::from_utf8_lossy(&o.stdout).trim().to_string())
        } else { None })
        .unwrap_or_else(|| "unknown".to_string())
}

fn git_dirty() -> String {
    Command::new("git")
        .args(["status", "--porcelain"])
        .output()
        .ok()
        .map(|o| if !o.stdout.is_empty() { "1" } else { "0" }.to_string())
        .unwrap_or_else(|| "0".to_string())
}

fn write_build_info(ts: &str, git: &str, dirty: &str) {
    let pkg = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "0.0.0".to_string());
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR is set by cargo");
    let mut path = PathBuf::from(out_dir);
    path.push("build_info.rs");

    // Важно: используем ВНЕШНИЙ док-коммент `///`, а не `//!`
    let contents = format!(
        r#"/// Auto-generated by build.rs
pub const BUILD_TS: &str = "{ts}";
pub const GIT_COMMIT_SHORT: &str = "{git}";
pub const GIT_DIRTY: &str = "{dirty}";
pub const PKG_VERSION: &str = "{pkg}";
"#,
        ts = ts, git = git, dirty = dirty, pkg = pkg
    );

    fs::write(&path, contents).expect("write build_info.rs");
}

fn main() {
    // Триггеры пересборки
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=SOURCE_DATE_EPOCH");

    // Данные сборки
    let ts = ts_rfc3339();
    let git = git_short();
    let dirty = git_dirty();

    // Env (для рантайма)
    println!("cargo:rustc-env=BUILD_TS={}", ts);
    println!("cargo:rustc-env=GIT_COMMIT_SHORT={}", git);
    println!("cargo:rustc-env=GIT_DIRTY={}", dirty);

    // Файл для include!
    write_build_info(&ts, &git, &dirty);
}

```

## FILE: /root/logos_lrb/node/build.rs.bak.20250921T152855Z  (size=1722b)
```text
use std::{env, fs, path::PathBuf, process::Command};

fn main() {
    // короткий git-хеш (если git доступен)
    let git_hash = Command::new("git")
        .args(["rev-parse", "--short=12", "HEAD"])
        .output()
        .ok()
        .and_then(|o| if o.status.success() {
            Some(String::from_utf8_lossy(&o.stdout).trim().to_string())
        } else { None })
        .unwrap_or_else(|| "unknown".into());

    // текущая ветка
    let git_branch = Command::new("git")
        .args(["rev-parse", "--abbrev-ref", "HEAD"])
        .output()
        .ok()
        .and_then(|o| if o.status.success() {
            Some(String::from_utf8_lossy(&o.stdout).trim().to_string())
        } else { None })
        .unwrap_or_else(|| "unknown".into());

    // версия пакета и время сборки
    let pkg_ver = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "0.0.0".into());
    let ts = chrono::Utc::now().to_rfc3339();

    // записываем build_info.rs в OUT_DIR
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let dest = out_dir.join("build_info.rs");
    let contents = format!(
        "pub const BUILD_GIT_HASH: &str = \"{git_hash}\";\n\
         pub const BUILD_GIT_BRANCH: &str = \"{git_branch}\";\n\
         pub const BUILD_TIMESTAMP_RFC3339: &str = \"{ts}\";\n\
         pub const BUILD_PKG_VERSION: &str = \"{pkg_ver}\";\n"
    );
    fs::write(&dest, contents).expect("write build_info.rs failed");

    // триггеры пересборки
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=../Cargo.toml");
    println!("cargo:rerun-if-changed=.git/HEAD");
}

```

## FILE: /root/logos_lrb/node/Cargo.toml  (size=2350b)
```toml
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"

[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# ---- core ----
lrb_core     = { path = "../lrb_core" }

# ---- web stack: Axum 0.7 + tower-http 0.5 (Hyper 1) ----
axum         = { version = "0.7.5", features = ["macros"] }
# hyper как прямую зависимость не указываем (axum/tower-http подтянут нужную 1.x)
tower = { version = "0.4.13", default-features = false, features = ["limit", "timeout"] }
# фичи оставим минимальными (trace + cors). Сжатие добавим позже при надобности.
tower-http   = { version = "0.5.2", default-features = false, features = ["trace", "cors"] }

# ---- async/runtime ----
tokio        = { version = "1.40", features = ["full"] }

# ---- utils / логирование / метрики ----
serde        = { version = "1.0", features = ["derive"] }
serde_json   = "1.0"
anyhow       = "1.0"
thiserror    = "1.0"
once_cell    = "1.19"
tracing      = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus   = "0.13"

# ---- crypto / hash / codecs ----
sha2         = "0.10"
blake3       = "1.5"
ed25519-dalek = { version = "2", features = ["rand_core"] }
hex          = "0.4"
base64       = "0.22"
rand         = "0.8"
uuid         = { version = "1.8", features = ["v4"] }

# ---- хранилища / БД (архив) ----
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# ---- http-клиент (нужен blocking для утилит в src/bin/*) ----
reqwest      = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls", "blocking"] }

# ---- утилиты CLI / безоп. очистка ----
clap         = { version = "4.5", features = ["derive"] }
zeroize      = "1.8"

# ---- встретившиеся в коде ----
hmac         = "0.12"
bs58         = "0.5"
parking_lot  = "0.12"

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.124637  (size=2406b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# --- бинарь узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

# --- вспомогательные утилиты (можно закомментировать, если не нужны) ---
[[bin]]
name = "mint"
path = "src/bin/mint.rs"

[[bin]]
name = "make_tx"
path = "src/bin/make_tx.rs"

[[bin]]
name = "bench_burst"
path = "src/bin/bench_burst.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# базовый стек (всё из workspace — единые версии)
axum.workspace                = true
tower.workspace               = true
tower-http.workspace          = true
tokio.workspace               = true

serde.workspace               = true
serde_json.workspace          = true
anyhow.workspace              = true
thiserror.workspace           = true
once_cell.workspace           = true
dashmap.workspace             = true
tracing.workspace             = true
tracing-subscriber.workspace  = true
sha2.workspace                = true   # canonical_msg в API

# хранилища/индексация
sled.workspace                = true
deadpool-postgres.workspace   = true
tokio-postgres.workspace      = true
rusqlite.workspace            = true
r2d2_sqlite.workspace         = true

# утилиты/крипта/метрики
hex.workspace                 = true
base64.workspace              = true
bs58.workspace                = true
ed25519-dalek.workspace       = true
blake3.workspace              = true
ipnet.workspace               = true
prometheus.workspace          = true
uuid.workspace                = true

# === ДОБАВЛЕНО (security & utils) ===
# HMAC-SHA256 для подписи тела моста (deposit/redeem)
hmac = { version = "0.12", default-features = false }
# джиттер/phase-mixing в guard
rand = { version = "0.8", features = ["std","std_rng"] }
# мьютексы в state.rs (parking_lot::Mutex)
parking_lot = "0.12"

# для bin-утилит
reqwest   = { workspace = true, features = ["blocking","json"] }
rand_core = "0.6"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.141054  (size=2406b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# --- бинарь узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

# --- вспомогательные утилиты (можно закомментировать, если не нужны) ---
[[bin]]
name = "mint"
path = "src/bin/mint.rs"

[[bin]]
name = "make_tx"
path = "src/bin/make_tx.rs"

[[bin]]
name = "bench_burst"
path = "src/bin/bench_burst.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# базовый стек (всё из workspace — единые версии)
axum.workspace                = true
tower.workspace               = true
tower-http.workspace          = true
tokio.workspace               = true

serde.workspace               = true
serde_json.workspace          = true
anyhow.workspace              = true
thiserror.workspace           = true
once_cell.workspace           = true
dashmap.workspace             = true
tracing.workspace             = true
tracing-subscriber.workspace  = true
sha2.workspace                = true   # canonical_msg в API

# хранилища/индексация
sled.workspace                = true
deadpool-postgres.workspace   = true
tokio-postgres.workspace      = true
rusqlite.workspace            = true
r2d2_sqlite.workspace         = true

# утилиты/крипта/метрики
hex.workspace                 = true
base64.workspace              = true
bs58.workspace                = true
ed25519-dalek.workspace       = true
blake3.workspace              = true
ipnet.workspace               = true
prometheus.workspace          = true
uuid.workspace                = true

# === ДОБАВЛЕНО (security & utils) ===
# HMAC-SHA256 для подписи тела моста (deposit/redeem)
hmac = { version = "0.12", default-features = false }
# джиттер/phase-mixing в guard
rand = { version = "0.8", features = ["std","std_rng"] }
# мьютексы в state.rs (parking_lot::Mutex)
parking_lot = "0.12"

# для bin-утилит
reqwest   = { workspace = true, features = ["blocking","json"] }
rand_core = "0.6"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.141744  (size=2463b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# --- бинарь узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

# --- вспомогательные утилиты (можно закомментировать, если не нужны) ---
[[bin]]
name = "mint"
path = "src/bin/mint.rs"

[[bin]]
name = "make_tx"
path = "src/bin/make_tx.rs"

[[bin]]
name = "bench_burst"
path = "src/bin/bench_burst.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# базовый стек (всё из workspace — единые версии)
axum.workspace                = true
tower.workspace               = true
tower-http.workspace          = true
tokio.workspace               = true

serde.workspace               = true
serde_json.workspace          = true
anyhow.workspace              = true
thiserror.workspace           = true
once_cell.workspace           = true
dashmap.workspace             = true
tracing.workspace             = true
tracing-subscriber.workspace  = true
sha2.workspace                = true   # canonical_msg в API

# хранилища/индексация
sled.workspace                = true
deadpool-postgres.workspace   = true
tokio-postgres.workspace      = true
rusqlite.workspace            = true
r2d2_sqlite.workspace         = true

# утилиты/крипта/метрики
hex.workspace                 = true
base64.workspace              = true
bs58.workspace                = true
ed25519-dalek.workspace       = true
blake3.workspace              = true
ipnet.workspace               = true
prometheus.workspace          = true
uuid.workspace                = true

# === ДОБАВЛЕНО (security & utils) ===
# HMAC-SHA256 для подписи тела моста (deposit/redeem)
hmac = { version = "0.12", default-features = false }
# джиттер/phase-mixing в guard
rand = { version = "0.8", features = ["std","std_rng"] }
# мьютексы в state.rs (parking_lot::Mutex)
parking_lot = "0.12"

# для bin-утилит
reqwest   = { workspace = true, features = ["blocking","json"] }
rand_core = "0.6"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }
hyper = { version = "1", features = ["http1","server"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250921T133102Z  (size=2031b)
```text
[package]
name    = "logos_node"
version = "0.1.0"
edition = "2021"
build   = "build.rs"

# --- бин узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

# --- утилиты ---
[[bin]]
name = "rid_gen"
path = "src/bin/rid_gen.rs"

[[bin]]
name = "sign_submit"
path = "src/bin/sign_submit.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# ===== Axum стек (СТАБИЛЬНЫЙ КАНОН) =====
hyper = "0.14"
axum       = { version = "0.6", features = ["http1","json","macros"] }
tokio      = { version = "1",   features = ["rt-multi-thread","macros","signal"] }
tower      = { version = "0.4", features = ["util"] }            # make НЕ нужен
tower-http = { version = "0.4", features = ["trace","util"] }

# ===== Логирование =====
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt","env-filter"] }

# ===== Сериализация =====
serde      = { version = "1", features = ["derive"] }
serde_json = "1"

# ===== Метрики/утилы/крипта =====
prometheus      = "0.13"
sha2            = "0.10"
bs58            = "0.5"
ed25519-dalek   = { version = "2", features = ["rand_core"] }
blake3          = "1"
hmac            = { version = "0.12", default-features = false }
rand            = { version = "0.8", features = ["std","std_rng"] }
hex             = "0.4"
anyhow          = "1"
once_cell       = "1.19"
base64          = "0.22"
parking_lot     = "0.12"
clap            = { version = "4", features = ["derive"] }
zeroize         = "1"

# ===== Хранилища / БД =====
sled             = "0.34"
deadpool-postgres= "0.12"
tokio-postgres   = "0.7"
rusqlite         = { version = "0.31", features = ["bundled"] }

# ===== HTTP-клиент для утилит =====
reqwest          = { version = "0.12", features = ["blocking","json"] }

# ===== ядро =====
lrb_core         = { path = "../lrb_core" }

[build-dependencies]
chrono           = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250921T135301Z  (size=2281b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# --- бинарники узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

[[bin]]
name = "mint"
path = "src/bin/mint.rs"

[[bin]]
name = "make_tx"
path = "src/bin/make_tx.rs"

[[bin]]
name = "bench_burst"
path = "src/bin/bench_burst.rs"

# --- lib для общих модулей (metrics, bridge utils и т.д.) ---
[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# core
lrb_core = { path = "../lrb_core" }

# web stack (Axum 0.6 + Hyper 0.14)
axum        = { version = "0.6.20", features = ["macros", "http1", "json"] }
hyper       = { version = "0.14.32", features = ["http1", "http2", "server", "tcp"] }
tokio       = { version = "1.40", features = ["full"] }
tower       = "0.4.13"
# включаем нужные фичи tower-http (иначе будут ошибки 'cors'/'compression')
tower-http  = { version = "0.4.4", default-features = false, features = [
  "trace",
  "cors",
  "compression-gzip",
  "decompression-gzip"
] }

# utils / логирование / метрики
serde       = { version = "1.0", features = ["derive"] }
serde_json  = "1.0"
anyhow      = "1.0"
thiserror   = "1.0"
once_cell   = "1.19"
tracing     = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus  = "0.13"

# crypto / hash / codecs (если используются в узле)
sha2        = "0.10"
blake3      = "1.5"
ed25519-dalek = "2"
hex         = "0.4"
base64      = "0.22"
rand        = "0.8"
uuid        = { version = "1.8", features = ["v4"] }

# хранилища / БД (архив)
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# http-клиент (для внешних вызовов/провайдера)
reqwest     = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls"] }

[build-dependencies]
# build.rs использует chrono::Utc — добавляем зависимость для скрипта сборки
chrono = "0.4"

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250921T152031Z  (size=2329b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# --- бинарники узла ---
[[bin]]
name = "logos_node"
path = "src/main.rs"

[[bin]]
name = "mint"
path = "src/bin/mint.rs"

[[bin]]
name = "make_tx"
path = "src/bin/make_tx.rs"

[[bin]]
name = "bench_burst"
path = "src/bin/bench_burst.rs"

# --- lib для общих модулей (metrics, bridge utils и т.д.) ---
[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# core
lrb_core = { path = "../lrb_core" }

# web stack (Axum 0.6 + Hyper 0.14)
axum        = { version = "0.6.20", features = ["macros", "http1", "json"] }
hyper       = { version = "0.14.32", features = ["http1", "http2", "server", "tcp"] }
tokio       = { version = "1.40", features = ["full"] }
tower       = "0.4.13"
# включаем нужные фичи tower-http (иначе будут ошибки 'cors'/'compression')
tower-http  = { version = "0.4.4", default-features = false, features = [
  "trace",
  "cors",
  "compression-gzip",
  "decompression-gzip"
] }

# utils / логирование / метрики
serde       = { version = "1.0", features = ["derive"] }
serde_json  = "1.0"
anyhow      = "1.0"
thiserror   = "1.0"
once_cell   = "1.19"
tracing     = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus  = "0.13"

# crypto / hash / codecs (если используются в узле)
sha2        = "0.10"
blake3      = "1.5"
ed25519-dalek = "2"
hex         = "0.4"
base64      = "0.22"
rand        = "0.8"
uuid        = { version = "1.8", features = ["v4"] }

# хранилища / БД (архив)
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# http-клиент (для внешних вызовов/провайдера)
reqwest     = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls"] }
hmac = "0.12"
bs58 = "0.5"
parking_lot = "0.12"

[build-dependencies]
# build.rs использует chrono::Utc — добавляем зависимость для скрипта сборки
chrono = "0.4"

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250921T152838Z  (size=2436b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
# Если у тебя есть build.rs — оставь строку ниже; если нет, можно закомментировать
# build       = "build.rs"

# Бинарники: Cargo всё равно подхватит всё из src/bin/*.rs, даже если их не перечислять.
[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# core
lrb_core     = { path = "../lrb_core" }

# web stack (Axum 0.6 + Hyper 0.14)
axum         = { version = "0.6.20", features = ["macros", "http1", "json"] }
hyper        = { version = "0.14.32", features = ["http1", "http2", "server", "tcp"] }
tokio        = { version = "1.40", features = ["full"] }
tower        = "0.4.13"
# включаем нужные фичи tower-http (иначе будут ошибки 'cors'/'compression')
tower-http   = { version = "0.4.4", default-features = false, features = [
  "trace",
  "cors",
  "compression-gzip",
  "decompression-gzip"
] }

# utils / логирование / метрики
serde        = { version = "1.0", features = ["derive"] }
serde_json   = "1.0"
anyhow       = "1.0"
thiserror    = "1.0"
once_cell    = "1.19"
tracing      = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus   = "0.13"

# crypto / hash / codecs (если используются в узле)
sha2         = "0.10"
blake3       = "1.5"
ed25519-dalek = "2"
hex          = "0.4"
base64       = "0.22"
rand         = "0.8"
uuid         = { version = "1.8", features = ["v4"] }

# хранилища / БД (архив)
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# http-клиент:
# ВКЛЮЧЕНА фича "blocking", чтобы компилировались src/bin/*, которые используют reqwest::blocking::Client
reqwest      = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls", "blocking"] }

# полезные для узла зависимости, которые уже встречались в коде
hmac         = "0.12"
bs58         = "0.5"
parking_lot  = "0.12"

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250921T165322Z  (size=2314b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
# build.rs подхватится автоматически, т.к. файл существует в корне пакета

[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# core
lrb_core     = { path = "../lrb_core" }

# web stack (Axum 0.6 + Hyper 0.14)
axum         = { version = "0.6.20", features = ["macros", "http1", "json"] }
hyper        = { version = "0.14.32", features = ["http1", "http2", "server", "tcp"] }
tokio        = { version = "1.40", features = ["full"] }
tower        = "0.4.13"
# включаем нужные фичи tower-http (иначе будут ошибки 'cors'/'compression')
tower-http   = { version = "0.4.4", default-features = false, features = [
  "trace",
  "cors",
  "compression-gzip",
  "decompression-gzip"
] }

# utils / логирование / метрики
serde        = { version = "1.0", features = ["derive"] }
serde_json   = "1.0"
anyhow       = "1.0"
thiserror    = "1.0"
once_cell    = "1.19"
tracing      = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus   = "0.13"

# crypto / hash / codecs
sha2         = "0.10"
blake3       = "1.5"
ed25519-dalek = "2"
hex          = "0.4"
base64       = "0.22"
rand         = "0.8"
uuid         = { version = "1.8", features = ["v4"] }

# хранилища / БД (архив)
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# http-клиент (есть утилиты src/bin/*, которым нужен reqwest::blocking)
reqwest      = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls", "blocking"] }

# доп. зависимости, встречающиеся в коде узла
hmac         = "0.12"
bs58         = "0.5"
parking_lot  = "0.12"

[build-dependencies]
# минимальная сборка chrono для build.rs: без тяжёлых таймзон, только часы
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250922T021131Z  (size=2225b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"

[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# core
lrb_core     = { path = "../lrb_core" }

# web stack (Axum 0.6 + Hyper 0.14)
axum         = { version = "0.6.20", features = ["macros", "http1", "json"] }
hyper        = { version = "0.14.32", features = ["http1", "http2", "server", "tcp"] }
tokio        = { version = "1.40", features = ["full"] }
tower        = "0.4.13"
tower-http   = { version = "0.4.4", default-features = false, features = [
  "trace",
  "cors",
  "compression-gzip",
  "decompression-gzip"
] }

# utils / логирование / метрики
serde        = { version = "1.0", features = ["derive"] }
serde_json   = "1.0"
anyhow       = "1.0"
thiserror    = "1.0"
once_cell    = "1.19"
tracing      = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus   = "0.13"

# crypto / hash / codecs
sha2         = "0.10"
blake3       = "1.5"
# ВАЖНО: включаем rand_core, чтобы был SigningKey::generate(&mut OsRng)
ed25519-dalek = { version = "2", features = ["rand_core"] }
hex          = "0.4"
base64       = "0.22"
rand         = "0.8"
uuid         = { version = "1.8", features = ["v4"] }

# хранилища / БД (архив)
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# http-клиент (нужен blocking для утилит в src/bin/*)
reqwest      = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls", "blocking"] }

# для утилит в src/bin/*
clap         = { version = "4.5", features = ["derive"] }
zeroize      = "1.8"

# дополнительно встречались
hmac         = "0.12"
bs58         = "0.5"
parking_lot  = "0.12"

[build-dependencies]
# build.rs использует chrono (минимальная сборка)
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/Cargo.toml.bak.20250922T042246Z  (size=2284b)
```text
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"

[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# ---- core ----
lrb_core     = { path = "../lrb_core" }

# ---- web stack: Axum 0.7 + tower-http 0.5 (Hyper 1) ----
axum         = { version = "0.7.5", features = ["macros"] }
# hyper как прямую зависимость не указываем (axum/tower-http подтянут нужную 1.x)
tower        = "0.4.13"
# фичи оставим минимальными (trace + cors). Сжатие добавим позже при надобности.
tower-http   = { version = "0.5.2", default-features = false, features = ["trace", "cors"] }

# ---- async/runtime ----
tokio        = { version = "1.40", features = ["full"] }

# ---- utils / логирование / метрики ----
serde        = { version = "1.0", features = ["derive"] }
serde_json   = "1.0"
anyhow       = "1.0"
thiserror    = "1.0"
once_cell    = "1.19"
tracing      = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus   = "0.13"

# ---- crypto / hash / codecs ----
sha2         = "0.10"
blake3       = "1.5"
ed25519-dalek = { version = "2", features = ["rand_core"] }
hex          = "0.4"
base64       = "0.22"
rand         = "0.8"
uuid         = { version = "1.8", features = ["v4"] }

# ---- хранилища / БД (архив) ----
sled               = "0.34"
deadpool-postgres  = { version = "0.14", features = ["serde"] }
tokio-postgres     = { version = "0.7", features = ["with-uuid-1"] }

# ---- http-клиент (нужен blocking для утилит в src/bin/*) ----
reqwest      = { version = "0.11.27", default-features = false, features = ["json", "rustls-tls", "blocking"] }

# ---- утилиты CLI / безоп. очистка ----
clap         = { version = "4.5", features = ["derive"] }
zeroize      = "1.8"

# ---- встретившиеся в коде ----
hmac         = "0.12"
bs58         = "0.5"
parking_lot  = "0.12"

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

## FILE: /root/logos_lrb/node/openapi/openapi.json  (size=7947b)
```json
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB — Core API", "version": "0.1.0", "description": "Public & Admin API for LOGOS LRB (strict CSP, JWT admin, rTokens, staking)." },
  "servers": [{ "url": "https://45-159-248-232.sslip.io" }],
  "paths": {
    "/healthz": { "get": { "summary": "Healthcheck", "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/OkMsg" }}}}}}},
    "/head":    { "get": { "summary": "Chain head",  "responses": { "200": { "description": "Head", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" }}}}}}},
    "/balance/{rid}": {
      "get": {
        "summary": "Account balance & nonce",
        "parameters": [{ "name":"rid","in":"path","required":true,"schema":{"type":"string"}}],
        "responses": { "200": { "description": "Balance", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Balance" }}}}}
      }
    },
    "/submit_tx": {
      "post": {
        "summary": "Submit transaction",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref":"#/components/schemas/TxIn" }}}},
        "responses": { "200": { "description": "Result", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" }}}}}
      }
    },
    "/economy": { "get": { "summary": "Economy snapshot", "responses": { "200": { "description": "Economy", "content": { "application/json": { "schema": { "$ref":"#/components/schemas/Economy" }}}}}}},
    "/history/{rid}": {
      "get": {
        "summary": "History by RID (sled index)",
        "parameters": [{ "name":"rid","in":"path","required":true,"schema":{"type":"string"}}],
        "responses": { "200": { "description": "History", "content": { "application/json": { "schema": { "type":"array","items":{"$ref":"#/components/schemas/HistoryItem"} }}}}}
      }
    },

    "/stake/submit":      { "post": { "summary":"Submit staking op", "requestBody":{ "required":true, "content":{"application/json":{"schema":{"$ref":"#/components/schemas/StakeTxIn"}}}}, "responses":{ "200":{ "description":"Result", "content":{ "application/json":{ "schema":{"$ref":"#/components/schemas/SubmitResult"}}}}}}},
    "/stake/validators":  { "get":  { "summary":"List validators", "responses":{ "200":{ "description":"OK", "content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ValidatorInfo"}}}}}}}},
    "/stake/delegations/{rid}": { "get": { "summary":"Delegations of RID", "parameters":[{ "name":"rid","in":"path","required":true,"schema":{"type":"string"}}], "responses":{ "200":{ "description":"OK", "content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DelegationInfo"}}}}}}}},
    "/stake/rewards/{rid}":     { "get": { "summary":"Rewards of RID",     "parameters":[{ "name":"rid","in":"path","required":true,"schema":{"type":"string"}}], "responses":{ "200":{ "description":"OK", "content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/RewardInfo"}}}}}}}},
    "/stake/params":      { "get":  { "summary":"Stake parameters", "responses":{ "200":{ "description":"OK", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/StakeParams"}}}}}}},

    "/admin/set_balance": { "post": { "summary":"Set balance (admin)", "security":[{"AdminJWT":[]}], "requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SetBalanceReq"}}}}, "responses":{"200":{"description":"OK"}}}},
    "/admin/set_nonce":   { "post": { "summary":"Set nonce (admin)",   "security":[{"AdminJWT":[]}], "requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SetNonceReq"}}}},   "responses":{"200":{"description":"OK"}}}},
    "/admin/bump_nonce":  { "post": { "summary":"Bump nonce (admin)",  "security":[{"AdminJWT":[]}], "requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BumpNonceReq"}}}}, "responses":{"200":{"description":"OK"}}}},
    "/admin/mint":        { "post": { "summary":"Add minted amount (admin)", "security":[{"AdminJWT":[]}], "requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/MintReq"}}}}, "responses":{"200":{"description":"OK"}}}},
    "/admin/burn":        { "post": { "summary":"Add burned amount (admin)", "security":[{"AdminJWT":[]}], "requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BurnReq"}}}}, "responses":{"200":{"description":"OK"}}}}
  },
  "components": {
    "securitySchemes": {
      "AdminJWT":  { "type":"apiKey", "in":"header", "name":"X-Admin-JWT" },
      "BridgeKey": { "type":"apiKey", "in":"header", "name":"X-Bridge-Key" }
    },
    "schemas": {
      "OkMsg": { "type":"object", "properties": { "status": { "type":"string" } } },
      "Head":  { "type":"object", "properties": { "height": { "type":"integer" } }, "required": ["height"] },
      "Balance": { "type":"object", "properties": { "rid":{"type":"string"}, "balance":{"type":"string"}, "nonce":{"type":"integer"} }, "required":["rid","balance","nonce"] },
      "TxIn": { "type":"object", "properties": { "from":{"type":"string"}, "to":{"type":"string"}, "amount":{"type":"integer","format":"uint64"}, "nonce":{"type":"integer","format":"uint64"}, "memo":{"type":"string","nullable":true}, "sig_hex":{"type":"string"} }, "required":["from","to","amount","nonce","sig_hex"] },
      "SubmitResult": { "type":"object", "properties": { "ok":{"type":"boolean"}, "txid":{"type":"string","nullable":true}, "info":{"type":"string"} }, "required":["ok","info"] },
      "Economy": { "type":"object", "properties": { "supply":{"type":"integer"}, "burned":{"type":"integer"}, "cap":{"type":"integer"} }, "required":["supply","burned","cap"] },
      "HistoryItem": { "type":"object", "properties": { "txid":{"type":"string"}, "height":{"type":"integer"}, "from":{"type":"string"}, "to":{"type":"string"}, "amount":{"type":"integer"}, "nonce":{"type":"integer"} }, "required":["txid","height","from","to","amount","nonce"] },

      "StakeTxIn": { "type":"object", "required":["from","op","nonce","sig_hex"], "properties": { "from":{"type":"string"}, "op":{"type":"string","enum":["delegate","undelegate","claim"]}, "validator":{"type":"string"}, "amount":{"type":"integer","format":"uint64"}, "nonce":{"type":"integer","format":"uint64"}, "sig_hex":{"type":"string"}, "memo":{"type":"string"} } },
      "ValidatorInfo": { "type":"object", "properties": { "rid":{"type":"string"}, "commission_bps":{"type":"integer"}, "self_bond":{"type":"integer"}, "voting_power":{"type":"integer"}, "status":{"type":"string"} } },
      "DelegationInfo": { "type":"object", "properties": { "validator":{"type":"string"}, "amount":{"type":"integer"}, "since_height":{"type":"integer"} } },
      "RewardInfo": { "type":"object", "properties": { "validator":{"type":"string"}, "pending":{"type":"integer"}, "last_height":{"type":"integer"} } },
      "StakeParams": { "type":"object", "properties": { "min_delegate":{"type":"integer"}, "unbond_period_blocks":{"type":"integer"}, "apr_estimate_bps":{"type":"integer"} } },

      "SetBalanceReq": { "type":"object", "properties": { "rid":{"type":"string"}, "amount":{"type":"integer"} }, "required":["rid","amount"] },
      "SetNonceReq":   { "type":"object", "properties": { "rid":{"type":"string"}, "value":{"type":"integer"} }, "required":["rid","value"] },
      "BumpNonceReq":  { "type":"object", "properties": { "rid":{"type":"string"} }, "required":["rid"] },
      "MintReq":       { "type":"object", "properties": { "amount":{"type":"integer"} }, "required":["amount"] },
      "BurnReq":       { "type":"object", "properties": { "amount":{"type":"integer"} }, "required":["amount"] }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/admin.rs  (size=2835b)
```rust
use axum::{extract::State, http::HeaderMap, response::IntoResponse, Json};
use crate::metrics::inc_total;
use serde::Deserialize;
use std::sync::Arc;
use serde_json::json;

use crate::state::AppState;
use crate::auth::require_admin;

#[derive(Deserialize)] pub struct SetBalanceReq { pub rid: String, pub amount: u128 }
#[derive(Deserialize)] pub struct BumpNonceReq  { pub rid: String }
#[derive(Deserialize)] pub struct SetNonceReq   { pub rid: String, pub value: u64 }
#[derive(Deserialize)] pub struct MintReq       { pub amount: u64 }
#[derive(Deserialize)] pub struct BurnReq       { pub amount: u64 }

pub async fn set_balance(State(app): State<Arc<AppState>>, headers: HeaderMap, Json(req): Json<SetBalanceReq>) -> impl IntoResponse {
    inc_total("admin_set_balance");
    if let Err(e) = require_admin(&headers) { return Json(json!({"ok":false,"err":e.to_string()})); }
    let l = app.ledger.write().await;
    match l.set_balance(&req.rid, req.amount) { Ok(_) => Json(json!({"ok":true})), Err(e)=>Json(json!({"ok":false,"err":e.to_string()})) }
}
pub async fn bump_nonce(State(app): State<Arc<AppState>>, headers: HeaderMap, Json(req): Json<BumpNonceReq>) -> impl IntoResponse {
    inc_total("admin_bump_nonce");
    if let Err(e) = require_admin(&headers) { return Json(json!({"ok":false,"err":e.to_string()})); }
    let l = app.ledger.write().await;
    match l.bump_nonce(&req.rid) { Ok(n)=>Json(json!({"ok":true,"nonce":n})), Err(e)=>Json(json!({"ok":false,"err":e.to_string()})) }
}
pub async fn set_nonce(State(app): State<Arc<AppState>>, headers: HeaderMap, Json(req): Json<SetNonceReq>) -> impl IntoResponse {
    inc_total("admin_set_nonce");
    if let Err(e) = require_admin(&headers) { return Json(json!({"ok":false,"err":e.to_string()})); }
    let l = app.ledger.write().await;
    match l.set_nonce(&req.rid, req.value) { Ok(_)=>Json(json!({"ok":true,"nonce":req.value})), Err(e)=>Json(json!({"ok":false,"err":e.to_string()})) }
}
pub async fn mint(State(app): State<Arc<AppState>>, headers: HeaderMap, Json(req): Json<MintReq>) -> impl IntoResponse {
    inc_total("admin_mint");
    if let Err(e) = require_admin(&headers) { return Json(json!({"ok":false,"err":e.to_string()})); }
    let l = app.ledger.write().await;
    match l.add_minted(req.amount) { Ok(net)=>Json(json!({"ok":true,"net_supply":net})), Err(e)=>Json(json!({"ok":false,"err":e.to_string()})) }
}
pub async fn burn(State(app): State<Arc<AppState>>, headers: HeaderMap, Json(req): Json<BurnReq>) -> impl IntoResponse {
    inc_total("admin_burn");
    if let Err(e) = require_admin(&headers) { return Json(json!({"ok":false,"err":e.to_string()})); }
    let l = app.ledger.write().await;
    match l.add_burned(req.amount) { Ok(net)=>Json(json!({"ok":true,"net_supply":net})), Err(e)=>Json(json!({"ok":false,"err":e.to_string()})) }
}

```

## FILE: /root/logos_lrb/node/src/api/archive.rs  (size=2097b)
```rust
use std::sync::Arc;
use axum::{
    extract::{State, Path, Query},
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Deserialize;
use crate::{state::AppState, archive::{BlockRow, TxRecord}};

#[derive(Deserialize)]
pub struct BlocksQuery { pub lim: Option<i64>, pub before: Option<i64> }

pub async fn archive_blocks(
    State(st): State<Arc<AppState>>,
    Query(q): Query<BlocksQuery>
) -> Response {
    let lim = q.lim.unwrap_or(50).clamp(1, 1000);
    let before = q.before;
    if let Some(arch) = &st.archive {
        if let Ok(list) = arch.recent_blocks(lim, before).await {
            return Json(list).into_response();
        }
    }
    Json(Vec::<BlockRow>::new()).into_response()
}

#[derive(Deserialize)]
pub struct TxsQuery { pub lim: Option<i64>, pub rid: Option<String>, pub before_ts: Option<i64> }

pub async fn archive_txs(
    State(st): State<Arc<AppState>>,
    Query(q): Query<TxsQuery>
) -> Response {
    let lim = q.lim.unwrap_or(50).clamp(1, 1000);
    let rid = q.rid;
    let before_ts = q.before_ts;
    if let Some(arch) = &st.archive {
        if let Ok(list) = arch.recent_txs(lim, rid, before_ts).await {
            return Json(list).into_response();
        }
    }
    Json(Vec::<TxRecord>::new()).into_response()
}

pub async fn archive_history(
    State(st): State<Arc<AppState>>,
    Path(rid): Path<String>
) -> Response {
    if let Some(arch) = &st.archive {
        if let Ok(list) = arch.history_by_rid(&rid, 100, None).await {
            return Json(list).into_response();
        }
    }
    Json(Vec::<TxRecord>::new()).into_response()
}

pub async fn archive_tx(
    State(st): State<Arc<AppState>>,
    Path(txid): Path<String>
) -> Response {
    if let Some(arch) = &st.archive {
        match arch.tx_by_id(&txid).await {
            Ok(Some(rec)) => return Json(rec).into_response(),
            Ok(None) => return StatusCode::NOT_FOUND.into_response(),
            Err(_) => return StatusCode::INTERNAL_SERVER_ERROR.into_response(),
        }
    }
    StatusCode::NOT_IMPLEMENTED.into_response()
}

```

## FILE: /root/logos_lrb/node/src/api/base.rs  (size=2040b)
```rust
use axum::{extract::{Path, State}, Json};
use std::sync::Arc;

use crate::state::AppState;
use super::{OkMsg, Head, Balance, Economy, HistoryItem};

/// GET /healthz
pub async fn healthz() -> Json<OkMsg> {
    Json(OkMsg { status: "ok" })
}

/// GET /head
pub async fn head(State(app): State<Arc<AppState>>) -> Json<Head> {
    let l = app.ledger.read().await;
    let h = l.height().unwrap_or(0);
    let fin = h.saturating_sub(1);
    Json(Head { height: h, finalized: fin })
}

/// GET /balance/:rid
pub async fn balance(
    Path(rid): Path<String>,
    State(app): State<Arc<AppState>>,
) -> Json<Balance> {
    let l = app.ledger.read().await;
    let bal = l.get_balance(&rid).unwrap_or(0);
    let n   = l.get_nonce(&rid).unwrap_or(0);
    // Balance.balance в модуле api — u64
    Json(Balance { rid, balance: bal as u64, nonce: n })
}

/// GET /economy
pub async fn economy(State(app): State<Arc<AppState>>) -> Json<Economy> {
    // Ledger::supply() -> (minted, burned)
    let (minted, burned) = app.ledger.read().await.supply().unwrap_or((0, 0));
    let net_supply = minted.saturating_sub(burned);

    // В текущей структуре Economy требуются поля: net_supply, minted, burned
    Json(Economy {
        net_supply,
        minted: Some(minted),
        burned: Some(burned),
    })
}

/// GET /history/:rid
pub async fn history(
    Path(rid): Path<String>,
    State(app): State<Arc<AppState>>,
) -> Json<Vec<HistoryItem>> {
    let l = app.ledger.read().await;
    let rows = l.account_txs_page(&rid, 0, 100).unwrap_or_default();

    Json(rows.into_iter().map(|r| HistoryItem {
        txid:   r.txid,
        height: r.height,
        from:   r.from,
        to:     r.to,
        amount: r.amount,
        nonce:  r.nonce,
        // В HistoryItem у тебя требуется ts. Если r.ts — u64, заворачиваем в Some(..).
        // Если вдруг r.ts уже Option<u64>, заменишь на: ts: r.ts
        ts:     Some(r.ts),
    }).collect())
}

```

## FILE: /root/logos_lrb/node/src/api/base.rs.bak.20250922T084527Z  (size=1444b)
```text
use axum::{extract::{Path, State}, Json};
use std::sync::Arc;
use crate::state::AppState;
use super::{OkMsg, Head, Balance, Economy, HistoryItem};

pub async fn healthz() -> Json<OkMsg> { Json(OkMsg{ status:"ok" }) }

pub async fn head(State(app): State<Arc<AppState>>) -> Json<Head> {
    let l = app.ledger.read().await;
    let h = l.height().unwrap_or(0);
    let fin = h.saturating_sub(1);
    Json(Head{ height:h, finalized: fin })
}

pub async fn balance(Path(rid):Path<String>, State(app): State<Arc<AppState>>) -> Json<Balance> {
    let l = app.ledger.read().await;
    let bal = l.get_balance(&rid).unwrap_or(0);
    let n   = l.get_nonce(&rid).unwrap_or(0);
    Json(Balance{ rid, balance: bal as u128, nonce: n })
}

pub async fn economy(State(app): State<Arc<AppState>>) -> Json<Economy> {
    const CAP_MICRO: u64 = 81_000_000_u64 * 1_000_000_u64;
    let (minted, burned) = app.ledger.read().await.supply().unwrap_or((0,0));
    let supply = minted.saturating_sub(burned);
    Json(Economy{ supply, burned, cap: CAP_MICRO })
}

pub async fn history(Path(rid):Path<String>, State(app): State<Arc<AppState>>) -> Json<Vec<HistoryItem>> {
    let l = app.ledger.read().await;
    let rows = l.account_txs_page(&rid, 0, 100).unwrap_or_default();
    Json(rows.into_iter().map(|r| HistoryItem{
        txid:r.txid, height:r.height, from:r.from, to:r.to, amount:r.amount, nonce:r.nonce, ts:Some((r.ts/1000) as u64)
    }).collect())
}

```

## FILE: /root/logos_lrb/node/src/api/base.rs.bak.20250922T085303Z  (size=1444b)
```text
use axum::{extract::{Path, State}, Json};
use std::sync::Arc;
use crate::state::AppState;
use super::{OkMsg, Head, Balance, Economy, HistoryItem};

pub async fn healthz() -> Json<OkMsg> { Json(OkMsg{ status:"ok" }) }

pub async fn head(State(app): State<Arc<AppState>>) -> Json<Head> {
    let l = app.ledger.read().await;
    let h = l.height().unwrap_or(0);
    let fin = h.saturating_sub(1);
    Json(Head{ height:h, finalized: fin })
}

pub async fn balance(Path(rid):Path<String>, State(app): State<Arc<AppState>>) -> Json<Balance> {
    let l = app.ledger.read().await;
    let bal = l.get_balance(&rid).unwrap_or(0);
    let n   = l.get_nonce(&rid).unwrap_or(0);
    Json(Balance{ rid, balance: bal as u128, nonce: n })
}

pub async fn economy(State(app): State<Arc<AppState>>) -> Json<Economy> {
    const CAP_MICRO: u64 = 81_000_000_u64 * 1_000_000_u64;
    let (minted, burned) = app.ledger.read().await.supply().unwrap_or((0,0));
    let supply = minted.saturating_sub(burned);
    Json(Economy{ supply, burned, cap: CAP_MICRO })
}

pub async fn history(Path(rid):Path<String>, State(app): State<Arc<AppState>>) -> Json<Vec<HistoryItem>> {
    let l = app.ledger.read().await;
    let rows = l.account_txs_page(&rid, 0, 100).unwrap_or_default();
    Json(rows.into_iter().map(|r| HistoryItem{
        txid:r.txid, height:r.height, from:r.from, to:r.to, amount:r.amount, nonce:r.nonce, ts:Some((r.ts/1000) as u64)
    }).collect())
}

```

## FILE: /root/logos_lrb/node/src/api/base.rs.bak.20250922T093326Z  (size=2183b)
```text
use axum::{extract::{Path, State}, Json};
use std::sync::Arc;

use crate::state::AppState;
use super::{OkMsg, Head, Balance, Economy, HistoryItem};

/// GET /healthz
pub async fn healthz() -> Json<OkMsg> {
    Json(OkMsg { status: "ok" })
}

/// GET /head
pub async fn head(State(app): State<Arc<AppState>>) -> Json<Head> {
    let l = app.ledger.read().await;
    let h = l.height().unwrap_or(0);
    // Если в Ledger нет отдельного finalized, оставляем как было: height-1.
    let fin = h.saturating_sub(1);
    Json(Head { height: h, finalized: fin })
}

/// GET /balance/:rid
pub async fn balance(
    Path(rid): Path<String>,
    State(app): State<Arc<AppState>>,
) -> Json<Balance> {
    let l = app.ledger.read().await;
    let bal = l.get_balance(&rid).unwrap_or(0);
    let n   = l.get_nonce(&rid).unwrap_or(0);
    // В новой структуре Balance.balance = u64
    Json(Balance { rid, balance: bal as u64, nonce: n })
}

/// GET /economy
pub async fn economy(State(app): State<Arc<AppState>>) -> Json<Economy> {
    // Ledger::supply() возвращает (minted, burned). Считаем net_supply = minted - burned.
    let (minted, burned) = app.ledger.read().await.supply().unwrap_or((0, 0));
    let net_supply = minted.saturating_sub(burned);
    // В новой структуре нет cap/burned; есть net_supply и minted (minted делаем Some(..)).
    Json(Economy { net_supply, minted: Some(minted) })
}

/// GET /history/:rid
pub async fn history(
    Path(rid): Path<String>,
    State(app): State<Arc<AppState>>,
) -> Json<Vec<HistoryItem>> {
    let l = app.ledger.read().await;
    // первая страница, до 100 записей
    let rows = l.account_txs_page(&rid, 0, 100).unwrap_or_default();

    Json(rows.into_iter().map(|r| HistoryItem {
        txid:   r.txid,
        height: r.height,
        from:   r.from,
        to:     r.to,
        amount: r.amount,
        nonce:  r.nonce,
        // если в твоём HistoryItem есть ещё поля (например ts: Option<u64>),
        // их можно добавить здесь: ts: r.ts
    }).collect())
}

```

## FILE: /root/logos_lrb/node/src/api/mod.rs  (size=4700b)
```rust
//! API root: типы, каноника/верификация, ре‑экспорт HTTP‑хендлеров.

use serde::{Deserialize, Serialize};

//// ---- Типы, которые ждёт base.rs ----

#[derive(Serialize)]
pub struct OkMsg {
    pub status: &'static str,
}

#[derive(Serialize)]
pub struct Head {
    pub height: u64,
    pub finalized: u64,
}

#[derive(Serialize)]
pub struct Balance {
    pub rid: String,
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Serialize)]
pub struct Economy {
    pub net_supply: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minted: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub burned: Option<u64>,
}

#[derive(Serialize, Clone)]
pub struct HistoryItem {
    pub txid: String,
    pub height: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    // unix‑время в секундах, если есть
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ts: Option<u64>,
}

//// ---- Типы для submit ----

#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    /// подпись ed25519 в hex (64 байта)
    pub sig_hex: String,
    /// опциональное memo — уходит в ledger::submit_tx_simple как Option<String>
    #[serde(default)]
    pub memo: Option<String>,
}

#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>, // важно: usize — ровно как из enumerate()
}

//// ---- Канонические байты для подписи ----
/// Формат: `from|to|amount|nonce` без перевода строки.
/// ВНИМАНИЕ: должен 1:1 совпадать с тем, что проверяет verify_sig/submit.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

//// ---- Проверка подписи ed25519 ----
/// `from` — base58 адрес (32‑байтный pk), `sig_hex` — 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use bs58;
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // RID (base58) -> 32 байта pk
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);

    // Sig hex -> 64 байта
    let sig_vec = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_vec.len() != 64 {
        return Err(format!("sig_len={}", sig_vec.len()));
    }
    let sig = Signature::from_bytes(&sig_vec.try_into().unwrap());

    // Для отладки по переменной окружения печатаем канонику/подпись/ключ
    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target: "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    // Проверка
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|_| "vk_from_bytes".to_string())?;
    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

//// ---- Сабмодули и ре‑экспорт для main.rs ----
pub mod base;     // /healthz /head /balance /economy /history
pub mod archive;  // архивные ручки
pub mod staking;  // стейкинг
pub mod tx;       // /submit_tx /submit_tx_batch (и др. если добавлены)

/// Публичный ре‑экспорт (удобно для main.rs)
pub use base::{healthz, head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};
pub use tx::{submit_tx, submit_tx_batch};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250922T075006Z  (size=4025b)
```text
/// API root: общие типы/утилы + экспорт подмодулей
use serde::{Deserialize, Serialize};

pub mod base;
pub mod tx;
pub mod archive;
pub mod staking;

//
// ---------- Общие модели ----------
#[derive(Serialize)]
pub struct OkMsg { pub status: &'static str }

#[derive(Serialize)]
pub struct Head { pub height: u64, pub finalized: u64 }

#[derive(Serialize)]
pub struct Balance { pub rid: String, pub balance: u128, pub nonce: u64 }

#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from:   String,
    pub to:     String,
    pub amount: u64,
    pub nonce:  u64,
    #[serde(default)] pub memo: Option<String>,
    // подпись обязателЬна для /submit_tx
    pub sig_hex: String,
}

#[derive(Deserialize)]
pub struct SubmitBatchReq { pub txs: Vec<TxIn> }

#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if="Option::is_none")]
    pub txid: Option<String>,
    // в коде прокидываются String — делаем совместимым
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<String>,
}

#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if="Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<String>,
    // код ждёт Option<usize>
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<usize>,
}

#[derive(Serialize)]
pub struct Economy { pub supply:u64, pub burned:u64, pub cap:u64 }

#[derive(Serialize)]
pub struct HistoryItem {
    pub txid:  String,
    pub height:u64,
    pub from:  String,
    pub to:    String,
    pub amount:u64,
    pub nonce: u64,                  // требуется base.rs/archive.rs
    #[serde(skip_serializing_if="Option::is_none")]
    pub ts:    Option<u64>,
}

//
// ---------- Канон подписи и проверка ----------
use sha2::{Sha256, Digest};
use bs58;
use ed25519_dalek::{Verifier, Signature, VerifyingKey, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH};

/// КАНОН: SHA-256( from "|" to "|" amount_be "|" nonce_be ) → 32 байта.
/// ЭТИ БАЙТЫ и нужно подписывать Ed25519.
pub fn canonical_msg(from:&str, to:&str, amount:u64, nonce:u64) -> Vec<u8> {
    let mut h = Sha256::new();
    h.update(from.as_bytes());        h.update(b"|");
    h.update(to.as_bytes());          h.update(b"|");
    h.update(amount.to_be_bytes());   h.update(b"|");
    h.update(nonce.to_be_bytes());
    h.finalize().to_vec()
}

/// Проверка подписи (используется на сервере).
pub fn verify_sig(from:&str, msg:&[u8], sig_hex:&str) -> Result<(), String> {
    // RID -> pubkey(32)
    let pk_bytes = bs58::decode(from).into_vec()
        .map_err(|e| format!("bad_from_rid_base58: {}", e))?;
    if pk_bytes.len() != PUBLIC_KEY_LENGTH {
        return Err(format!("bad_pubkey_len: got {} want {}", pk_bytes.len(), PUBLIC_KEY_LENGTH));
    }
    let mut pk_arr = [0u8; PUBLIC_KEY_LENGTH];
    pk_arr.copy_from_slice(&pk_bytes);
    let vk = VerifyingKey::from_bytes(&pk_arr)
        .map_err(|e| format!("bad_pubkey: {}", e))?;

    // sig_hex -> Signature(64)
    let sig_bytes = hex::decode(sig_hex).map_err(|e| format!("bad_sig_hex: {}", e))?;
    if sig_bytes.len() != SIGNATURE_LENGTH {
        return Err(format!("bad_sig_len: got {} want {}", sig_bytes.len(), SIGNATURE_LENGTH));
    }
    let mut sig_arr = [0u8; SIGNATURE_LENGTH];
    sig_arr.copy_from_slice(&sig_bytes);
    let sig = Signature::from_bytes(&sig_arr);

    vk.verify(msg, &sig).map_err(|_| "bad_signature".to_string())
}

//
// ---------- Реэкспорт хэндлеров ----------
pub use base::{healthz, head, balance, economy, history};
pub use tx::{submit_tx, submit_tx_batch};
pub use archive::{archive_history, archive_tx, archive_blocks, archive_txs};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250922T080344Z  (size=3094b)
```text
//! API base: общие типы, каноника сообщения и верификация подписи.

use serde::{Deserialize, Serialize};

// ---------- ВХОД/ВЫХОД ТИПЫ ----------

#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,                 // под это поле подписываем и проверяем
    #[serde(default)]
    pub memo: Option<String>,            // на будущее (может быть None)
}

#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>,
}

// ---------- КАНОНИКА И ПОДПИСЬ ----------

/// ЕДИНАЯ каноника сообщения для подписи/проверки.
/// ВАЖНО: trim() убирает случайные пробелы у адресов.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// Проверка подписи (ed25519).
/// from -> bs58(pubkey32), sig_hex -> 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // 1) pubkey из RID (bs58)
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // 2) подпись из hex
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    // 3) (опц.) дамп каноники в логи
    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target: "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    // 4) verify
    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

// ---------- re-export хендлеров ----------
mod tx;
pub use tx::*;

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250922T081341Z  (size=3907b)
```text
//! API root: общие типы, ЕДИНАЯ каноника, проверка подписи
//! и ре‑экспорт всех HTTP‑хендлеров, чтобы main.rs работал как раньше.

use serde::{Deserialize, Serialize};

/// Вход транзакции
#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,          // подпись в hex (64 байта)
    #[serde(default)]
    pub memo: Option<String>,     // опционально
}

/// Результат одиночного submit
#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

/// Запрос батча
#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

/// Результат по одному элементу батча
#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>,
}

/// ЕДИНАЯ каноника сообщения для подписи/проверки.
/// Любые пробелы у адресов/строк убираем.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// Проверка подписи (ed25519). `from` — bs58(pubkey32), `sig_hex` — 64‑байтная подпись в hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // pubkey из RID (bs58)
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // подпись из hex
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    // (опционально) дамп каноники/подписи/паблика
    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target: "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

// ---------- сабмодули с HTTP‑хендлерами ----------
// Названия файлов должны соответствовать реальным .rs в каталоге api/.
// Если у тебя вместо chain.rs/health.rs другие имена — поправь mod/use ниже.

pub mod tx;
pub mod health;
pub mod chain;
pub mod archive;
pub mod stake;

// ---------- ре‑экспорт функций, чтобы main.rs мог звать api::foo ----------
pub use tx::{submit_tx, submit_tx_batch};
pub use health::healthz;
pub use chain::{head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use stake::{stake_delegate, stake_undelegate, stake_claim, stake_my};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250922T082714Z  (size=3561b)
```text
//! API root: типы, единая каноника/верификация и ре‑экспорт HTTP‑хендлеров.

use serde::{Deserialize, Serialize};

/// Вход транзакции
#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,          // подпись в hex (64 байта)
    #[serde(default)]
    pub memo: Option<String>,     // опционально
}

/// Результат одиночного submit
#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

/// Запрос батча
#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

/// Результат по элементу батча
#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>,
}

/// Канонические байты для подписи/проверки.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// Проверка ed25519: `from` — bs58(pubkey32), `sig_hex` — 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // bs58 -> 32 байта паблика
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // подпись hex -> 64 байта
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    // Диагностика каноники/подписи/паблика (включается LOGOS_CANON_DUMP=1)
    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target: "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg), sig_hex.trim(), hex::encode(pk32),
        );
    }

    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

// ---- сабмодули (ИМЕНА СООТВЕТСТВУЮТ ТВОИМ ФАЙЛАМ) ----
pub mod base;     // health/head/balance/economy/history
pub mod archive;  // архивные ручки
pub mod staking;  // stake ручки
pub mod tx;       // submit_tx(/_batch)

// ---- ре‑экспорт, чтобы main.rs мог вызывать api::... ----
pub use tx::{submit_tx, submit_tx_batch};
pub use base::{healthz, head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250922T083621Z  (size=4037b)
```text
//! API root: типы, каноника/верификация, ре‑экспорт HTTP‑хендлеров.

use serde::{Deserialize, Serialize};

/// Вход транзакции (submit_tx/submit_tx_batch)
#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    /// Подпись в hex (64 байта). Для отладки можно передать "00" — сервер
    /// вернёт `bad_signature`, но выведет canon.msg_hex в журнал при LOGOS_CANON_DUMP=1.
    #[serde(default)]
    pub sig_hex: String,
    /// Необязательное поле, прокидывается в ledger::submit_tx_simple как Option<String>.
    #[serde(default)]
    pub memo: Option<String>,
}

/// Результат одиночного сабмита
#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

/// Запрос батча
#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

/// Результат по элементу батча
#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>, // важно: usize (совпадает с i из enumerate())
}

/// Канонические байты для подписи (ровно эти байты должны подписываться).
/// Формат: "from|to|amount|nonce" без перевода строки.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// Проверка ed25519.
/// `from` — bs58(pk32), `sig_hex` — 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // RID (bs58) -> 32 байта паблика
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // Подпись из hex -> 64 байта
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    // Диагностика (включается LOGOS_CANON_DUMP=1)
    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target = "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

// ---- сабмодули (имена соответствуют твоим файлам) ----
pub mod base;     // healthz/head/balance/economy/history
pub mod archive;  // архивные ручки
pub mod staking;  // стейкинг
pub mod tx;       // submit_tx и submit_tx_batch

// ---- публичный ре-экспорт для main.rs ----
pub use tx::{submit_tx, submit_tx_batch};
pub use base::{healthz, head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250924T084318Z  (size=4373b)
```text
//! API root: типы, каноника/верификация, ре‑экспорт HTTP‑хендлеров.

use serde::{Deserialize, Serialize};

/// ---- Типы, которые ждёт base.rs ----

#[derive(Serialize)]
pub struct OkMsg {
    pub status: &'static str,
}

#[derive(Serialize)]
pub struct Head {
    pub height: u64,
    pub finalized: u64,
}

#[derive(Serialize)]
pub struct Balance {
    pub rid: String,
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Serialize)]
pub struct Economy {
    pub net_supply: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minted: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub burned: Option<u64>,
}

#[derive(Serialize, Clone)]
pub struct HistoryItem {
    pub txid: String,
    pub height: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ts: Option<u64>, // сек, если есть
}

/// ---- Типы для submit ----

#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    /// подпись 64 байта hex
    #[serde(default)]
    pub sig_hex: String,
    /// опциональное memo — уходит в ledger::submit_tx_simple как Option<String>
    #[serde(default)]
    pub memo: Option<String>,
}

#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>, // важно: usize, ровно как i из enumerate()
}

/// ---- Канонические байты для подписи ----
/// Формат: `from|to|amount|nonce` без перевода строки.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// ---- Проверка подписи ed25519 ----
/// `from` — bs58 адрес (32‑байтный pk), `sig_hex` — 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // RID (base58) -> 32 байта pk
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // Sig hex -> 64 байта
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target = "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

/// ---- Сабмодули с реализацией ручек ----
pub mod base;     // healthz/head/balance/economy/history
pub mod archive;  // архивные ручки
pub mod staking;  // стейкинг
pub mod tx;       // submit_tx / submit_tx_batch

/// ---- Публичный ре‑экспорт для main.rs ----
pub use base::{healthz, head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};
pub use tx::{submit_tx, submit_tx_batch};

```

## FILE: /root/logos_lrb/node/src/api/mod.rs.bak.20250924T085240Z  (size=4373b)
```text
//! API root: типы, каноника/верификация, ре‑экспорт HTTP‑хендлеров.

use serde::{Deserialize, Serialize};

/// ---- Типы, которые ждёт base.rs ----

#[derive(Serialize)]
pub struct OkMsg {
    pub status: &'static str,
}

#[derive(Serialize)]
pub struct Head {
    pub height: u64,
    pub finalized: u64,
}

#[derive(Serialize)]
pub struct Balance {
    pub rid: String,
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Serialize)]
pub struct Economy {
    pub net_supply: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minted: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub burned: Option<u64>,
}

#[derive(Serialize, Clone)]
pub struct HistoryItem {
    pub txid: String,
    pub height: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ts: Option<u64>, // сек, если есть
}

/// ---- Типы для submit ----

#[derive(Deserialize, Clone)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    /// подпись 64 байта hex
    #[serde(default)]
    pub sig_hex: String,
    /// опциональное memo — уходит в ledger::submit_tx_simple как Option<String>
    #[serde(default)]
    pub memo: Option<String>,
}

#[derive(Serialize)]
pub struct SubmitResult {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
}

#[derive(Deserialize)]
pub struct SubmitBatchReq {
    pub txs: Vec<TxIn>,
}

#[derive(Serialize)]
pub struct SubmitBatchItem {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>, // важно: usize, ровно как i из enumerate()
}

/// ---- Канонические байты для подписи ----
/// Формат: `from|to|amount|nonce` без перевода строки.
pub fn canonical_msg(from: &str, to: &str, amount: u64, nonce: u64) -> Vec<u8> {
    format!("{}|{}|{}|{}", from.trim(), to.trim(), amount, nonce).into_bytes()
}

/// ---- Проверка подписи ed25519 ----
/// `from` — bs58 адрес (32‑байтный pk), `sig_hex` — 64 байта hex.
pub fn verify_sig(from: &str, msg: &[u8], sig_hex: &str) -> Result<(), String> {
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    // RID (base58) -> 32 байта pk
    let pk_vec = bs58::decode(from.trim())
        .into_vec()
        .map_err(|e| format!("rid_base58:{e}"))?;
    if pk_vec.len() != 32 {
        return Err(format!("rid_len={}", pk_vec.len()));
    }
    let mut pk32 = [0u8; 32];
    pk32.copy_from_slice(&pk_vec[..32]);
    let vk = VerifyingKey::from_bytes(&pk32).map_err(|e| format!("vk:{e}"))?;

    // Sig hex -> 64 байта
    let sig_raw = hex::decode(sig_hex.trim()).map_err(|e| format!("sig_hex:{e}"))?;
    if sig_raw.len() != 64 {
        return Err(format!("sig_len={}", sig_raw.len()));
    }
    let mut sig64 = [0u8; 64];
    sig64.copy_from_slice(&sig_raw[..64]);
    let sig = Signature::from_bytes(&sig64);

    if std::env::var_os("LOGOS_CANON_DUMP").is_some() {
        tracing::info!(
            target = "verify",
            "canon.msg_hex={} sig_hex={} from_pk_hex={}",
            hex::encode(msg),
            sig_hex.trim(),
            hex::encode(pk32),
        );
    }

    vk.verify(msg, &sig).map_err(|_| "verify_failed".to_string())
}

/// ---- Сабмодули с реализацией ручек ----
pub mod base;     // healthz/head/balance/economy/history
pub mod archive;  // архивные ручки
pub mod staking;  // стейкинг
pub mod tx;       // submit_tx / submit_tx_batch

/// ---- Публичный ре‑экспорт для main.rs ----
pub use base::{healthz, head, balance, economy, history};
pub use archive::{archive_blocks, archive_txs, archive_history, archive_tx};
pub use staking::{stake_delegate, stake_undelegate, stake_claim, stake_my};
pub use tx::{submit_tx, submit_tx_batch};

```

## FILE: /root/logos_lrb/node/src/api.rs:10:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/api.rs:108:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/api.rs:59:39  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/api/staking.rs  (size=2705b)
```rust
use axum::{extract::{Path}, http::StatusCode, Json};
use serde::{Deserialize, Serialize};
use reqwest::Client;

#[derive(Deserialize, Serialize)]
pub struct StakeAction {
    pub rid: String,
    #[serde(default)] pub validator: String,
    #[serde(default)] pub amount: Option<u64>,
}

pub async fn stake_delegate(Json(body):Json<StakeAction>) -> (StatusCode, String) {
    let cli = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/stake/submit")
        .json(&serde_json::json!({"action":"delegate","rid":body.rid,"validator":body.validator,"amount":body.amount}))
        .send().await;
    match resp {
        Ok(r) => (StatusCode::from_u16(r.status().as_u16()).unwrap_or(StatusCode::OK), r.text().await.unwrap_or_default()),
        Err(e)=> (StatusCode::BAD_GATEWAY, format!("proxy_error: {e}")),
    }
}

pub async fn stake_undelegate(Json(body):Json<StakeAction>) -> (StatusCode, String) {
    let cli = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/stake/submit")
        .json(&serde_json::json!({"action":"undelegate","rid":body.rid,"validator":body.validator,"amount":body.amount}))
        .send().await;
    match resp {
        Ok(r) => (StatusCode::from_u16(r.status().as_u16()).unwrap_or(StatusCode::OK), r.text().await.unwrap_or_default()),
        Err(e)=> (StatusCode::BAD_GATEWAY, format!("proxy_error: {e}")),
    }
}

pub async fn stake_claim(Json(body):Json<StakeAction>) -> (StatusCode, String) {
    let cli = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/stake/submit")
        .json(&serde_json::json!({"action":"claim","rid":body.rid}))
        .send().await;
    match resp {
        Ok(r) => (StatusCode::from_u16(r.status().as_u16()).unwrap_or(StatusCode::OK), r.text().await.unwrap_or_default()),
        Err(e)=> (StatusCode::BAD_GATEWAY, format!("proxy_error: {e}")),
    }
}

pub async fn stake_my(Path(rid):Path<String>) -> (StatusCode, String) {
    let cli = Client::new();

    let dtext = match cli.get(format!("http://127.0.0.1:8080/stake/delegations/{rid}")).send().await {
        Ok(resp) => resp.text().await.unwrap_or_else(|_| "[]".to_string()),
        Err(_)   => "[]".to_string(),
    };

    let rtext = match cli.get(format!("http://127.0.0.1:8080/stake/rewards/{rid}")).send().await {
        Ok(resp) => resp.text().await.unwrap_or_else(|_| "[]".to_string()),
        Err(_)   => "[]".to_string(),
    };

    let body = serde_json::json!({
        "delegations": serde_json::from_str::<serde_json::Value>(&dtext).unwrap_or(serde_json::json!([])),
        "rewards":     serde_json::from_str::<serde_json::Value>(&rtext).unwrap_or(serde_json::json!([]))
    });
    (StatusCode::OK, body.to_string())
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs  (size=7276b)
```rust
//! tx.rs — обработка транзакций (single + batch) с понятными причинами отказа.
//! Всегда возвращаем конкретный reason и ожидаемый nonce в info: "bad_nonce: expected N"
//! Логи: печатаем last_nonce, next_nonce и tx_nonce до коммита.

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, error};

use crate::{metrics, state::AppState};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig, canonical_msg};

fn classify_ledger_err<E: std::fmt::Display>(e: &E) -> &'static str {
    let s = format!("{e}").to_lowercase();
    if s.contains("nonce_gap") || s.contains("nonce gap") || (s.contains("expected") && s.contains("nonce")) {
        "nonce_gap"
    } else if s.contains("bad nonce") || s.contains("bad_nonce") {
        "bad_nonce"
    } else if s.contains("insufficient") || s.contains("funds") || s.contains("balance") {
        "insufficient_funds"
    } else if s.contains("duplicate") || s.contains("dup") {
        "duplicate"
    } else if s.contains("signature") {
        "bad_signature"
    } else {
        "internal"
    }
}

/// Формируем подсказку по expected nonce на основе last_nonce из ledger.
fn info_with_expected(reason: &str, last_nonce: u64) -> String {
    // Две модели в природе:
    //  (A) expected == last_nonce
    //  (B) expected == last_nonce + 1
    // Если "gap" — почти всегда клиент прислал больше ожидаемого -> expected = last
    // Если "bad_nonce" (меньше ожидаемого) — most likely expected = last + 1
    match reason {
        "nonce_gap" => format!("nonce_gap: expected {}", last_nonce),
        "bad_nonce" => format!("bad_nonce: expected {}", last_nonce.saturating_add(1)),
        other => other.to_string(),
    }
}

pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноника и лог (по желанию)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(target: "verify", "canon.msg_hex={}", hex::encode(&msg));
    }

    // 2) Сигнатура (падает раньше nonce — так безопаснее)
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (StatusCode::UNAUTHORIZED, Json(SubmitResult{
            ok:false, txid:None, info:Some("bad_signature".into())
        }));
    }

    // 3) Снимем last/next из ledger и залогируем перед коммитом
    let (last_nonce, balance) = {
        let l = app.ledger.read().await;
        let last = l.get_nonce(&tx.from).unwrap_or(0);
        let bal  = l.get_balance(&tx.from).unwrap_or(0);
        (last, bal)
    };
    let next_nonce = last_nonce.saturating_add(1);
    debug!(
        target: "verify",
        "pre-commit: from={} balance={} last_nonce={} next_nonce={} tx_nonce={}",
        tx.from, balance, last_nonce, next_nonce, tx.nonce
    );

    // 4) Пытаемся закоммитить (истина — в ledger)
    match app.ledger
        .write().await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
    {
        Ok(stx) => {
            metrics::inc_tx_accepted();
            if let Some(arch) = &app.archive {
                if let Err(e) = arch.record_tx(
                    &stx.txid, stx.height, &stx.from, &stx.to,
                    stx.amount as u64, stx.nonce as u64, Some((stx.ts/1000) as u64)
                ).await {
                    error!("archive: write failed: {e}");
                }
            }
            (StatusCode::OK, Json(SubmitResult{
                ok:true, txid:Some(stx.txid.clone()), info:Some("accepted".into())
            }))
        }
        Err(e) => {
            let reason = classify_ledger_err(&e);
            // формируем понятное info с цифрой expected
            let info = info_with_expected(reason, last_nonce);
            if reason == "internal" {
                error!("ledger submit error: {e} (reason={reason})");
            } else {
                debug!("ledger submit error: {e} (reason={info})");
            }
            metrics::inc_tx_rejected(reason);
            (StatusCode::OK, Json(SubmitResult{
                ok:false, txid:None, info:Some(info)
            }))
        }
    }
}

pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(target: "verify", "batch[{i}]: canon.msg_hex={}", hex::encode(&msg));
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem{ ok:false, txid:None, info:Some("bad_signature".into()), index:Some(i) });
            continue;
        }

        let (last_nonce, _bal) = {
            let l = app.ledger.read().await;
            (l.get_nonce(&tx.from).unwrap_or(0), l.get_balance(&tx.from).unwrap_or(0))
        };
        let next_nonce = last_nonce.saturating_add(1);
        debug!(
            target: "verify",
            "batch pre-commit[{i}]: from={} last_nonce={} next_nonce={} tx_nonce={}",
            tx.from, last_nonce, next_nonce, tx.nonce
        );

        match app.ledger
            .write().await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem{
                    ok:true, txid:Some(stx.txid.clone()), info:Some("accepted".into()), index:Some(i)
                });
                if let Some(arch) = &app.archive {
                    if let Err(e) = arch.record_tx(
                        &stx.txid, stx.height, &stx.from, &stx.to,
                        stx.amount as u64, stx.nonce as u64, Some((stx.ts/1000) as u64)
                    ).await {
                        error!("archive: batch write failed (idx={i}): {e}");
                    }
                }
            }
            Err(e) => {
                let reason = classify_ledger_err(&e);
                let info = info_with_expected(reason, last_nonce);
                if reason == "internal" {
                    error!("ledger submit error (batch idx={i}): {e} (reason={reason})");
                } else {
                    debug!("ledger submit error (batch idx={i}): {e} (reason={info})");
                }
                metrics::inc_tx_rejected(reason);
                out.push(SubmitBatchItem{ ok:false, txid:None, info:Some(info), index:Some(i) });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250922T072341Z  (size=4032b)
```text
use crate::api::canonical_msg;
use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{info,warn,error};
use crate::{state::AppState, metrics};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};

pub async fn submit_tx(State(app): State<Arc<AppState>>, Json(tx):Json<TxIn>)
    -> (StatusCode, Json<SubmitResult>)
{
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
    if let Err(e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (StatusCode::UNAUTHORIZED, Json(SubmitResult{ ok:false, txid:None, info:Some(e.to_string()) }));
    }
    let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce <= prev {
        metrics::inc_tx_rejected("nonce_reuse");
        return (StatusCode::CONFLICT, Json(SubmitResult{ ok:false, txid:None, info:Some("nonce_reuse".to_string()).into() }));
    }
    let stx = match app.ledger.write().await.submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone()){
        Ok(s)=>s, Err(e)=>{
            metrics::inc_tx_rejected("internal");
            return (StatusCode::OK, Json(SubmitResult{ ok:false, txid:None, info:Some(e.to_string()) }))
        },
    };
    if let Some(arch)=&app.archive {
        match arch.record_tx(&stx.txid, stx.height, &stx.from, &stx.to, stx.amount, stx.nonce, Some((stx.ts/1000) as u64)).await {
            Ok(()) => info!("archive: wrote tx {}", stx.txid),
            Err(e) => error!("archive: write failed: {}", e),
        }
    } else { warn!("archive: not configured"); }

    metrics::inc_tx_accepted();
    (StatusCode::OK, Json(SubmitResult{ ok:true, txid:Some(stx.txid), info:Some("accepted".to_string()) }))
}

pub async fn submit_tx_batch(State(app): State<Arc<AppState>>, Json(req):Json<SubmitBatchReq>)
    -> (StatusCode, Json<Vec<SubmitBatchItem>>)
{
    let mut out = Vec::with_capacity(req.txs.len());

    // commit по правилам
    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
        if let Err(e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem{ ok:false, txid:None, info:Some(e), index:Some(i) });
            continue;
        }
        let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce <= prev {
            metrics::inc_tx_rejected("nonce_reuse");
            out.push(SubmitBatchItem{ ok:false, txid:None, info:Some("nonce_reuse".to_string()), index:Some(i) });
            continue;
        }
        match app.ledger.write().await.submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone()) {
            Ok(s) => { metrics::inc_tx_accepted(); out.push(SubmitBatchItem{ ok:true, txid:Some(s.txid), info:Some("accepted".to_string()), index:Some(i) }); }
            Err(e)=> { metrics::inc_tx_rejected("internal"); out.push(SubmitBatchItem{ ok:false, txid:None, info:Some(e.to_string()), index:Some(i) }); }
        }
    }

    // batch ingest (OWNED кортежи → нет lifetime-ловушек)
    if let Some(arch)=&app.archive {
        let mut rows: Vec<(String,u64,String,String,u64,u64,Option<u64>)> = Vec::new();
        for item in &out {
            if !item.ok { continue; }
            if let Some(ref txid) = item.txid {
                if let Ok(Some(stx)) = app.ledger.read().await.get_tx(txid) {
                    rows.push((
                        txid.clone(),
                        stx.height,
                        stx.from.clone(),
                        stx.to.clone(),
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts/1000) as u64),
                    ));
                }
            }
        }
        if !rows.is_empty() { let _ = arch.record_txs_batch(&rows[..]).await; }
    }

    (StatusCode::OK, Json(out))
}


```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250922T073044Z  (size=7547b)
```text
//! tx.rs — приём и валидация транзакций (single + batch)
//! Axum 0.7 совместимо. Канонизация сообщения берётся из crate::api::canonical_msg.
//! Для отладки можно включить LOGOS_CANON_DUMP=1 — сервер напечатает canon.msg_hex.

use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};
use crate::api::canonical_msg;
use crate::{state::AppState, metrics};

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, info, warn, error};

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноническое сообщение (ровно эти байты будут проверяться на подписи)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    // По желанию — печатаем канонику (смотри LOGOS_CANON_DUMP=1)
    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "canon.from_rid={} canon.to_rid={} canon.amount={} canon.nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
            }),
        );
    }

    // 3) Защита от повторного nonce
    let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce <= prev {
        metrics::inc_tx_rejected("nonce_reuse");
        return (
            StatusCode::CONFLICT,
            Json(SubmitResult {
                ok: false,
                txid: None,
                info: Some("nonce_reuse".into()),
            }),
        );
    }

    // 4) Коммит в ledger
    let stx = match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce)
    {
        Ok(s) => s,
        Err(e) => {
            error!("ledger submit error: {e}");
            metrics::inc_tx_rejected("internal");
            return (
                StatusCode::OK,
                Json(SubmitResult {
                    ok: false,
                    txid: None,
                    info: Some("internal".into()),
                }),
            );
        }
    };

    metrics::inc_tx_accepted();

    // 5) Архивируем (если подключен архив)
    //    Используем batch-интерфейс (универсальная сигнатура).
    if let Some(arch) = &app.archive {
        if let Ok(Some(saved)) = app.ledger.read().await.get_tx(&stx.txid) {
            let rows = vec![(
                saved.txid.clone(),
                saved.height,
                saved.from.clone(),
                saved.to.clone(),
                saved.amount as u64,
                saved.nonce as u64,
                Some((saved.ts / 1000) as u64),
            )];
            if let Err(e) = arch.record_txs_batch(&rows).await {
                // не фейлим при сбое архива — это побочный сервис
                error!("archive: batch write failed: {e}");
            } else {
                info!("archive: wrote tx {}", saved.txid);
            }
        } else {
            warn!("archive: get_tx after commit returned none");
        }
    } else {
        // это нормальный режим, если архив не задействован
        debug!("archive: not configured");
    }

    (
        StatusCode::OK,
        Json(SubmitResult {
            ok: true,
            txid: Some(stx.txid),
            info: Some("accepted".into()),
        }),
    )
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    // Коммитим по правилам
    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{}] canon.from_rid={} canon.to_rid={} canon.amount={} canon.nonce={} canon.msg_hex={}",
                i, tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
                index: Some(i as u32),
            });
            continue;
        }

        let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce <= prev {
            metrics::inc_tx_rejected("nonce_reuse");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("nonce_reuse".into()),
                index: Some(i as u32),
            });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce)
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i as u32),
                });
            }
            Err(e) => {
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected("internal");
                out.push(SubmitBatchItem {
                    ok: false,
                    txid: None,
                    info: Some("internal".into()),
                    index: Some(i as u32),
                });
            }
        }
    }

    // Batch ingest в архив (OWNED кортежи — без lifetime-ловушек)
    if let Some(arch) = &app.archive {
        let mut rows: Vec<(String, u64, String, String, u64, u64, Option<u64>)> = Vec::new();
        for item in &out {
            if !item.ok {
                continue;
            }
            if let Some(ref txid) = item.txid {
                if let Ok(Some(stx)) = app.ledger.read().await.get_tx(txid) {
                    rows.push((
                        txid.clone(),
                        stx.height,
                        stx.from.clone(),
                        stx.to.clone(),
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    ));
                }
            }
        }
        if !rows.is_empty() {
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            }
        }
    } else {
        debug!("archive: not configured");
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250922T142220Z  (size=6827b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7
//! Канонизация выполняет crate::api::canonical_msg.
//! Для отладки можно включить LOGOS_CANON_DUMP=1 — напечатает canon.msg_hex.

use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};
use crate::api::canonical_msg;
use crate::{state::AppState, metrics};

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, info, warn, error};

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноническое сообщение (ровно эти байты должны подписываться)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "canon.from={} canon.to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Защита от повторного nonce
    let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce <= prev {
        metrics::inc_tx_rejected("nonce_reuse");
        return (
            StatusCode::CONFLICT,
            Json(SubmitResult { ok: false, txid: None, info: Some("nonce_reuse".into()) }),
        );
    }

    // 4) Коммит в ledger (у тебя submit_tx_simple принимает 5-й аргумент Option<String> под memo)
    let stx = match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, None)
    {
        Ok(s) => s,
        Err(e) => {
            error!("ledger submit error: {e}");
            metrics::inc_tx_rejected("internal");
            return (
                StatusCode::OK,
                Json(SubmitResult { ok: false, txid: None, info: Some("internal".into()) }),
            );
        }
    };

    metrics::inc_tx_accepted();

    // 5) Архивируем (если архив настроен). Не фейлим при ошибке архива.
    if let Some(arch) = &app.archive {
        if let Ok(Some(saved)) = app.ledger.read().await.get_tx(&stx.txid) {
            let rows = vec![(
                saved.txid.clone(),
                saved.height,
                saved.from.clone(),
                saved.to.clone(),
                saved.amount as u64,
                saved.nonce as u64,
                Some((saved.ts / 1000) as u64),
            )];
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            } else {
                info!("archive: wrote tx {}", saved.txid);
            }
        } else {
            warn!("archive: get_tx after commit returned none");
        }
    } else {
        debug!("archive: not configured");
    }

    (
        StatusCode::OK,
        Json(SubmitResult { ok: true, txid: Some(stx.txid), info: Some("accepted".into()) }),
    )
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                i, tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
                index: Some(i), // usize!
            });
            continue;
        }

        let prev = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce <= prev {
            metrics::inc_tx_rejected("nonce_reuse");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("nonce_reuse".into()),
                index: Some(i), // usize!
            });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, None)
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i), // usize!
                });
            }
            Err(e) => {
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected("internal");
                out.push(SubmitBatchItem {
                    ok: false,
                    txid: None,
                    info: Some("internal".into()),
                    index: Some(i), // usize!
                });
            }
        }
    }

    // Batch‑ингест в архив
    if let Some(arch) = &app.archive {
        let mut rows: Vec<(String, u64, String, String, u64, u64, Option<u64>)> = Vec::new();
        for item in &out {
            if !item.ok { continue; }
            if let Some(ref txid) = item.txid {
                if let Ok(Some(stx)) = app.ledger.read().await.get_tx(txid) {
                    rows.push((
                        txid.clone(),
                        stx.height,
                        stx.from.clone(),
                        stx.to.clone(),
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    ));
                }
            }
        }
        if !rows.is_empty() {
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            }
        }
    } else {
        debug!("archive: not configured");
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T074445Z  (size=6843b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7
//! Канонизация выполняет crate::api::canonical_msg.
//! Для отладки можно включить LOGOS_CANON_DUMP=1 — напечатает canon.msg_hex.

use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};
use crate::api::canonical_msg;
use crate::{state::AppState, metrics};

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, info, warn, error};

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноническое сообщение (ровно эти байты должны подписываться)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "canon from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Проверка nonce: ledger.get_nonce() возвращает ожидаемый next_nonce
    let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce != expected {
        let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
        metrics::inc_tx_rejected(info);
        return (
            StatusCode::CONFLICT,
            Json(SubmitResult {
                ok: false,
                txid: None,
                info: Some(format!("{}: expected {}", info, expected)),
            }),
        );
    }

    // 4) Коммит в ledger (submit_tx_simple принимает 5‑й аргумент Option<memo>)
    let stx = match app.ledger
        .write().await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, None)
    {
        Ok(s) => s,
        Err(e) => {
            error!("ledger submit error: {e}");
            metrics::inc_tx_rejected("internal");
            return (StatusCode::OK, Json(SubmitResult { ok: false, txid: None, info: Some("internal".into()) }));
        }
    };

    metrics::inc_tx_accepted();

    // 5) Архивируем (если настроен). Ошибки архива не фейлят запрос.
    if let Some(arch) = &app.archive {
        if let Ok(Some(saved)) = app.ledger.read().await.get_tx(&stx.txid) {
            let rows = vec![(
                saved.txid.clone(),
                saved.height,
                saved.from.clone(),
                saved.to.clone(),
                saved.amount as u64,
                saved.nonce as u64,
                Some((saved.ts / 1000) as u64),
            )];
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            } else {
                info!("archive: wrote tx {}", saved.txid);
            }
        } else {
            warn!("archive: get_tx after commit returned none");
        }
    } else {
        debug!("archive: not configured");
    }

    (
        StatusCode::OK,
        Json(SubmitResult { ok: true, txid: Some(stx.txid), info: Some("accepted".into()) }),
    )
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false, txid: None, info: Some("bad_signature".into()), index: Some(i),
            });
            continue;
        }

        let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce != expected {
            let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
            metrics::inc_tx_rejected(info);
            out.push(SubmitBatchItem {
                ok: false, txid: None, info: Some(info.into()), index: Some(i),
            });
            continue;
        }

        match app.ledger
            .write().await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, None)
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i),
                });
            }
            Err(e) => {
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected("internal");
                out.push(SubmitBatchItem {
                    ok: false, txid: None, info: Some("internal".into()), index: Some(i),
                });
            }
        }
    }

    // Batch‑ингест в архив по успешно закоммиченным
    if let Some(arch) = &app.archive {
        let mut rows: Vec<(String, u64, String, String, u64, u64, Option<u64>)> = Vec::new();
        for item in &out {
            if !item.ok { continue; }
            if let Some(ref txid) = item.txid {
                if let Ok(Some(stx)) = app.ledger.read().await.get_tx(txid) {
                    rows.push((
                        stx.txid.clone(),
                        stx.height,
                        stx.from.clone(),
                        stx.to.clone(),
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    ));
                }
            }
        }
        if !rows.is_empty() {
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            }
        }
    } else {
        debug!("archive: not configured");
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T075441Z  (size=6865b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7
//! Канонизация выполняет crate::api::canonical_msg.
//! Для отладки можно включить LOGOS_CANON_DUMP=1 — напечатает canon.msg_hex.

use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};
use crate::api::canonical_msg;
use crate::{state::AppState, metrics};

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, info, warn, error};

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноническое сообщение
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "canon from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Проверка nonce: ledger.get_nonce() возвращает ожидаемый next_nonce
    let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce != expected {
        let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
        metrics::inc_tx_rejected(info);
        return (
            StatusCode::CONFLICT,
            Json(SubmitResult {
                ok: false,
                txid: None,
                info: Some(format!("{}: expected {}", info, expected)),
            }),
        );
    }

    // 4) Коммит в ledger — ПЕРЕДАЁМ ПОДПИСЬ!
    let stx = match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, Some(tx.sig_hex.clone()))
    {
        Ok(s) => s,
        Err(e) => {
            error!("ledger submit error: {e}");
            metrics::inc_tx_rejected("internal");
            return (
                StatusCode::OK,
                Json(SubmitResult { ok: false, txid: None, info: Some("internal".into()) }),
            );
        }
    };

    metrics::inc_tx_accepted();

    // 5) Архивируем (если настроен). Ошибки архива не фейлят запрос.
    if let Some(arch) = &app.archive {
        if let Ok(Some(saved)) = app.ledger.read().await.get_tx(&stx.txid) {
            let rows = vec![(
                saved.txid.clone(),
                saved.height,
                saved.from.clone(),
                saved.to.clone(),
                saved.amount as u64,
                saved.nonce as u64,
                Some((saved.ts / 1000) as u64),
            )];
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            } else {
                info!("archive: wrote tx {}", saved.txid);
            }
        } else {
            warn!("archive: get_tx after commit returned none");
        }
    } else {
        debug!("archive: not configured");
    }

    (
        StatusCode::OK,
        Json(SubmitResult { ok: true, txid: Some(stx.txid), info: Some("accepted".into()) }),
    )
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false, txid: None, info: Some("bad_signature".into()), index: Some(i),
            });
            continue;
        }

        let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce != expected {
            let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
            metrics::inc_tx_rejected(info);
            out.push(SubmitBatchItem {
                ok: false, txid: None, info: Some(info.into()), index: Some(i),
            });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, Some(tx.sig_hex.clone()))
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i),
                });
            }
            Err(e) => {
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected("internal");
                out.push(SubmitBatchItem {
                    ok: false, txid: None, info: Some("internal".into()), index: Some(i),
                });
            }
        }
    }

    // Batch‑ингест в архив по успешно закоммиченным
    if let Some(arch) = &app.archive {
        let mut rows: Vec<(String, u64, String, String, u64, u64, Option<u64>)> = Vec::new();
        for item in &out {
            if !item.ok { continue; }
            if let Some(ref txid) = item.txid {
                if let Ok(Some(stx)) = app.ledger.read().await.get_tx(txid) {
                    rows.push((
                        stx.txid.clone(),
                        stx.height,
                        stx.from.clone(),
                        stx.to.clone(),
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    ));
                }
            }
        }
        if !rows.is_empty() {
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            }
        }
    } else {
        debug!("archive: not configured");
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T084246Z  (size=6365b)
```text
//! tx.rs — submit_tx (+batch) с корректной передачей подписи в ledger
//! и с диагностикой ошибок ledger (по флагу LOGOS_DEBUG_ERRORS=1).

use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig};
use crate::api::canonical_msg;
use crate::{state::AppState, metrics};

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, info, warn, error};

fn map_ledger_err(e: &anyhow::Error) -> (&'static str, String) {
    let s = e.to_string();
    let sl = s.to_lowercase();
    // человекочитаемая категория для метрик
    let cat = if sl.contains("sig") || sl.contains("signature") {
        "bad_signature"
    } else if sl.contains("nonce") {
        if sl.contains("reuse") || sl.contains("too low") { "nonce_reuse" } else { "nonce_gap" }
    } else if sl.contains("insufficient") || sl.contains("balance") {
        "insufficient_balance"
    } else {
        "internal"
    };

    // Что показать в HTTP-ответе
    let info = if std::env::var("LOGOS_DEBUG_ERRORS").as_deref() == Ok("1") {
        s
    } else {
        cat.to_string()
    };

    (cat, info)
}

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноника (для локальной проверки; ledger всё равно проверит сам)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "canon from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Опциональная локальная проверка подписи — только чтобы раньше отсеять явный мусор.
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Проверка ожидаемого nonce (ускоряем отказ; ledger дублирует)
    let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
    if tx.nonce != expected {
        let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
        metrics::inc_tx_rejected(info);
        return (
            StatusCode::CONFLICT,
            Json(SubmitResult {
                ok: false,
                txid: None,
                info: Some(format!("{}: expected {}", info, expected)),
            }),
        );
    }

    // 4) Коммит в ledger — ВАЖНО: передаём подпись!
    let stx = match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, Some(tx.sig_hex.clone()))
    {
        Ok(s) => s,
        Err(e) => {
            let (cat, info) = map_ledger_err(&e);
            error!("ledger submit error: {e}");
            metrics::inc_tx_rejected(cat);
            return (StatusCode::OK, Json(SubmitResult { ok: false, txid: None, info: Some(info) }));
        }
    };

    metrics::inc_tx_accepted();

    // 5) Архив (best-effort)
    if let Some(arch) = &app.archive {
        if let Ok(Some(saved)) = app.ledger.read().await.get_tx(&stx.txid) {
            let rows = vec![(
                saved.txid.clone(),
                saved.height,
                saved.from.clone(),
                saved.to.clone(),
                saved.amount as u64,
                saved.nonce as u64,
                Some((saved.ts / 1000) as u64),
            )];
            if let Err(e) = arch.record_txs_batch(&rows).await {
                error!("archive: batch write failed: {e}");
            } else {
                info!("archive: wrote tx {}", saved.txid);
            }
        } else {
            warn!("archive: get_tx after commit returned none");
        }
    }

    (StatusCode::OK, Json(SubmitResult { ok: true, txid: Some(stx.txid), info: Some("accepted".into()) }))
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem { ok: false, txid: None, info: Some("bad_signature".into()), index: Some(i) });
            continue;
        }

        let expected = app.ledger.read().await.get_nonce(&tx.from).unwrap_or(0);
        if tx.nonce != expected {
            let info = if tx.nonce < expected { "nonce_reuse" } else { "nonce_gap" };
            metrics::inc_tx_rejected(info);
            out.push(SubmitBatchItem { ok: false, txid: None, info: Some(info.into()), index: Some(i) });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, Some(tx.sig_hex.clone()))
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem { ok: true, txid: Some(stx.txid.clone()), info: Some("accepted".into()), index: Some(i) });
            }
            Err(e) => {
                let (cat, info) = map_ledger_err(&e);
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected(cat);
                out.push(SubmitBatchItem { ok: false, txid: None, info: Some(info), index: Some(i) });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T090505Z  (size=6851b)
```text
use std::sync::Arc;

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};

use crate::state::AppState;

// ==== ВХОДНЫЕ ТИПЫ ====

#[derive(Debug, Deserialize)]
pub struct TxCanonReq {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    #[serde(default)]
    pub memo: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub sig_hex: String,
    #[serde(default)]
    pub memo: Option<String>,
}

// ==== ВЫХОДНЫЕ ТИПЫ ====

#[derive(Debug, Serialize)]
pub struct NonceRes {
    pub rid: String,
    pub expected: u64,
}

#[derive(Debug, Serialize)]
pub struct CanonRes {
    pub msg_hex: String,
}

#[derive(Debug, Serialize)]
pub struct CheckRes {
    pub ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_nonce: Option<u64>,
}

// ==== ВНУТРЕННЕЕ: тот же билдер канонического сообщения, что и в submit ====

fn build_canon_bytes(from: &str, to: &str, amount: u64, nonce: u64, memo: Option<&str>) -> Vec<u8> {
    // Важно: держать 100% идентичным тому, чем пользуется верификация сигнатуры.
    // Наш контракт на этом билде: "from|to|amount|nonce" (+ "|memo" если memo есть)
    let mut s = format!("{}|{}|{}|{}", from, to, amount, nonce);
    if let Some(m) = memo {
        if !m.is_empty() {
            s.push('|');
            s.push_str(m);
        }
    }
    s.into_bytes()
}

// ==== ЭНДПОЙНТЫ ====

pub async fn expected_nonce(
    State(app): State<Arc<AppState>>,
    axum::extract::Path(rid): axum::extract::Path<String>,
) -> Json<NonceRes> {
    // Берём те же цифры, что идут в /balance
    let (_bal, n) = app.ledger.balance_nonce(&rid).unwrap_or((0, 0));
    Json(NonceRes { rid, expected: n })
}

pub async fn canon(Json(req): Json<TxCanonReq>) -> Json<CanonRes> {
    let canon = build_canon_bytes(&req.from, &req.to, req.amount, req.nonce, req.memo.as_deref());
    Json(CanonRes {
        msg_hex: hex::encode(canon),
    })
}

pub async fn check(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> Json<CheckRes> {
    // 1) Проверим nonce, чтобы сразу вернуть expected
    let (_bal, expected) = app.ledger.balance_nonce(&tx.from).unwrap_or((0, 0));
    if tx.nonce != expected {
        return Json(CheckRes {
            ok: false,
            info: Some("nonce_gap".to_string()),
            expected_nonce: Some(expected),
        });
    }

    // 2) Проверка сигнатуры к канонике
    let canon = build_canon_bytes(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.as_deref());
    let sig = match hex::decode(&tx.sig_hex) {
        Ok(v) => v,
        Err(_) => {
            return Json(CheckRes {
                ok: false,
                info: Some("bad_signature_hex".to_string()),
                expected_nonce: Some(expected),
            })
        }
    };

    // from — это base58-строка публичного ключа (ed25519, 32 байта)
    let pk_bytes = match bs58::decode(&tx.from).into_vec() {
        Ok(v) => v,
        Err(_) => {
            return Json(CheckRes {
                ok: false,
                info: Some("bad_from_rid".to_string()),
                expected_nonce: Some(expected),
            })
        }
    };
    if pk_bytes.len() != 32 || sig.len() != 64 {
        return Json(CheckRes {
            ok: false,
            info: Some("bad_key_or_sig_len".to_string()),
            expected_nonce: Some(expected),
        });
    }

    // Проверяем подпись
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};
    let vk = match VerifyingKey::from_bytes(pk_bytes[..32].try_into().unwrap()) {
        Ok(v) => v,
        Err(_) => {
            return Json(CheckRes {
                ok: false,
                info: Some("bad_from_key".to_string()),
                expected_nonce: Some(expected),
            })
        }
    };
    let sig = Signature::from_bytes(sig[..64].try_into().unwrap());
    if let Err(_e) = vk.verify(&canon, &sig) {
        return Json(CheckRes {
            ok: false,
            info: Some("bad_signature".to_string()),
            expected_nonce: Some(expected),
        });
    }

    // 3) Всё хорошо с подписью и nonce — транза должна пройти
    Json(CheckRes {
        ok: true,
        info: None,
        expected_nonce: Some(expected),
    })
}

// === submit_tx: используем тот же билд каноники и затем леджер ===

#[derive(Debug, Serialize)]
struct SubmitOk {
    ok: bool,
}

#[derive(Debug, Serialize)]
struct SubmitErr {
    ok: bool,
    info: String,
}

pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> axum::response::Response {
    // сначала «сухая» проверка
    let dry = check(State(app.clone()), Json(tx.clone())).await;
    if !dry.ok {
        let body = serde_json::to_string(&dry.0).unwrap();
        return axum::http::Response::builder()
            .status(axum::http::StatusCode::BAD_REQUEST)
            .header(axum::http::header::CONTENT_TYPE, "application/json")
            .body(axum::body::Body::from(body))
            .unwrap();
    }

    // nonce/подпись ок -> пишем в леджер
    let res = app
        .ledger
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone());

    match res {
        Ok(_) => {
            let body = serde_json::to_string(&SubmitOk { ok: true }).unwrap();
            axum::http::Response::builder()
                .status(axum::http::StatusCode::OK)
                .header(axum::http::header::CONTENT_TYPE, "application/json")
                .body(axum::body::Body::from(body))
                .unwrap()
        }
        Err(e) => {
            // Попробуем выдать человеку лучший текст
            let (_bal, expected) = app.ledger.balance_nonce(&tx.from).unwrap_or((0, 0));
            let msg = format!("internal: {e}; expected_nonce={expected}");
            let body = serde_json::to_string(&SubmitErr {
                ok: false,
                info: msg,
            })
            .unwrap();
            axum::http::Response::builder()
                .status(axum::http::StatusCode::BAD_REQUEST)
                .header(axum::http::header::CONTENT_TYPE, "application/json")
                .body(axum::body::Body::from(body))
                .unwrap()
        }
    }
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T091810Z  (size=5554b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7.
//! Канонизация выполняет super::canonical_msg.

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, error, info, warn};

use crate::{state::AppState, metrics};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig, canonical_msg};

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноническое сообщение (ровно эти байты должны подписываться)
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            "single: from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Коммит в ledger (nonce/баланс валидирует сам ledger)
    match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
    {
        Ok(stx) => {
            metrics::inc_tx_accepted();

            // 4) (опционально) архив — не падаем при ошибке
            if let Some(arch) = &app.archive {
                if let Err(e) = arch
                    .record_tx(
                        &stx.txid,
                        stx.height,
                        &stx.from,
                        &stx.to,
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    )
                    .await
                {
                    error!("archive: write failed: {e}");
                } else {
                    info!("archive: wrote tx {}", stx.txid);
                }
            }

            (
                StatusCode::OK,
                Json(SubmitResult { ok: true, txid: Some(stx.txid.clone()), info: Some("accepted".into()) }),
            )
        }
        Err(e) => {
            error!("ledger submit error: {e}");
            // map внутренних ошибок ledger в строку метрики — деталей не раскрываем
            metrics::inc_tx_rejected("internal");
            (
                StatusCode::OK,
                Json(SubmitResult { ok: false, txid: None, info: Some("internal".into()) }),
            )
        }
    }
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
                index: Some(i), // usize — как и ожидалось в mod.rs
            });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i),
                });

                if let Some(arch) = &app.archive {
                    if let Err(e) = arch
                        .record_tx(
                            &stx.txid,
                            stx.height,
                            &stx.from,
                            &stx.to,
                            stx.amount as u64,
                            stx.nonce as u64,
                            Some((stx.ts / 1000) as u64),
                        )
                        .await
                    {
                        error!("archive: write failed (batch idx={i}): {e}");
                    }
                }
            }
            Err(e) => {
                error!("ledger submit error (batch idx={i}): {e}");
                metrics::inc_tx_rejected("internal");
                out.push(SubmitBatchItem {
                    ok: false,
                    txid: None,
                    info: Some("internal".into()),
                    index: Some(i),
                });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T094320Z  (size=6418b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7.
//! Подпись проверяем здесь, nonce/баланс/дедуп делает Ledger.
//! Для отладки: LOGOS_CANON_DUMP=1 и RUST_LOG=info,logos_node=debug,lrb_core=debug.

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, error, info};

use crate::{metrics, state::AppState};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig, canonical_msg};

/// Простая классификация сообщений об ошибке ledger -> короткий reason
fn classify_ledger_err<E: std::fmt::Display>(e: &E) -> &'static str {
    let s = format!("{e}").to_lowercase();
    if s.contains("nonce_gap") || (s.contains("expected") && s.contains("nonce")) {
        "nonce_gap"
    } else if s.contains("bad nonce") || s.contains("bad_nonce") || s.contains("nonce") {
        "bad_nonce"
    } else if s.contains("insufficient") || s.contains("funds") || s.contains("balance") {
        "insufficient_funds"
    } else if s.contains("duplicate") || s.contains("dup") {
        "duplicate"
    } else if s.contains("signature") {
        "bad_signature"
    } else {
        "internal"
    }
}

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноника — ровно эти байты подписываются
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            target: "verify",
            "single: from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи ed25519
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Коммит в Ledger (nonce/баланс/дедуп валидирует Ledger)
    match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
    {
        Ok(stx) => {
            metrics::inc_tx_accepted();

            // 4) Архив (опционально). Ошибки архива не фейлят запрос.
            if let Some(arch) = &app.archive {
                if let Err(e) = arch
                    .record_tx(
                        &stx.txid,
                        stx.height,
                        &stx.from,
                        &stx.to,
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    )
                    .await
                {
                    error!("archive: write failed: {e}");
                } else {
                    info!("archive: wrote tx {}", stx.txid);
                }
            }

            (
                StatusCode::OK,
                Json(SubmitResult { ok: true, txid: Some(stx.txid.clone()), info: Some("accepted".into()) }),
            )
        }
        Err(e) => {
            let reason = classify_ledger_err(&e);
            error!("ledger submit error: {e} (reason={reason})");
            metrics::inc_tx_rejected(reason);
            (
                StatusCode::OK,
                Json(SubmitResult { ok: false, txid: None, info: Some(reason.into()) }),
            )
        }
    }
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                target: "verify",
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
                index: Some(i),
            });
            continue;
        }

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i),
                });

                if let Some(arch) = &app.archive {
                    if let Err(e) = arch
                        .record_tx(
                            &stx.txid,
                            stx.height,
                            &stx.from,
                            &stx.to,
                            stx.amount as u64,
                            stx.nonce as u64,
                            Some((stx.ts / 1000) as u64),
                        )
                        .await
                    {
                        error!("archive: write failed (batch idx={i}): {e}");
                    }
                }
            }
            Err(e) => {
                let reason = classify_ledger_err(&e);
                error!("ledger submit error (batch idx={i}): {e} (reason={reason})");
                metrics::inc_tx_rejected(reason);
                out.push(SubmitBatchItem {
                    ok: false,
                    txid: None,
                    info: Some(reason.into()),
                    index: Some(i),
                });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T095516Z  (size=7278b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7.
//! Подпись проверяем здесь, nonce/баланс/дедуп делает Ledger.
//! Для отладки: LOGOS_CANON_DUMP=1 и RUST_LOG=info,logos_node=debug,lrb_core=debug.

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, error, info};

use crate::{metrics, state::AppState};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig, canonical_msg};

/// Мягкая классификация текста ошибки ledger -> короткий "reason"
fn classify_ledger_err<E: std::fmt::Display>(e: &E) -> &'static str {
    let s = format!("{e}").to_lowercase();
    if s.contains("nonce_gap") || s.contains("nonce gap") || (s.contains("expected") && s.contains("nonce")) {
        "nonce_gap"
    } else if s.contains("bad nonce") || s.contains("bad_nonce") {
        "bad_nonce"
    } else if s.contains("insufficient") || s.contains("funds") || s.contains("balance") {
        "insufficient_funds"
    } else if s.contains("duplicate") || s.contains("dup") {
        "duplicate"
    } else if s.contains("signature") {
        "bad_signature"
    } else {
        "internal"
    }
}

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноника — ровно эти байты подписываются
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            target: "verify",
            "single: from={} to={} amount={} nonce={} canon.msg_hex={}",
            tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
        );
    }

    // 2) Проверка подписи ed25519
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult { ok: false, txid: None, info: Some("bad_signature".into()) }),
        );
    }

    // 3) Лёгкий пролог: покажем текущее состояние счёта до коммита
    let (prev_nonce, balance) = {
        let l = app.ledger.read().await;
        let n = l.get_nonce(&tx.from).unwrap_or(0);
        let b = l.get_balance(&tx.from).unwrap_or(0);
        (n, b)
    };
    debug!(
        target: "verify",
        "pre-commit: from={} prev_nonce={} tx_nonce={} balance={}",
        tx.from, prev_nonce, tx.nonce, balance
    );

    // 4) Коммит в Ledger (nonce/баланс/дедуп валидирует Ledger)
    match app
        .ledger
        .write()
        .await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
    {
        Ok(stx) => {
            metrics::inc_tx_accepted();

            // 5) Архив (опционально). Ошибки архива не фейлят запрос.
            if let Some(arch) = &app.archive {
                if let Err(e) = arch
                    .record_tx(
                        &stx.txid,
                        stx.height,
                        &stx.from,
                        &stx.to,
                        stx.amount as u64,
                        stx.nonce as u64,
                        Some((stx.ts / 1000) as u64),
                    )
                    .await
                {
                    error!("archive: write failed: {e}");
                } else {
                    info!("archive: wrote tx {}", stx.txid);
                }
            }

            (
                StatusCode::OK,
                Json(SubmitResult { ok: true, txid: Some(stx.txid.clone()), info: Some("accepted".into()) }),
            )
        }
        Err(e) => {
            let reason = classify_ledger_err(&e);
            error!("ledger submit error: {e} (reason={reason})");
            metrics::inc_tx_rejected(reason);
            (
                StatusCode::OK,
                Json(SubmitResult { ok: false, txid: None, info: Some(reason.into()) }),
            )
        }
    }
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out: Vec<SubmitBatchItem> = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);

        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                target: "verify",
                "batch[{i}] from={} to={} amount={} nonce={} canon.msg_hex={}",
                tx.from, tx.to, tx.amount, tx.nonce, hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem {
                ok: false,
                txid: None,
                info: Some("bad_signature".into()),
                index: Some(i),
            });
            continue;
        }

        // Лёгкий пролог: снимем prev_nonce для отладки
        let prev_nonce = {
            let l = app.ledger.read().await;
            l.get_nonce(&tx.from).unwrap_or(0)
        };
        debug!(
            target: "verify",
            "batch pre-commit[{i}]: from={} prev_nonce={} tx_nonce={}",
            tx.from, prev_nonce, tx.nonce
        );

        match app
            .ledger
            .write()
            .await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem {
                    ok: true,
                    txid: Some(stx.txid.clone()),
                    info: Some("accepted".into()),
                    index: Some(i),
                });

                if let Some(arch) = &app.archive {
                    if let Err(e) = arch
                        .record_tx(
                            &stx.txid,
                            stx.height,
                            &stx.from,
                            &stx.to,
                            stx.amount as u64,
                            stx.nonce as u64,
                            Some((stx.ts / 1000) as u64),
                        )
                        .await
                    {
                        error!("archive: batch write failed (idx={i}): {e}");
                    }
                }
            }
            Err(e) => {
                let reason = classify_ledger_err(&e);
                error!("ledger submit error (batch idx={i}): {e} (reason={reason})");
                metrics::inc_tx_rejected(reason);
                out.push(SubmitBatchItem {
                    ok: false,
                    txid: None,
                    info: Some(reason.into()),
                    index: Some(i),
                });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/api/tx.rs.bak.20250924T100553Z  (size=7643b)
```text
//! tx.rs — приём и валидация транзакций (single + batch) для Axum 0.7.
//!
//! Здесь:
//!   • Проверяем подпись ed25519 именно на канонические байты `from|to|amount|nonce`
//!   • Делаем pre-check nonce (смотрим ожидаемый в ledger) и возвращаем точный reason
//!   • Пишем подробные логи перед коммитом
//!   • Не «маскируем» ошибки под "internal" — метрики с корректными лейблами
//!
//! Для отладки:
//!   LOGOS_CANON_DUMP=1  — печатает canon.msg_hex
//!   RUST_LOG=info,logos_node=debug,lrb_core=debug

use axum::{extract::State, http::StatusCode, Json};
use std::sync::Arc;
use tracing::{debug, error, info};

use crate::{metrics, state::AppState};
use super::{TxIn, SubmitResult, SubmitBatchReq, SubmitBatchItem, verify_sig, canonical_msg};

/// Классификация текста ошибки ledger -> reason
fn classify_ledger_err<E: std::fmt::Display>(e: &E) -> &'static str {
    let s = format!("{e}").to_lowercase();
    if s.contains("nonce_gap") || s.contains("nonce gap") || (s.contains("expected") && s.contains("nonce")) {
        "nonce_gap"
    } else if s.contains("bad nonce") || s.contains("bad_nonce") {
        "bad_nonce"
    } else if s.contains("insufficient") || s.contains("funds") || s.contains("balance") {
        "insufficient_funds"
    } else if s.contains("duplicate") || s.contains("dup") {
        "duplicate"
    } else if s.contains("signature") {
        "bad_signature"
    } else {
        "internal"
    }
}

/// POST /submit_tx
pub async fn submit_tx(
    State(app): State<Arc<AppState>>,
    Json(tx): Json<TxIn>,
) -> (StatusCode, Json<SubmitResult>) {
    // 1) Каноника: ровно эти байты подписываются
    let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
    if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
        debug!(
            target: "verify",
            "canon.msg_hex={}", hex::encode(&msg)
        );
    }

    // 2) Проверка подписи (rid -> ed25519 pk)
    if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
        metrics::inc_tx_rejected("bad_signature");
        return (
            StatusCode::UNAUTHORIZED,
            Json(SubmitResult{ ok:false, txid:None, info:Some("bad_signature".into()) })
        );
    }

    // 3) Pre-check: какой nonce ждёт ledger СЕЙЧАС
    let (expected, balance) = {
        let l = app.ledger.read().await;
        let n = l.get_nonce(&tx.from).unwrap_or(0);    // трактуем как "ожидаемый next"
        let b = l.get_balance(&tx.from).unwrap_or(0);
        (n, b)
    };
    debug!(
        target: "verify",
        "pre-commit: from={} balance={} expected_nonce={} tx_nonce={}",
        tx.from, balance, expected, tx.nonce
    );

    if tx.nonce != expected {
        let reason = if tx.nonce > expected {
            "nonce_gap"
        } else {
            "bad_nonce"
        };
        metrics::inc_tx_rejected(reason);
        let info = if reason == "nonce_gap" {
            format!("nonce_gap: expected {}", expected)
        } else {
            "bad_nonce".to_string()
        };
        return (
            StatusCode::OK,
            Json(SubmitResult{ ok:false, txid:None, info:Some(info) })
        );
    }

    // 4) Коммит в ledger (баланс/дедуп — на стороне ledger)
    match app.ledger
        .write().await
        .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
    {
        Ok(stx) => {
            metrics::inc_tx_accepted();

            // 5) Архив — не фейлим запрос, если не удалось записать
            if let Some(arch) = &app.archive {
                if let Err(e) = arch.record_tx(
                    &stx.txid, stx.height, &stx.from, &stx.to,
                    stx.amount as u64, stx.nonce as u64, Some((stx.ts/1000) as u64)
                ).await {
                    error!("archive: write failed: {e}");
                } else {
                    info!("archive: wrote tx {}", stx.txid);
                }
            }

            (
                StatusCode::OK,
                Json(SubmitResult{ ok:true, txid:Some(stx.txid.clone()), info:Some("accepted".into()) })
            )
        }
        Err(e) => {
            let reason = classify_ledger_err(&e);
            error!("ledger submit error: {e} (reason={reason})");
            metrics::inc_tx_rejected(reason);
            (
                StatusCode::OK,
                Json(SubmitResult{ ok:false, txid:None, info:Some(reason.into()) })
            )
        }
    }
}

/// POST /submit_tx_batch
pub async fn submit_tx_batch(
    State(app): State<Arc<AppState>>,
    Json(req): Json<SubmitBatchReq>,
) -> (StatusCode, Json<Vec<SubmitBatchItem>>) {
    let mut out = Vec::with_capacity(req.txs.len());

    for (i, tx) in req.txs.into_iter().enumerate() {
        let msg = canonical_msg(&tx.from, &tx.to, tx.amount, tx.nonce);
        if std::env::var("LOGOS_CANON_DUMP").as_deref() == Ok("1") {
            debug!(
                target: "verify",
                "batch[{i}]: canon.msg_hex={}", hex::encode(&msg)
            );
        }

        if let Err(_e) = verify_sig(&tx.from, &msg, &tx.sig_hex) {
            metrics::inc_tx_rejected("bad_signature");
            out.push(SubmitBatchItem{ ok:false, txid:None, info:Some("bad_signature".into()), index:Some(i) });
            continue;
        }

        // pre-check nonce
        let expected = {
            let l = app.ledger.read().await;
            l.get_nonce(&tx.from).unwrap_or(0)
        };
        debug!(
            target: "verify",
            "batch pre-commit[{i}]: from={} expected_nonce={} tx_nonce={}",
            tx.from, expected, tx.nonce
        );

        if tx.nonce != expected {
            let reason = if tx.nonce > expected { "nonce_gap" } else { "bad_nonce" };
            metrics::inc_tx_rejected(reason);
            let info = if reason == "nonce_gap" {
                format!("nonce_gap: expected {}", expected)
            } else {
                "bad_nonce".to_string()
            };
            out.push(SubmitBatchItem{ ok:false, txid:None, info:Some(info), index:Some(i) });
            continue;
        }

        match app.ledger
            .write().await
            .submit_tx_simple(&tx.from, &tx.to, tx.amount, tx.nonce, tx.memo.clone())
        {
            Ok(stx) => {
                metrics::inc_tx_accepted();
                out.push(SubmitBatchItem{ ok:true, txid:Some(stx.txid.clone()), info:Some("accepted".into()), index:Some(i) });

                if let Some(arch) = &app.archive {
                    if let Err(e) = arch.record_tx(
                        &stx.txid, stx.height, &stx.from, &stx.to,
                        stx.amount as u64, stx.nonce as u64, Some((stx.ts/1000) as u64)
                    ).await {
                        error!("archive: batch write failed (idx={i}): {e}");
                    }
                }
            }
            Err(e) => {
                let reason = classify_ledger_err(&e);
                error!("ledger submit error (batch idx={i}): {e} (reason={reason})");
                metrics::inc_tx_rejected(reason);
                out.push(SubmitBatchItem{ ok:false, txid:None, info:Some(reason.into()), index:Some(i) });
            }
        }
    }

    (StatusCode::OK, Json(out))
}

```

## FILE: /root/logos_lrb/node/src/archive_ingest.rs  (size=1219b)
```rust
use crate::state::SharedState;
use chrono::Utc;

/// Асинхронная запись tx в Postgres (fire-and-forget).
/// Без паник — ошибки только в лог.
pub async fn insert_tx(
    state: SharedState,
    tx_id: String,
    from_rid: String,
    to_rid: String,
    amount: i64,
    nonce: i64,
    height: Option<i64>,
) {
    let pool = state.archive.clone();
    // получаем клиент
    let client = match pool.get().await {
        Ok(c) => c,
        Err(e) => { tracing::warn!("archive: get conn err: {e}"); return; }
    };

    // ts_sec берём по времени узла; height даём приблизительный (финализация у тебя quorum=1 — ок).
    let ts_sec = Utc::now().timestamp();
    let h = height.unwrap_or_else(|| state.metrics.head_height.get() as i64);

    // upsert по txid
    if let Err(e) = client.execute(
        "INSERT INTO tx (txid, rid_from, rid_to, amount, nonce, ts_sec, height)
         VALUES ($1,$2,$3,$4,$5,$6,$7)
         ON CONFLICT (txid) DO NOTHING",
        &[&tx_id, &from_rid, &to_rid, &amount, &nonce, &ts_sec, &h],
    ).await {
        tracing::warn!("archive: insert err: {e}");
    }
}

```

## FILE: /root/logos_lrb/node/src/archive/mod.rs  (size=1786b)
```rust
use std::sync::Arc;
use anyhow::Result;
use serde::Serialize;

#[derive(Clone, Serialize)]
pub struct BlockRow { pub height: i64, pub hash: String, pub ts_ms: i64 }

#[derive(Clone, Serialize)]
pub struct TxRecord {
    pub txid: String,
    pub from: String,
    pub to: String,
    pub amount: String, // отображение в JSON строкой
    pub nonce: i64,
    pub height: i64,
    pub ts_ms: i64,
}

pub struct Archive { /* pg pool или пусто */ }

impl Archive {
    // история по RID
    pub async fn history_by_rid(&self, _rid: &str, _limit: i64, _cursor: Option<String>) -> Result<Vec<TxRecord>> {
        Ok(vec![])
    }

    // поиск по txid
    pub async fn tx_by_id(&self, _txid: &str) -> Result<Option<TxRecord>> {
        Ok(None)
    }

    // последние блоки
    pub async fn recent_blocks(&self, _limit: i64, _before: Option<i64>) -> Result<Vec<BlockRow>> {
        Ok(vec![])
    }

    // последние транзакции
    pub async fn recent_txs(&self, _limit: i64, _rid: Option<String>, _before_ts: Option<i64>) -> Result<Vec<TxRecord>> {
        Ok(vec![])
    }

    // Единичная запись: типы как их вызывает api/tx.rs
    pub async fn record_tx(
        &self,
        _txid: &str,
        _height: u64,
        _from: &str,
        _to: &str,
        _amount: u64,
        _nonce: u64,
        _ts_opt: Option<u64>
    ) -> Result<()> {
        Ok(())
    }

    // Батч-запись: ровно та же кортежная сигнатура
    pub async fn record_txs_batch(
        &self,
        _rows: &[(String, u64, String, String, u64, u64, Option<u64>)]
    ) -> Result<()> {
        Ok(())
    }
}

pub async fn init() -> Option<Arc<Archive>> { None }

```

## FILE: /root/logos_lrb/node/src/archive/pg.rs  (size=4790b)
```rust
//! Postgres архивация: deadpool-postgres, батч-вставки (prod).
//! ENV: LRB_ARCHIVE_URL=postgres://user:pass@host:5432/db

use anyhow::Result;
use deadpool_postgres::{Config, ManagerConfig, Pool, RecyclingMethod};
use tokio_postgres::NoTls;

#[derive(Clone)]
pub struct ArchivePg {
    pool: Pool,
}

impl ArchivePg {
    pub async fn new(url: &str) -> Result<Self> {
        // Правильная настройка пула: используем поле `url`
        let mut cfg = Config::new();
        cfg.url = Some(url.to_string());
        cfg.manager = Some(ManagerConfig { recycling_method: RecyclingMethod::Fast });
        // Можно добавить пул-лимиты при необходимости:
        // cfg.pool = Some(deadpool_postgres::PoolConfig { max_size: 32, ..Default::default() });

        let pool = cfg.create_pool(Some(deadpool_postgres::Runtime::Tokio1), NoTls)?;
        let a = Self { pool };
        a.ensure_schema().await?;
        Ok(a)
    }

    async fn ensure_schema(&self) -> Result<()> {
        let client = self.pool.get().await?;
        client.batch_execute(r#"
            CREATE TABLE IF NOT EXISTS tx (
                txid      TEXT PRIMARY KEY,
                height    BIGINT NOT NULL,
                from_rid  TEXT NOT NULL,
                to_rid    TEXT NOT NULL,
                amount    BIGINT NOT NULL,
                nonce     BIGINT NOT NULL,
                ts        BIGINT
            );
            CREATE TABLE IF NOT EXISTS account_tx (
                rid    TEXT NOT NULL,
                height BIGINT NOT NULL,
                txid   TEXT NOT NULL,
                PRIMARY KEY (rid, height, txid)
            );
            CREATE INDEX IF NOT EXISTS idx_tx_height ON tx(height);
            CREATE INDEX IF NOT EXISTS idx_ac_tx_rid_height ON account_tx(rid, height);
        "#).await?;
        Ok(())
    }

    pub async fn record_tx(
        &self,
        txid: &str,
        height: u64,
        from: &str,
        to: &str,
        amount: u64,
        nonce: u64,
        ts: Option<u64>
    ) -> Result<()> {
        let mut client = self.pool.get().await?; // <- нужен mut для build_transaction()
        let stmt1 = client.prepare_cached(
            "INSERT INTO tx(txid,height,from_rid,to_rid,amount,nonce,ts)
             VALUES ($1,$2,$3,$4,$5,$6,$7) ON CONFLICT DO NOTHING"
        ).await?;
        let stmt2 = client.prepare_cached(
            "INSERT INTO account_tx(rid,height,txid)
             VALUES ($1,$2,$3) ON CONFLICT DO NOTHING"
        ).await?;

        let h = height as i64;
        let a = amount as i64;
        let n = nonce as i64;
        let t = ts.map(|v| v as i64);

        let tr = client.build_transaction().start().await?;
        tr.execute(&stmt1, &[&txid, &h, &from, &to, &a, &n, &t]).await?;
        tr.execute(&stmt2, &[&from, &h, &txid]).await?;
        tr.execute(&stmt2, &[&to,   &h, &txid]).await?;
        tr.commit().await?;
        Ok(())
    }

    pub async fn history_page(&self, rid: &str, page: u32, per_page: u32) -> Result<Vec<serde_json::Value>> {
        let client = self.pool.get().await?;
        let per = per_page.clamp(1, 1000) as i64;
        let offset = (page as i64) * per;
        let stmt = client.prepare_cached(r#"
            SELECT t.txid,t.height,t.from_rid,t.to_rid,t.amount,t.nonce,t.ts
            FROM account_tx a JOIN tx t ON t.txid=a.txid
            WHERE a.rid=$1
            ORDER BY t.height DESC
            LIMIT $2 OFFSET $3
        "#).await?;
        let rows = client.query(&stmt, &[&rid, &per, &offset]).await?;
        Ok(rows.iter().map(|r| {
            serde_json::json!({
                "txid":   r.get::<_, String>(0),
                "height": r.get::<_, i64>(1),
                "from":   r.get::<_, String>(2),
                "to":     r.get::<_, String>(3),
                "amount": r.get::<_, i64>(4),
                "nonce":  r.get::<_, i64>(5),
                "ts":     r.get::<_, Option<i64>>(6),
            })
        }).collect())
    }

    pub async fn get_tx(&self, txid: &str) -> Result<Option<serde_json::Value>> {
        let client = self.pool.get().await?;
        let stmt = client.prepare_cached(
            "SELECT txid,height,from_rid,to_rid,amount,nonce,ts FROM tx WHERE txid=$1"
        ).await?;
        let row = client.query_opt(&stmt, &[&txid]).await?;
        Ok(row.map(|r| serde_json::json!({
            "txid":   r.get::<_, String>(0),
            "height": r.get::<_, i64>(1),
            "from":   r.get::<_, String>(2),
            "to":     r.get::<_, String>(3),
            "amount": r.get::<_, i64>(4),
            "nonce":  r.get::<_, i64>(5),
            "ts":     r.get::<_, Option<i64>>(6),
        })))
    }
}

```

## FILE: /root/logos_lrb/node/src/archive/sqlite.rs  (size=3556b)
```rust
use anyhow::Result;
use r2d2::{Pool, PooledConnection};
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, OptionalExtension};

#[derive(Clone)]
pub struct ArchiveSqlite { pool: Pool<SqliteConnectionManager> }

impl ArchiveSqlite {
    pub fn new_from_env() -> Option<Self> {
        let path = std::env::var("LRB_ARCHIVE_PATH").ok()?;
        let mgr  = SqliteConnectionManager::file(path);
        let pool = Pool::builder().max_size(8).build(mgr).ok()?;
        let a = Self { pool };
        a.ensure_schema().ok()?;
        Some(a)
    }
    fn conn(&self) -> Result<PooledConnection<SqliteConnectionManager>> { Ok(self.pool.get()?) }
    fn ensure_schema(&self) -> Result<()> {
        let c = self.conn()?;
        c.execute_batch(r#"
            PRAGMA journal_mode=WAL;
            PRAGMA synchronous=NORMAL;
            CREATE TABLE IF NOT EXISTS tx (txid TEXT PRIMARY KEY, height INTEGER, from_rid TEXT, to_rid TEXT, amount INTEGER, nonce INTEGER, ts INTEGER);
            CREATE TABLE IF NOT EXISTS account_tx (rid TEXT, height INTEGER, txid TEXT, PRIMARY KEY(rid,height,txid));
            CREATE INDEX IF NOT EXISTS idx_tx_height ON tx(height);
            CREATE INDEX IF NOT EXISTS idx_ac_tx_rid_height ON account_tx(rid,height);
        "#)?;
        Ok(())
    }
    pub fn record_tx(&self, txid:&str, h:u64, from:&str, to:&str, amount:u64, nonce:u64, ts:Option<u64>) -> Result<()> {
        let c = self.conn()?;
        let tx = c.unchecked_transaction()?;
        tx.execute("INSERT OR IGNORE INTO tx(txid,height,from_rid,to_rid,amount,nonce,ts) VALUES(?,?,?,?,?,?,?)",
            params![txid, h as i64, from, to, amount as i64, nonce as i64, ts.map(|v| v as i64)])?;
        tx.execute("INSERT OR IGNORE INTO account_tx(rid,height,txid) VALUES(?,?,?)", params![from, h as i64, txid])?;
        tx.execute("INSERT OR IGNORE INTO account_tx(rid,height,txid) VALUES(?,?,?)", params![to,   h as i64, txid])?;
        tx.commit()?;
        Ok(())
    }
    pub fn history_page(&self, rid:&str, page:u32, per_page:u32) -> Result<Vec<serde_json::Value>> {
        let c = self.conn()?;
        let per = per_page.clamp(1,1000) as i64;
        let offset = (page as i64) * per;
        let mut st = c.prepare(
            "SELECT t.txid,t.height,t.from_rid,t.to_rid,t.amount,t.nonce,t.ts \
             FROM account_tx a JOIN tx t ON t.txid=a.txid \
             WHERE a.rid=? ORDER BY t.height DESC LIMIT ? OFFSET ?")?;
        let rows = st.query_map(params![rid, per, offset], |row| Ok(serde_json::json!({
            "txid": row.get::<_, String>(0)?, "height": row.get::<_, i64>(1)?,
            "from": row.get::<_, String>(2)?, "to": row.get::<_, String>(3)?,
            "amount": row.get::<_, i64>(4)?, "nonce": row.get::<_, i64>(5)?,
            "ts": row.get::<_, Option<i64>>(6)?
        })))?;
        let mut out = Vec::with_capacity(per as usize);
        for it in rows { out.push(it?); }
        Ok(out)
    }
    pub fn get_tx(&self, txid:&str) -> Result<Option<serde_json::Value>> {
        let c = self.conn()?;
        let mut st = c.prepare("SELECT txid,height,from_rid,to_rid,amount,nonce,ts FROM tx WHERE txid=?")?;
        let v = st.query_row(params![txid], |r| Ok(serde_json::json!({
            "txid": r.get::<_, String>(0)?, "height": r.get::<_, i64>(1)?,
            "from": r.get::<_, String>(2)?, "to": r.get::<_, String>(3)?,
            "amount": r.get::<_, i64>(4)?, "nonce": r.get::<_, i64>(5)?,
            "ts": r.get::<_, Option<i64>>(6)?
        }))).optional()?;
        Ok(v)
    }
}

```

## FILE: /root/logos_lrb/node/src/auth.rs  (size=2129b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/node/src/auth.rs:37:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/auth.rs:69:15  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/bin/bench_burst.rs  (size=1186b)
```rust
// node/src/bin/bench_burst.rs — мини-нагрузчик отправки tx
use reqwest::Client;
use serde_json::json;
use std::env;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = env::var("NODE_URL").unwrap_or_else(|_| "http://127.0.0.1:8080".into());
    let from = env::args().nth(1).expect("arg1 = from rid");
    let to   = env::args().nth(2).expect("arg2 = to rid");
    let base_nonce: u64 = env::args().nth(3).unwrap_or_else(|| "1".into()).parse().unwrap();
    let n: usize = env::args().nth(4).unwrap_or_else(|| "1000".into()).parse().unwrap();

    let cli = Client::new();
    let mut handles = Vec::new();

    for i in 0..n {
        let cli = cli.clone();
        let url = url.clone();
        let from = from.clone();
        let to = to.clone();
        let nonce = base_nonce + (i as u64);
        handles.push(tokio::spawn(async move {
            let body = json!({"from": from, "to": to, "amount": 1u64, "nonce": nonce, "sig_hex": "00"});
            let _ = cli.post(format!("{}/submit_tx", url)).json(&body).send().await;
        }));
    }

    for h in handles { let _ = h.await; }
    println!("burst sent: {}", n);
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/make_tx.rs  (size=1149b)
```rust
// node/src/bin/make_tx.rs — отправка одной транзакции в узел через REST
// Зависимости: reqwest (blocking), serde_json

use reqwest::blocking::Client;
use serde_json::json;
use std::env;

fn main() {
    // Аргументы: FROM TO AMOUNT NONCE  (подпись тут заглушка — в проде подписывает кошелёк)
    let from = env::args().nth(1).expect("arg1 = from RID");
    let to   = env::args().nth(2).expect("arg2 = to RID");
    let amount: u64 = env::args().nth(3).expect("arg3 = amount").parse().expect("u64");
    let nonce:  u64 = env::args().nth(4).unwrap_or_else(|| "1".into()).parse().expect("u64");

    let url = env::var("NODE_URL").unwrap_or_else(|_| "http://127.0.0.1:8080".into());
    let body = json!({
        "from": from,
        "to": to,
        "amount": amount,
        "nonce": nonce,
        "sig_hex": "00" // заглушка
    });

    let cli = Client::new();
    let resp = cli.post(format!("{}/submit_tx", url))
        .json(&body)
        .send()
        .expect("send");
    println!("{}", resp.text().unwrap_or_default());
}

```

## FILE: /root/logos_lrb/node/src/bin/mint.rs  (size=756b)
```rust
// node/src/bin/mint.rs — утилита пополнения баланса (dev/admin)
use std::env;
use lrb_core::ledger::Ledger;

fn main() {
    // путь к sled
    let data_path = env::var("LRB_DATA_PATH")
        .or_else(|_| env::var("LRB_DATA_DIR").map(|p| format!("{}/data.sled", p)))
        .unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());

    let ledger = Ledger::open(&data_path).expect("open ledger");

    let rid = env::args().nth(1).expect("arg1 = RID (base58)");
    let amount: u64 = env::args().nth(2).expect("arg2 = amount").parse().expect("u64");

    ledger.set_balance(&rid, amount as u128).expect("set_balance");
    let _ = ledger.add_minted(amount);

    println!("mint ok: rid={} amount={}", rid, amount);
}

```

## FILE: /root/logos_lrb/node/src/bin/nonce_of_rid.rs  (size=665b)
```rust
use clap::Parser;
use anyhow::Result;

// Ledger из lrb_core
use lrb_core::ledger::Ledger;

/// Вывести expected nonce для RID из локального ledger.
#[derive(Parser)]
struct Opt {
    /// RID (адрес) аккаунта
    #[arg(long)]
    rid: String,

    /// Путь к базе ledger (должен совпадать с тем, что использует сервис)
    #[arg(long, default_value = "/var/lib/logos/data.sled")]
    db: String,
}

fn main() -> Result<()> {
    let opt = Opt::parse();
    let ledger = Ledger::open(&opt.db)?;
    let n = ledger.get_nonce(&opt.rid).unwrap_or(0);
    println!("{n}");
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/rid_gen.rs  (size=4023b)
```rust
use clap::{Parser, Subcommand, ValueEnum};
use ed25519_dalek::{SigningKey, VerifyingKey, SecretKey};
use rand::rngs::OsRng;
use bs58;
use hex;
use zeroize::Zeroize;
use core::convert::TryFrom;

/// Multibase+Multicodec RID:
/// RID = 'z' + base58( 0xED 0x01 || ed25519_pubkey[32] )
const MC_ED25519_PUB: [u8; 2] = [0xED, 0x01];

#[derive(Debug, Clone, ValueEnum)]
enum Output {
    Env,
    Json,
}

#[derive(Debug, Parser)]
#[command(name = "rid_gen", version, about = "RID generator (full-mainnet grade)")]
struct Opts {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Debug, Subcommand)]
enum Cmd {
    /// Сгенерировать пару ключей из CSPRNG
    Gen {
        #[arg(long, value_enum, default_value_t = Output::Env)]
        out: Output,
    },
    /// Сгенерировать ключи из 32-байтового сида (64 hex)
    FromSeedHex {
        seed_hex: String,
        #[arg(long, value_enum, default_value_t = Output::Env)]
        out: Output,
    },
    /// Валидация RID
    Validate { rid: String },
}

fn rid_from_pubkey(pk: &[u8; 32]) -> String {
    let mut buf = Vec::with_capacity(2 + 32);
    buf.extend_from_slice(&MC_ED25519_PUB);
    buf.extend_from_slice(pk);
    // простая base58 (без check) + префикс 'z'/base58btc
    let b58 = bs58::encode(buf).into_string();
    format!("z{b58}")
}

fn parse_rid(rid: &str) -> Result<[u8; 32], String> {
    if !rid.starts_with('z') {
        return Err("RID must start with 'z' (multibase base58btc)".into());
    }
    let data = bs58::decode(&rid[1..]).into_vec().map_err(|e| format!("base58: {e}"))?;
    if data.len() < 34 { return Err("RID payload too short".into()); }
    if data[0..2] != MC_ED25519_PUB { return Err("multicodec prefix mismatch (expected 0xED01)".into()); }
    let mut pk = [0u8; 32];
    pk.copy_from_slice(&data[2..34]);
    Ok(pk)
}

fn print_pair(rid: &str, sk_hex: &str, out: Output) {
    match out {
        Output::Env => {
            println!("FROM_RID={}", rid);
            println!("FROM_SK_HEX={}", sk_hex);
        }
        Output::Json => {
            println!(r#"{{"rid":"{}","sk_hex":"{}"}} "#, rid, sk_hex);
        }
    }
}

fn gen_from_rng(out: Output) -> i32 {
    // ed25519-dalek 2.x с feature=rand_core даёт generate(&mut OsRng)
    let mut rng = OsRng;
    let sk = SigningKey::generate(&mut rng);
    let vk = VerifyingKey::from(&sk);

    let rid = rid_from_pubkey(&vk.to_bytes());
    let sk_hex = hex::encode(sk.to_bytes()); // 32 bytes hex

    print_pair(&rid, &sk_hex, out);
    0
}

fn gen_from_seed_hex(seed_hex: &str, out: Output) -> i32 {
    // 32 байта seed в hex
    let mut seed_bytes = match hex::decode(seed_hex) {
        Ok(v) => v,
        Err(_) => { eprintln!("ERR: seed_hex must be 64 hex chars (32 bytes)"); return 2; }
    };
    if seed_bytes.len() != 32 { eprintln!("ERR: seed must be 32 bytes"); return 2; }

    let mut seed = [0u8; 32];
    seed.copy_from_slice(&seed_bytes);
    seed_bytes.zeroize();

    // В 2.x есть SecretKey::try_from(&[u8])
    let secret = match SecretKey::try_from(&seed[..]) {
        Ok(s) => s,
        Err(e) => { eprintln!("ERR: secret from seed: {e}"); return 2; }
    };
    seed.zeroize();

    let sk = SigningKey::from_bytes(&secret);
    let vk = VerifyingKey::from(&sk);

    let rid = rid_from_pubkey(&vk.to_bytes());
    let sk_hex = hex::encode(sk.to_bytes());

    print_pair(&rid, &sk_hex, out);
    0
}

fn validate_rid(rid: &str) -> i32 {
    match parse_rid(rid) {
        Ok(pk) => { println!("ok ed25519-pub (len=32), pubkey_hex={}", hex::encode(pk)); 0 }
        Err(e) => { eprintln!("invalid RID: {e}"); 3 }
    }
}

fn main() {
    let opts = Opts::parse();
    let code = match opts.cmd {
        Cmd::Gen { out }                 => gen_from_rng(out),
        Cmd::FromSeedHex { seed_hex, out } => gen_from_seed_hex(&seed_hex, out),
        Cmd::Validate { rid }            => validate_rid(&rid),
    };
    std::process::exit(code);
}

```

## FILE: /root/logos_lrb/node/src/bin/rid_of_key.rs  (size=1699b)
```rust
use std::{fs, path::PathBuf};
use clap::Parser;
use ed25519_dalek::SigningKey;
use anyhow::{bail, Result};
use bs58;
use base64::{engine::general_purpose, Engine as _};

#[derive(Parser, Debug)]
struct Opts {
    /// Путь к приватному ключу (raw 32/64 bytes, hex, или base64)
    #[arg(long, default_value="/var/lib/logos/node_key")]
    key: PathBuf,
}

fn decode_guess(bytes: Vec<u8>) -> Vec<u8> {
    // если это «текстоподобно» — попробуем hex/base64; иначе вернём raw
    let s = String::from_utf8_lossy(&bytes).trim().to_string();
    if s.is_empty() { return bytes; }
    let is_texty = s.chars().all(|c| !c.is_control() || c=='\n' || c=='\r' || c=='\t');
    if !is_texty { return bytes; }

    if s.chars().all(|c| c.is_ascii_hexdigit()) && s.len()%2==0 {
        if let Ok(v) = hex::decode(&s) { return v; }
    }
    if let Ok(v) = general_purpose::STANDARD.decode(&s) { return v; }
    bytes
}

fn signing_key_from(buf: &[u8]) -> Result<SigningKey> {
    match buf.len() {
        32 => {
            let seed: [u8;32] = buf.try_into().unwrap();
            Ok(SigningKey::from_bytes(&seed))
        }
        64 => {
            let kp: [u8;64] = buf.try_into().unwrap();
            Ok(SigningKey::from_keypair_bytes(&kp)?)
        }
        n => bail!("Unsupported key length: {n} (need 32 or 64 bytes after decode)"),
    }
}

fn main() -> Result<()> {
    let opts = Opts::parse();
    let raw = fs::read(&opts.key)?;
    let dec = decode_guess(raw);
    let sk = signing_key_from(&dec)?;
    let pk = sk.verifying_key();
    let rid = bs58::encode(pk.as_bytes()).into_string();
    println!("{rid}");
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/sign_raw_hex.rs  (size=610b)
```rust
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey};
use std::{fs, path::PathBuf};

#[derive(Parser)]
struct Opt {
    #[arg(long)] key: PathBuf,      // файл 32 байта (seed)
    #[arg(long)] msg_hex: String,   // каноника сервера в hex
}

fn main() -> anyhow::Result<()> {
    let opt = Opt::parse();
    let seed = fs::read(opt.key)?;
    let mut skb = [0u8; 32];
    skb.copy_from_slice(&seed[..32]);
    let sk = SigningKey::from_bytes(&skb);
    let msg = hex::decode(opt.msg_hex)?;
    let sig = sk.sign(&msg);
    println!("{}", hex::encode(sig.to_bytes()));
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/sign_submit.rs  (size=1834b)
```rust
use anyhow::Result;
use ed25519_dalek::{SigningKey, VerifyingKey, Signer};
use reqwest::blocking::Client;
use reqwest::header::CONTENT_TYPE;
use serde_json::json;
use std::{env, process};
use bs58;

// ВАЖНО: импорт канона из основного узла как из lib-крэйта
use logos_node::api::canonical_msg;

fn main() -> Result<()> {
    let a: Vec<String> = env::args().collect();
    if a.len() < 7 {
        eprintln!("usage: sign_submit <from_sk_hex> <from_rid> <to_rid> <amount> <nonce> <memo>");
        process::exit(2);
    }
    let sk_hex=&a[1]; let from=&a[2]; let to=&a[3];
    let amount: u64=a[4].parse()?; let nonce: u64=a[5].parse()?; let memo=&a[6];

    // SK -> SigningKey, проверим RID
    let sk_bytes = hex::decode(sk_hex)?;
    if sk_bytes.len()!=32 { anyhow::bail!("from_sk_hex must be 32 bytes hex"); }
    let mut arr=[0u8;32]; arr.copy_from_slice(&sk_bytes);
    let sk = SigningKey::from_bytes(&arr);
    let vk = VerifyingKey::from(&sk);
    let rid_check = bs58::encode(vk.to_bytes()).into_string();
    if rid_check != *from { anyhow::bail!("from_rid mismatch with provided secret key"); }

    // КАНОНИЧЕСКОЕ сообщение узла (digest-байты)
    let msg = canonical_msg(from, to, amount, nonce);

    // Подписываем digest-байты Ed25519
    let sig_hex = hex::encode(sk.sign(&msg).to_bytes());

    // submit_tx
    let body = json!({"from":from,"to":to,"amount":amount,"nonce":nonce,"memo":memo,"sig_hex":sig_hex});
    let cli  = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/submit_tx")
        .header(CONTENT_TYPE, "application/json")
        .body(body.to_string())
        .send()?.text()?;

    println!("== submit body ==\n{}\n", body);
    println!("== response ==\n{}\n", resp);
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_json.rs  (size=1792b)
```rust
use ed25519_dalek::{SigningKey, VerifyingKey, Signer};
use sha2::{Sha256, Digest};
use bs58;
use std::{env, process};

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 7 {
        eprintln!("usage: tx_json <from_sk_hex> <from_rid(base58)> <to_rid(base58)> <amount> <nonce> <memo>");
        process::exit(2);
    }
    let sk_hex   = &args[1];
    let from_rid = &args[2];
    let to_rid   = &args[3];
    let amount: u64 = args[4].parse().expect("amount u64");
    let nonce:  u64 = args[5].parse().expect("nonce u64");
    let memo        = &args[6];

    // SK hex -> SigningKey (32 байта)
    let sk_bytes = hex::decode(sk_hex).expect("bad sk hex");
    if sk_bytes.len() != 32 { eprintln!("from_sk_hex must be 32 bytes hex"); process::exit(3); }
    let mut arr = [0u8; 32]; arr.copy_from_slice(&sk_bytes);
    let sk = SigningKey::from_bytes(&arr);
    let vk = VerifyingKey::from(&sk);

    // Проверка соответствия from_rid публичному ключу
    let rid_check = bs58::encode(vk.to_bytes()).into_string();
    if rid_check != *from_rid {
        eprintln!("from_rid mismatch with from_sk_hex");
        process::exit(4);
    }

    // txid = SHA256(from|to|amount|nonce)
    let mut hasher = Sha256::new();
    hasher.update(from_rid.as_bytes());
    hasher.update(to_rid.as_bytes());
    hasher.update(&amount.to_be_bytes());
    hasher.update(&nonce.to_be_bytes());
    let txid = hasher.finalize();

    // Подпись
    let sig = sk.sign(&txid);
    let sig_hex = hex::encode(sig.to_bytes());

    // Готовый JSON для submit_tx
    println!(r#"{{
  "from":"{}",
  "to":"{}",
  "amount":{},
  "nonce":{},
  "memo":"{}",
  "sig_hex":"{}"
}}"#, from_rid, to_rid, amount, nonce, memo, sig_hex);
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs  (size=1171b)
```rust
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use logos_node::api::canonical_msg; // <-- одна и та же каноника!
use std::{fs, path::PathBuf};

#[derive(Parser)]
struct Opt {
    /// Файл с приватным ключом (32 байта seed)
    #[arg(long)]
    key: PathBuf,

    /// RID получателя (bs58(pubkey32))
    #[arg(long)]
    to: String,

    /// Сумма и nonce
    #[arg(long)]
    amount: u64,
    #[arg(long)]
    nonce: u64,
}

fn main() -> anyhow::Result<()> {
    let opt = Opt::parse();

    // 1) загрузили seed -> signing key
    let seed = fs::read(&opt.key)?;
    let mut skb = [0u8; 32];
    skb.copy_from_slice(&seed[..32]);
    let sk = SigningKey::from_bytes(&skb);

    // 2) from RID как bs58(pubkey32) из ключа
    let vk: VerifyingKey = (&sk).into();
    let from = bs58::encode(vk.to_bytes()).into_string();

    // 3) каноническое сообщение
    let msg = canonical_msg(&from, &opt.to, opt.amount, opt.nonce);

    // 4) подпись -> hex
    let sig = sk.sign(&msg);
    println!("{}", hex::encode(sig.to_bytes()));
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs.bak.20250922T045932Z  (size=3115b)
```text
// tx_offline_sign.rs — оффлайн подпись и (опционально) submit
// Формат канонической строки: "from|to|amount|nonce"
// Подпись: Ed25519, выводим в base64

use anyhow::{Context, Result};
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey, SecretKey, VerifyingKey};
use serde_json::json;
use std::{fs, path::PathBuf};
use bs58;
use reqwest::Client;

#[derive(Parser, Debug)]
struct Opts {
    /// Путь к 32-байтному секрету (seed) ed25519
    #[clap(long)]
    key: PathBuf,
    /// RID получателя (bs58)
    #[clap(long)]
    to: String,
    /// Сумма (целое, u128)
    #[clap(long)]
    amount: String,
    /// Nonce (u64)
    #[clap(long)]
    nonce: u64,
    /// Куда записать JSON транзакции
    #[clap(long, default_value = "/tmp/tx.json")]
    out: PathBuf,
    /// (Опционально) URL узла для submit (/submit_tx)
    #[clap(long)]
    submit: Option<String>,
}

fn read_key32(p: &PathBuf) -> Result<[u8;32]> {
    let buf = fs::read(p).with_context(|| format!("read key: {}", p.display()))?;
    if buf.len() == 32 {
        return Ok(<[u8;32]>::try_from(buf.as_slice()).unwrap());
    }
    // на всякий — пробуем hex/base64
    if let Ok(raw) = hex::decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    if let Ok(raw) = base64::engine::general_purpose::STANDARD.decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    anyhow::bail!("key must be 32 bytes (raw/hex/base64)");
}

#[tokio::main]
async fn main() -> Result<()> {
    let opt = Opts::parse();

    // 1) грузим ключ, строим RID из публичного ключа
    let seed = read_key32(&opt.key)?;
    let sk = SigningKey::from_bytes(&SecretKey::from_bytes(&seed));
    let vk: VerifyingKey = sk.verifying_key();
    let from_rid = bs58::encode(vk.to_bytes()).into_string();

    // 2) каноническое сообщение
    let msg = format!("{}|{}|{}|{}", from_rid, opt.to, opt.amount, opt.nonce);

    // 3) подпись Ed25519 (base64)
    let sig = sk.sign(msg.as_bytes());
    let sig_b64 = base64::engine::general_purpose::STANDARD.encode(sig.to_bytes());

    // 4) JSON транзакции
    let tx = json!({
        "from": from_rid,
        "to": opt.to,
        "amount": opt.amount,
        "nonce": opt.nonce,
        "signature": sig_b64
    });
    fs::write(&opt.out, serde_json::to_vec_pretty(&tx)?)?;
    eprintln!("tx written to {}", opt.out.display());

    // 5) (опц.) submit
    if let Some(url) = opt.submit {
        let cli = Client::builder().use_rustls_tls().build()?;
        let res = cli.post(url)
            .header("content-type","application/json")
            .body(serde_json::to_vec(&tx)?)
            .send().await?;
        let status = res.status();
        let body = res.text().await.unwrap_or_default();
        println!("submit status={status}, body={body}");
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs.bak.20250922T050907Z  (size=3193b)
```text
// tx_offline_sign.rs — оффлайн подпись и (опционально) submit
// Канон сообщения: "from|to|amount|nonce" (amount — u64).
// Подпись: Ed25519, выводим в base64.

use anyhow::{Context, Result};
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey, SecretKey, VerifyingKey};
use serde_json::json;
use std::{fs, path::PathBuf};

use base64::Engine; // <= обязательно для .encode/.decode
use reqwest::Client;
use bs58;
use hex;

#[derive(Parser, Debug)]
struct Opts {
    /// Путь к 32-байтному seed (ed25519)
    #[clap(long)]
    key: PathBuf,
    /// RID получателя (bs58)
    #[clap(long)]
    to: String,
    /// Сумма (u64)
    #[clap(long)]
    amount: u64,
    /// Nonce (u64)
    #[clap(long)]
    nonce: u64,
    /// Куда записать JSON транзакции
    #[clap(long, default_value = "/tmp/tx.json")]
    out: PathBuf,
    /// (Опц.) URL узла для submit (/submit_tx)
    #[clap(long)]
    submit: Option<String>,
}

fn read_key32(p: &PathBuf) -> Result<[u8;32]> {
    let buf = fs::read(p).with_context(|| format!("read key: {}", p.display()))?;
    if buf.len() == 32 {
        return Ok(<[u8;32]>::try_from(buf.as_slice()).unwrap());
    }
    // Доп. форматы — hex/base64
    if let Ok(raw) = hex::decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    if let Ok(raw) = base64::engine::general_purpose::STANDARD.decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    anyhow::bail!("key must be 32 bytes (raw/hex/base64)");
}

#[tokio::main]
async fn main() -> Result<()> {
    let opt = Opts::parse();

    // 1) Ключ и RID отправителя
    let seed = read_key32(&opt.key)?;
    let secret = ed25519_dalek::SecretKey::from_bytes(&seed);
    let sk: ed25519_dalek::SigningKey = ed25519_dalek::SigningKey::from_bytes(&secret);
    let vk: VerifyingKey = sk.verifying_key();
    let from_rid = bs58::encode(vk.to_bytes()).into_string();

    // 2) Каноническая строка
    let msg = format!("{}|{}|{}|{}", from_rid, opt.to, opt.amount, opt.nonce);

    // 3) Подпись (base64)
    let sig = sk.sign(msg.as_bytes());
    let sig_b64 = base64::engine::general_purpose::STANDARD.encode(sig.to_bytes());

    // 4) JSON-транзакция (amount — число)
    let tx = json!({
        "from": from_rid,
        "to": opt.to,
        "amount": opt.amount,
        "nonce": opt.nonce,
        "signature": sig_b64
    });
    fs::write(&opt.out, serde_json::to_vec_pretty(&tx)?)?;
    eprintln!("tx written to {}", opt.out.display());

    // 5) (опц.) submit
    if let Some(url) = opt.submit {
        let cli = Client::builder().use_rustls_tls().build()?;
        let res = cli.post(url)
            .header("content-type","application/json")
            .body(serde_json::to_vec(&tx)?)
            .send().await?;
        let status = res.status();
        let body = res.text().await.unwrap_or_default();
        println!("submit status={status}, body={body}");
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs.bak.20250922T065707Z  (size=3118b)
```text
// tx_offline_sign.rs — оффлайн подпись и (опционально) submit
// Канон сообщения: "from|to|amount|nonce" (amount — u64).
// Подпись: Ed25519, выводим в base64.

use anyhow::{Context, Result};
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use serde_json::json;
use std::{fs, path::PathBuf};

use base64::Engine; // для .encode/.decode
use reqwest::Client;
use bs58;
use hex;

#[derive(Parser, Debug)]
struct Opts {
    /// Путь к 32-байтному seed (ed25519)
    #[clap(long)]
    key: PathBuf,
    /// RID получателя (bs58)
    #[clap(long)]
    to: String,
    /// Сумма (u64)
    #[clap(long)]
    amount: u64,
    /// Nonce (u64)
    #[clap(long)]
    nonce: u64,
    /// Куда записать JSON транзакции
    #[clap(long, default_value = "/tmp/tx.json")]
    out: PathBuf,
    /// (Опц.) URL узла для submit (/submit_tx)
    #[clap(long)]
    submit: Option<String>,
}

fn read_key32(p: &PathBuf) -> Result<[u8;32]> {
    let buf = fs::read(p).with_context(|| format!("read key: {}", p.display()))?;
    if buf.len() == 32 {
        return Ok(<[u8;32]>::try_from(buf.as_slice()).unwrap());
    }
    // Доп. форматы — hex/base64
    if let Ok(raw) = hex::decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    if let Ok(raw) = base64::engine::general_purpose::STANDARD.decode(&buf) {
        if raw.len()==32 { return Ok(<[u8;32]>::try_from(raw.as_slice()).unwrap()); }
    }
    anyhow::bail!("key must be 32 bytes (raw/hex/base64)");
}

#[tokio::main]
async fn main() -> Result<()> {
    let opt = Opts::parse();

    // 1) Ключ и RID отправителя
    let seed = read_key32(&opt.key)?;
    // В ed25519-dalek v2 можно напрямую:
    let sk: SigningKey = SigningKey::from_bytes(&seed);
    let vk: VerifyingKey = sk.verifying_key();
    let from_rid = bs58::encode(vk.to_bytes()).into_string();

    // 2) Каноническая строка
    let msg = format!("{}|{}|{}|{}", from_rid, opt.to, opt.amount, opt.nonce);

    // 3) Подпись (base64)
    let sig = sk.sign(msg.as_bytes());
    let sig_b64 = base64::engine::general_purpose::STANDARD.encode(sig.to_bytes());

    // 4) JSON-транзакция (amount — число)
    let tx = json!({
        "from": from_rid,
        "to": opt.to,
        "amount": opt.amount,
        "nonce": opt.nonce,
        "signature": sig_b64
    });
    fs::write(&opt.out, serde_json::to_vec_pretty(&tx)?)?;
    eprintln!("tx written to {}", opt.out.display());

    // 5) (опц.) submit
    if let Some(url) = opt.submit {
        let cli = Client::builder().use_rustls_tls().build()?;
        let res = cli.post(url)
            .header("content-type","application/json")
            .body(serde_json::to_vec(&tx)?)
            .send().await?;
        let status = res.status();
        let body = res.text().await.unwrap_or_default();
        println!("submit status={status}, body={body}");
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs.bak.20250922T070552Z  (size=1762b)
```text
use std::{fs, path::PathBuf};
use anyhow::{Context, Result};
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey};

/// Подписывает каноническое сообщение "from|to|amount|nonce" и печатает подпись в HEX.
/// FROM вычисляется из ключа (verifying key -> bs58 RID), чтобы подпись и RID совпадали.
#[derive(Parser, Debug)]
#[command(name = "tx_offline_sign", version, about = "Sign canonical TX and print HEX signature")]
struct Opts {
    /// Путь к приватному ключу (32 байта)
    #[arg(long)]
    key: PathBuf,

    /// RID получателя (bs58)
    #[arg(long)]
    to: String,

    /// Сумма перевода
    #[arg(long)]
    amount: u64,

    /// Nonce отправителя
    #[arg(long)]
    nonce: u64,
}

fn main() -> Result<()> {
    let o = Opts::parse();

    // читаем 32-байтный seed
    let seed = fs::read(&o.key)
        .with_context(|| format!("read key {}", o.key.display()))?;
    if seed.len() < 32 {
        anyhow::bail!("key must be 32 bytes, got {}", seed.len());
    }
    let mut seed32 = [0u8; 32];
    seed32.copy_from_slice(&seed[..32]);

    // ed25519 sk
    let sk = SigningKey::from_bytes(&seed32);
    // derive FROM RID из verifying key
    let vk = sk.verifying_key();
    let from_rid = bs58::encode(vk.to_bytes()).into_string();

    // каноническое сообщение
    let msg = format!("{}|{}|{}|{}", from_rid, o.to, o.amount, o.nonce);

    // подпись
    let sig = sk.sign(msg.as_bytes());
    let sig_hex = hex::encode(sig.to_bytes()); // нижний hex

    // выводим только HEX в stdout
    println!("{sig_hex}");
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_offline_sign.rs.bak.20250922T075039Z  (size=2049b)
```text
use std::{fs, path::PathBuf};
use anyhow::{Context, Result};
use clap::Parser;
use ed25519_dalek::{Signer, SigningKey};

/// Подписывает каноническое сообщение, где FROM/TO берутся как hex(pubkey).
/// Сообщение: "{from_hex}|{to_hex}|{amount}|{nonce}"
/// Печатает подпись в HEX (нижний регистр).
#[derive(Parser, Debug)]
#[command(name = "tx_offline_sign", version, about = "Sign canonical TX and print HEX signature (hex(pubkey) canon)")]
struct Opts {
    /// Путь к приватному ключу (32 байта seed/secret)
    #[arg(long)]
    key: PathBuf,
    /// RID получателя (bs58)
    #[arg(long)]
    to: String,
    /// Сумма перевода
    #[arg(long)]
    amount: u64,
    /// Nonce отправителя
    #[arg(long)]
    nonce: u64,
}

fn main() -> Result<()> {
    let o = Opts::parse();

    // читаем 32-байтный seed/secret
    let seed = fs::read(&o.key)
        .with_context(|| format!("read key {}", o.key.display()))?;
    if seed.len() < 32 {
        anyhow::bail!("key must be 32 bytes, got {}", seed.len());
    }
    let mut seed32 = [0u8; 32];
    seed32.copy_from_slice(&seed[..32]);

    // ed25519 signing key + verifying key
    let sk = SigningKey::from_bytes(&seed32);
    let vk = sk.verifying_key();

    // hex(pubkey) отправителя (32 байта)
    let from_hex = hex::encode(vk.to_bytes());

    // to_hex: bs58 -> raw(32) -> hex
    let to_raw = bs58::decode(&o.to)
        .into_vec()
        .context("decode TO bs58")?;
    if to_raw.len() != 32 {
        anyhow::bail!("TO decoded length must be 32, got {}", to_raw.len());
    }
    let to_hex = hex::encode(to_raw);

    // каноническое сообщение
    let msg = format!("{}|{}|{}|{}", from_hex, to_hex, o.amount, o.nonce);

    // подпись и вывод HEX
    let sig = sk.sign(msg.as_bytes());
    let sig_hex = hex::encode(sig.to_bytes());
    println!("{sig_hex}");
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_submit.rs  (size=1874b)
```rust
use ed25519_dalek::{SigningKey, VerifyingKey, Signer};
use reqwest::blocking::Client;
use reqwest::header::CONTENT_TYPE;
use serde_json::json;
use sha2::{Sha256, Digest};
use anyhow::Result;
use std::{env, process};
use bs58;

fn main()->Result<()>{
    let a:Vec<String>=env::args().collect();
    if a.len()<7 {
        eprintln!("usage: tx_submit <from_sk_hex> <from_rid> <to_rid> <amount> <nonce> <memo>");
        process::exit(2);
    }
    let sk_hex=&a[1]; let from=&a[2]; let to=&a[3];
    let amount:u64=a[4].parse()?; let nonce:u64=a[5].parse()?; let memo=&a[6];

    // SK hex -> SigningKey + проверка, что from == base58(pubkey)
    let sk_bytes=hex::decode(sk_hex)?;
    if sk_bytes.len()!=32 { anyhow::bail!("from_sk_hex must be 32 bytes hex"); }
    let mut arr=[0u8;32]; arr.copy_from_slice(&sk_bytes);
    let sk=SigningKey::from_bytes(&arr);
    let vk=VerifyingKey::from(&sk);
    let rid_check = bs58::encode(vk.to_bytes()).into_string();
    if rid_check != *from { anyhow::bail!("from_rid mismatch with provided secret key"); }

    // Сообщение для подписи: SHA256(b"<from>|<to>|<amount>|<nonce>")
    let msg_ascii = format!("{}|{}|{}|{}", from, to, amount, nonce);
    let digest = Sha256::digest(msg_ascii.as_bytes());
    let sig_hex = hex::encode(sk.sign(&digest).to_bytes());

    let body = json!({"from":from,"to":to,"amount":amount,"nonce":nonce,"memo":memo,"sig_hex":sig_hex});
    let cli = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/submit_tx")
        .header(CONTENT_TYPE,"application/json")
        .body(body.to_string())
        .send()?.text()?;

    println!("== signed message (ascii) ==\n{}\n", msg_ascii);
    println!("== digest(hex) ==\n{}\n", hex::encode(digest));
    println!("== submit body ==\n{}\n", body);
    println!("== submit response ==\n{}\n", resp);
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bin/tx_submit_try.rs  (size=2867b)
```rust
use ed25519_dalek::{SigningKey, VerifyingKey, Signer};
use sha2::{Sha256, Digest};
use std::{env, process};
use reqwest::blocking::Client;
use reqwest::header::CONTENT_TYPE;

fn sign_and_send(sk: &SigningKey, from_rid: &str, to_rid: &str, amount: u64, nonce: u64, memo: &str, mode: &str) -> anyhow::Result<(bool, String)> {
    // базовый дайджест
    let mut h = Sha256::new();
    h.update(from_rid.as_bytes());
    h.update(to_rid.as_bytes());
    h.update(amount.to_string().as_bytes());
    h.update(nonce.to_string().as_bytes());
    let digest = h.finalize();               // 32 bytes
    let digest_hex = hex::encode(digest);    // ascii

    // варианты сообщения для подписи
    let msg: Vec<u8> = match mode {
        "digest_bytes" => digest.to_vec(),
        "digest_hex"   => digest_hex.as_bytes().to_vec(),
        "ascii_pipe"   => format!("{}|{}|{}|{}", from_rid, to_rid, amount, nonce).into_bytes(),
        "ascii_concat" => format!("{}{}{}{}",     from_rid, to_rid, amount, nonce).into_bytes(),
        _ => return Err(anyhow::anyhow!("unknown mode")),
    };

    let sig_hex = hex::encode(sk.sign(&msg).to_bytes());
    let body = format!(r#"{{
  "from":"{}","to":"{}","amount":{},"nonce":{},"memo":"{}","sig_hex":"{}"
}}"#, from_rid, to_rid, amount, nonce, memo, sig_hex);

    let cli = Client::new();
    let resp = cli.post("http://127.0.0.1:8080/submit_tx")
        .header(CONTENT_TYPE, "application/json")
        .body(body.clone())
        .send()?
        .text()?;

    let ok = resp.contains(r#""ok":true"#);
    println!("\n== mode: {} ==\n{}\n", mode, resp);
    Ok((ok, resp))
}

fn main() -> anyhow::Result<()> {
    let a: Vec<String> = env::args().collect();
    if a.len() < 7 {
        eprintln!("usage: tx_submit_try <from_sk_hex> <from_rid> <to_rid> <amount> <nonce> <memo>");
        process::exit(2);
    }
    let sk_hex   = &a[1];
    let from_rid = &a[2];
    let to_rid   = &a[3];
    let amount: u64 = a[4].parse()?;
    let nonce:  u64 = a[5].parse()?;
    let memo        = &a[6];

    // восстановим keypair
    let sk_bytes = hex::decode(sk_hex)?;
    if sk_bytes.len() != 32 { anyhow::bail!("from_sk_hex must be 32 bytes hex"); }
    let mut arr = [0u8; 32]; arr.copy_from_slice(&sk_bytes);
    let sk = SigningKey::from_bytes(&arr);
    let vk = VerifyingKey::from(&sk);
    let rid_check = bs58::encode(vk.to_bytes()).into_string();
    if rid_check != *from_rid {
        anyhow::bail!("from_rid mismatch with from_sk_hex");
    }

    let modes = ["digest_bytes","digest_hex","ascii_pipe","ascii_concat"];
    for m in modes {
        let (ok, _r) = sign_and_send(&sk, from_rid, to_rid, amount, nonce, memo, m)?;
        if ok { println!("✓ accepted with mode = {}", m); return Ok(()); }
    }
    println!("✗ all tried modes failed");
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/bridge_journal.rs  (size=4863b)
```rust
//! Durable journal for rToken bridge (idempotent ops + retries) on sled.

use serde::{Serialize,Deserialize};
use sled::IVec;
use anyhow::{Result,anyhow};
use std::time::{SystemTime,UNIX_EPOCH};

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum OpKind { Deposit, Redeem }

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum OpStatus { Pending, PayoutSent, Confirmed, Redeemed, Failed }

#[derive(Serialize,Deserialize,Clone)]
pub struct JournalOp{
    pub op_id:String,
    pub kind:OpKind,
    pub rid:String,
    pub amount:u64,
    pub ext_txid:String,     // external chain txid / idempotency key
    pub status:OpStatus,
    pub created_ms:u64,
    pub updated_ms:u64,
    pub retries:u32,
    pub last_error:Option<String>,
}

fn now_ms()->u64{
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() as u64
}

pub struct Journal{
    ops:   sled::Tree,      // j:<op_id> -> JournalOp
    idx:   sled::Tree,      // x:<ext_txid> -> op_id (idempotency)
    retry: sled::Tree,      // r:<op_id> -> next_retry_ms
}

impl Journal{
    pub fn open(db:&sled::Db)->Result<Self>{
        Ok(Self{
            ops:   db.open_tree("bridge_journal.ops")?,
            idx:   db.open_tree("bridge_journal.idx")?,
            retry: db.open_tree("bridge_journal.retry")?,
        })
    }

    fn ser<T:Serialize>(v:&T)->Vec<u8>{ serde_json::to_vec(v).unwrap() }
    fn de<T:for<'a> Deserialize<'a>>(v:&IVec)->T{ serde_json::from_slice(v).unwrap() }

    pub fn begin(&self, kind:OpKind, rid:&str, amount:u64, ext:&str)->Result<JournalOp>{
        if let Some(opid) = self.idx.get(format!("x:{ext}"))?{
            let id = std::str::from_utf8(&opid).unwrap();
            return self.get_by_id(id);
        }
        let op_id = blake3::hash(
            format!("{kind:?}:{rid}:{amount}:{ext}:{:?}", now_ms()).as_bytes()
        ).to_hex().to_string();

        let op = JournalOp{
            op_id: op_id.clone(),
            kind, rid: rid.to_string(), amount,
            ext_txid: ext.to_string(),
            status: OpStatus::Pending,
            created_ms: now_ms(), updated_ms: now_ms(),
            retries:0, last_error:None
        };

        self.ops.insert(format!("j:{op_id}"), Self::ser(&op))?;
        self.idx.insert(format!("x:{ext}"), op_id.as_bytes())?;
        Ok(op)
    }

    pub fn set_status(&self, op_id:&str, status:OpStatus, err:Option<String>)->Result<()>{
        let key = format!("j:{op_id}");
        let Some(v)=self.ops.get(&key)? else { return Err(anyhow!("op not found")); };
        let mut op:JournalOp = Self::de(&v);
        op.status = status;
        op.updated_ms = now_ms();
        op.last_error = err;
        self.ops.insert(key, Self::ser(&op))?;
        Ok(())
    }

    pub fn schedule_retry(&self, op_id:&str, delay_ms:u64)->Result<()>{
        let when = now_ms()+delay_ms;
        self.retry.insert(format!("r:{op_id}"), when.to_be_bytes().to_vec())?;
        Ok(())
    }

    pub fn due_retries(&self, limit:usize)->Result<Vec<String>>{
        let now = now_ms();
        let mut out=Vec::new();
        for kv in self.retry.iter(){
            let (k,v) = kv?;
            if v.len()==8 {
                let when = u64::from_be_bytes(v.as_ref().try_into().unwrap());
                if when <= now {
                    let key = std::str::from_utf8(&k).unwrap().to_string(); // r:<op_id>
                    let op_id = key[2..].to_string();
                    out.push(op_id);
                    if out.len()>=limit { break; }
                }
            }
        }
        Ok(out)
    }

    pub fn clear_retry(&self, op_id:&str)->Result<()>{
        self.retry.remove(format!("r:{op_id}"))?;
        Ok(())
    }

    pub fn get_by_id(&self, op_id:&str)->Result<JournalOp>{
        let Some(v)=self.ops.get(format!("j:{op_id}"))? else { return Err(anyhow!("op not found")); };
        Ok(Self::de(&v))
    }

    pub fn get_by_ext(&self, ext:&str)->Result<Option<JournalOp>>{
        if let Some(opid)=self.idx.get(format!("x:{ext}"))?{
            let id = std::str::from_utf8(&opid).unwrap();
            return Ok(Some(self.get_by_id(id)?));
        }
        Ok(None)
    }

    pub fn stats(&self)->Result<(u64,u64,u64)>{
        let (mut pending, mut confirmed, mut redeemed) = (0u64,0u64,0u64);
        for kv in self.ops.iter(){
            let (_k,v)=kv?;
            let op:JournalOp = Self::de(&v);
            match op.status{
                OpStatus::Pending      => pending   += 1,
                OpStatus::PayoutSent   => pending   += 1, // считаем как pending
                OpStatus::Confirmed    => confirmed += 1,
                OpStatus::Redeemed     => redeemed  += 1,
                OpStatus::Failed       => {}
            }
        }
        Ok((pending, confirmed, redeemed))
    }
}

```

## FILE: /root/logos_lrb/node/src/bridge.rs  (size=1252b)
```rust
use axum::{
    extract::State,
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
    Json,
};
use serde::Deserialize;
use std::sync::Arc;
use crate::state::AppState;

#[derive(Deserialize)]
pub struct DepositReq {
    pub client_id: String,
    pub nonce: String,
    pub from_chain: String,
    pub from_txid: String,
    pub amount: String,
    pub ts: String,
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub client_id: String,
    pub nonce: String,
    pub to_chain: String,
    pub to_address: String,
    pub amount: String,
    pub ts: String,
}

pub async fn deposit_json(
    State(_st): State<Arc<AppState>>,
    _headers: HeaderMap,
    Json(_req): Json<DepositReq>
) -> impl IntoResponse {
    (StatusCode::OK, "deposit json")
}

pub async fn redeem_json(
    State(_st): State<Arc<AppState>>,
    _headers: HeaderMap,
    Json(_req): Json<RedeemReq>
) -> impl IntoResponse {
    (StatusCode::OK, "redeem json")
}

pub async fn deposit(
    State(_st): State<Arc<AppState>>,
    Json(_req): Json<DepositReq>
) -> impl IntoResponse {
    (StatusCode::OK, "deposit")
}

pub async fn redeem(
    State(_st): State<Arc<AppState>>,
    Json(_req): Json<RedeemReq>
) -> impl IntoResponse {
    (StatusCode::OK, "redeem")
}

```

## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```rust
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```

## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```rust
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```

## FILE: /root/logos_lrb/node/src/guard.rs  (size=3395b)
```rust
use axum::{
    http::{Request, StatusCode, HeaderValue},
    middleware::Next,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use rand::{thread_rng, Rng};
use std::{
    collections::HashMap,
    env,
    time::{Duration, Instant},
};

fn env_u64(k: &str, d: u64) -> u64 { env::var(k).ok().and_then(|v| v.parse().ok()).unwrap_or(d) }
fn env_ms(k: &str, d: u64) -> Duration { Duration::from_millis(env_u64(k, d)) }

static BURST: Lazy<u64>       = Lazy::new(|| env_u64("RL_BURST", 200));
static LIMIT: Lazy<u64>       = Lazy::new(|| env_u64("RL_LIMIT", 100));
static WINDOW: Lazy<Duration> = Lazy::new(|| env_ms("RL_WINDOW_MS", 10_000));
static JITTER_MAX: Lazy<u64>  = Lazy::new(|| env_u64("PHASE_JITTER_MS", 7));
static CLEAN_EVERY: Lazy<u64> = Lazy::new(|| env_u64("RL_CLEAN_EVERY", 10_000));

#[derive(Clone)]
struct Bucket { tokens: u64, last: Instant }
impl Bucket {
    fn new(now: Instant) -> Self { Self { tokens: *BURST, last: now } }
    fn allow(&mut self, now: Instant) -> bool {
        let elapsed = now.saturating_duration_since(self.last);
        if elapsed >= *WINDOW {
            self.tokens = (*BURST).min(*LIMIT);
            self.last = now;
        } else {
            let add = (*LIMIT as f64 * elapsed.as_secs_f64() / WINDOW.as_secs_f64()).floor() as u64;
            if add > 0 {
                self.tokens = (self.tokens + add).min(*BURST);
                self.last = now;
            }
        }
        if self.tokens > 0 { self.tokens -= 1; true } else { false }
    }
}

static RL_MAP: Lazy<Mutex<HashMap<String, Bucket>>> = Lazy::new(|| Mutex::new(HashMap::with_capacity(4096)));
static CALLS: Lazy<Mutex<u64>> = Lazy::new(|| Mutex::new(0));

fn identity<B>(req: &Request<B>) -> String {
    let h = req.headers();
    if let Some(k) = h.get("x-api-key").and_then(|v| v.to_str().ok()) { return format!("api:{k}"); }
    if let Some(ip) = h.get("x-forwarded-for").and_then(|v| v.to_str().ok()) {
        return format!("xff:{}", ip.split(',').next().unwrap_or(ip).trim());
    }
    if let Some(ip) = h.get("x-real-ip").and_then(|v| v.to_str().ok()) { return format!("rip:{}", ip.trim()); }
    "anon".into()
}

async fn phase_jitter() {
    let max = *JITTER_MAX;
    if max == 0 { return; }
    let d = thread_rng().gen_range(0..=max);
    if d > 0 { tokio::time::sleep(Duration::from_millis(d)).await; }
}

/// Боевой middleware: rate-limit + фазовый джиттер.
/// Возвращает 429 с Retry-After при превышении.
pub async fn rate_limit_mw<B>(req: Request<B>, next: Next<B>) -> Response {
    // учёт вызовов/чистка
    {
        let mut c = CALLS.lock();
        *c += 1;
        if *c % *CLEAN_EVERY == 0 {
            let now = Instant::now();
            RL_MAP.lock().retain(|_, b| now.saturating_duration_since(b.last) < *WINDOW * 4);
        }
    }

    let id = identity(&req);
    let now = Instant::now();
    let allowed = {
        let mut map = RL_MAP.lock();
        let b = map.entry(id).or_insert_with(|| Bucket::new(now));
        b.allow(now)
    };

    if !allowed {
        let mut resp = (StatusCode::TOO_MANY_REQUESTS, r#"{"error":"rate_limited"}"#).into_response();
        resp.headers_mut().insert("retry-after", HeaderValue::from_static("1"));
        return resp;
    }

    phase_jitter().await;
    next.run(req).await
}

```

## FILE: /root/logos_lrb/node/src/health.rs  (size=1382b)
```rust
//! Health endpoints: /livez (жив) и /readyz (готов)

use axum::{extract::State, http::StatusCode, Json};
use serde::Serialize;
use std::sync::Arc;
use crate::state::AppState;

/// Публичная структура, т.к. используется в сигнатуре `Json<Ready>`
#[derive(Serialize)]
pub struct Ready {
    pub db: bool,
    pub archive: bool,
    pub payout_cfg: bool,
}

/// /livez — просто «жив ли процесс»
pub async fn livez() -> &'static str { "ok" }

/// /readyz — готовность: sled открыт; archive (если настроен) доступен; payout-адаптер сконфигурирован
pub async fn readyz(State(st):State<Arc<AppState>>) -> (StatusCode, Json<Ready>) {
    // sled: быстрая эвристика — БД поднялась и восстановилась
    let db_ok = st.sled().was_recovered();
    // archive: настроен ли (при желании можно сделать query .get().await)
    let arch_ok = st.archive.is_some();
    // payout-конфиг
    let payout_ok = std::env::var("BRIDGE_PAYOUT_URL").is_ok() && std::env::var("LRB_BRIDGE_KEY").is_ok();

    let body = Ready{ db: db_ok, archive: arch_ok, payout_cfg: payout_ok };
    let status = if db_ok { StatusCode::OK } else { StatusCode::SERVICE_UNAVAILABLE };
    (status, Json(body))
}

```

## FILE: /root/logos_lrb/node/src/history_sled.rs  (size=1044b)
```rust
use axum::{extract::{Path, Query, State}, Json};
use serde::Deserialize;
use serde_json::Value;

use crate::AppState;

#[derive(Deserialize)]
pub struct HistQ { pub limit: Option<usize> }

pub async fn history_by_rid(
    State(st): State<AppState>,
    Path(rid): Path<String>,
    Query(q): Query<HistQ>,
) -> Json<Value> {
    let prefix = format!("hist:{rid}:").into_bytes();
    let mut tmp: Vec<(String, Value)> = Vec::new();
    for kv in st.ledger.iter_prefix(&prefix) {
        if let Ok((k, v)) = kv {
            let key = String::from_utf8_lossy(k.as_ref()).to_string();
            let evt: Value = serde_json::from_slice(v.as_ref()).unwrap_or(Value::Null);
            tmp.push((key, evt));
            if tmp.len() >= 10_000 { break; }
        }
    }
    tmp.sort_by(|a,b| a.0.cmp(&b.0));
    let take = q.limit.unwrap_or(200).min(1000);
    let items: Vec<_> = tmp.into_iter().rev().take(take)
        .map(|(k,v)| serde_json::json!({"key":k, "evt":v})).collect();
    Json(serde_json::json!({ "rid": rid, "items": items }))
}

```

## FILE: /root/logos_lrb/node/src/JSON  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/LE  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/lib.rs  (size=337b)
```rust
// Экспорт модулей, доступных как logos_node::*
pub mod metrics;
pub mod archive;
pub mod state;
pub mod bridge;
pub mod version;
pub mod api; // <-- нужно для sign_submit.rs

// Алиасы для совместимости
pub use version::json as version_json;
pub use version::json as version_get;

```

## FILE: /root/logos_lrb/node/src/main.rs  (size=6856b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/node/src/main.rs:15:5  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/main.rs:73:25  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/node/src/main.rs.bak.093626  (size=5520b)
```text
use axum::routing::post;
use axum::{routing::{get, post}, Router};
use tower::ServiceBuilder;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod api_extra;
mod api_extra;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router {
    ::<std::sync::Arc<crate::state::AppState>> Router::new()
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/debug_canon", post(api_extra::debug_canon))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/debug_canon", post(api_extra::debug_canon))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .merge(api_extra::routes(app_state.clone())).merge(api_extra::routes().with_state(app_state.clone())).route("/debug_canon", post(api_extra::debug_canon)).with_state(app_state)
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.102422  (size=5159b)
```text
use axum::{routing::{get, post}, Router};
use tower::ServiceBuilder;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router {
    ::<std::sync::Arc<crate::state::AppState>> Router::new()
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.102926  (size=5030b)
```text
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router {
    Router::new()
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.115338  (size=5124b)
```text
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router {
    Router::new()
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.115808  (size=5176b)
```text
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.120849  (size=5206b)
```text
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.121503  (size=5261b)
```text
use tower::make::Shared;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.122015  (size=5434b)
```text
use std::net::SocketAddr;
use axum::extract::connect_info::IntoMakeServiceWithConnectInfo;
use tower::make::Shared;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state).into_make_service_with_connect_info::<SocketAddr>()).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.122520  (size=5417b)
```text
use tokio::net::TcpListener;
use std::net::SocketAddr;
use axum::extract::connect_info::IntoMakeServiceWithConnectInfo;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state))).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.123043  (size=5446b)
```text
use tokio::net::TcpListener;
use std::net::SocketAddr;
use axum::extract::connect_info::IntoMakeServiceWithConnectInfo;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.124637  (size=5438b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state).into_service()).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.125221  (size=5491b)
```text
use tower::make::Shared;
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, Shared::new(router(app_state))).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.125641  (size=5453b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.131403  (size=5453b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.132240  (size=5453b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.133009  (size=5483b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::routing::{get, post};
use axum::Router;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::sync::Arc;
use tracing::{info, warn};

mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod state;
mod peers;
mod guard;
mod metrics;
mod version;
mod storage;
mod archive;
mod openapi;
mod auth;
mod stake;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez + /readyz
mod wallet;
mod producer;

fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new().with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone()).with_state(app_state.clone())
        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",  get(health::livez))       // liveness
        .route("/readyz", get(health::readyz))      // readiness
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/economy",         get(api::economy))
        .route("/history/:rid",    get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",      get(api::archive_blocks))
        .route("/archive/txs",         get(api::archive_txs))
        .route("/archive/history/:rid",get(api::archive_history))
        .route("/archive/tx/:txid",    get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        // реальный settle награды в ledger
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))
        // Оставляем и «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  body: axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge",  get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",     get(version::get))
        .route("/metrics",     get(metrics::prometheus))
        .route("/openapi.json",get(openapi::serve))

        // --- admin ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn")))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive
    if let Some(ar) = crate::archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve
    let addr = state::bind_addr();
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("logos_node listening on {addr}");
    axum::serve(listener, router(app_state)).await?;.await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.134537  (size=5655b)
```text
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::{routing::{get, post}, Router};
use std::sync::Arc;
use tracing::{info, warn};
use tracing_subscriber::{prelude::*, EnvFilter};

// --- модули узла ---
mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod peers;
mod state;
mod guard;
mod storage;
mod metrics;
mod openapi;
mod archive;
mod auth;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez /readyz
mod wallet;           // legacy routes() — если используются
mod stake;            // legacy routes() — если используются
mod producer;         // слот-продюсер

/// Маршрутизатор узла.
/// ВНИМАНИЕ: возвращает Router<Arc<AppState>> и задаёт state в САМОМ НАЧАЛЕ.
fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new()
        .with_state(app_state.clone())

        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",   get(health::livez))    // liveness
        .route("/readyz",  get(health::readyz))   // readiness
        .route("/head",    get(api::head))

        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))

        .route("/balance/:rid", get(api::balance))
        .route("/economy",      get(api::economy))
        .route("/history/:rid", get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",        get(api::archive_blocks))
        .route("/archive/txs",           get(api::archive_txs))
        .route("/archive/history/:rid",  get(api::archive_history))
        .route("/archive/tx/:txid",      get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))

        // Оставляем «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, body).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, body).await
            })
        )
        .route("/health/bridge", get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",      get(openapi::version))
        .route("/metrics",      get(metrics::prometheus))
        .route("/openapi.json", get(openapi::serve))

        // --- admin / set balance ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

/// Точка входа (Axum 0.7 канон): tokio-listener + serve(app).await?
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // app state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive (инициализируем backend при наличии конфига)
    if let Some(ar) = archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve (Axum 0.7 «канон»)
    let addr = state::bind_addr();
    let listener = TcpListener::bind(addr).await?;
    info!("logos_node listening on {}", addr);

    axum::serve(listener, router(app_state)).await?;

    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.135012  (size=5726b)
```text
use axum::routing::IntoMakeService;
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::{routing::{get, post}, Router};
use std::sync::Arc;
use tracing::{info, warn};
use tracing_subscriber::{prelude::*, EnvFilter};

// --- модули узла ---
mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod peers;
mod state;
mod guard;
mod storage;
mod metrics;
mod openapi;
mod archive;
mod auth;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez /readyz
mod wallet;           // legacy routes() — если используются
mod stake;            // legacy routes() — если используются
mod producer;         // слот-продюсер

/// Маршрутизатор узла.
/// ВНИМАНИЕ: возвращает Router<Arc<AppState>> и задаёт state в САМОМ НАЧАЛЕ.
fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new()
        .with_state(app_state.clone())

        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",   get(health::livez))    // liveness
        .route("/readyz",  get(health::readyz))   // readiness
        .route("/head",    get(api::head))

        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))

        .route("/balance/:rid", get(api::balance))
        .route("/economy",      get(api::economy))
        .route("/history/:rid", get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",        get(api::archive_blocks))
        .route("/archive/txs",           get(api::archive_txs))
        .route("/archive/history/:rid",  get(api::archive_history))
        .route("/archive/tx/:txid",      get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))

        // Оставляем «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, axum::Json(body)).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, axum::Json(body)).await
            })
        )
        .route("/health/bridge", get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",      get(version))
        .route("/metrics",      get(metrics::prometheus))
        .route("/openapi.json", get(openapi::serve))

        // --- admin / set balance ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

/// Точка входа (Axum 0.7 канон): tokio-listener + serve(app).await?
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // app state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive (инициализируем backend при наличии конфига)
    if let Some(ar) = archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve (Axum 0.7 «канон»)
    let addr = state::bind_addr();
    let listener = TcpListener::bind(addr).await?;
    info!("logos_node listening on {}", addr);

    axum::serve(listener, router(app_state).into_make_service()).await?;

    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.135356  (size=5866b)
```text
use axum::Router;
use axum::routing::{get, post};
use hyper::Server;
use axum::routing::IntoMakeService;
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tower::ServiceBuilder;
use axum::{routing::{get, post}, Router};
use std::sync::Arc;
use tracing::{info, warn};
use tracing_subscriber::{prelude::*, EnvFilter};

// --- модули узла ---
mod api;
mod bridge;
mod bridge_journal;
mod payout_adapter;   // адаптер выплат (используется в bridge)
mod admin;
mod gossip;
mod peers;
mod state;
mod guard;
mod storage;
mod metrics;
mod openapi;
mod archive;
mod auth;
mod stake_claim;      // реальный claim_settle (зачисление в ledger)
mod health;           // /livez /readyz
mod wallet;           // legacy routes() — если используются
mod stake;            // legacy routes() — если используются
mod producer;         // слот-продюсер

/// Маршрутизатор узла.
/// ВНИМАНИЕ: возвращает Router<Arc<AppState>> и задаёт state в САМОМ НАЧАЛЕ.
fn router(app_state: Arc<state::AppState>) -> Router<Arc<state::AppState>> {
    Router::new()
        .with_state(app_state.clone())

        // --- public ---
        .route("/healthz", get(api::healthz))
        .route("/livez",   get(health::livez))    // liveness
        .route("/readyz",  get(health::readyz))   // readiness
        .route("/head",    get(api::head))

        .route("/submit_tx",       post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))

        .route("/balance/:rid", get(api::balance))
        .route("/economy",      get(api::economy))
        .route("/history/:rid", get(api::history))

        // --- archive API (PG) ---
        .route("/archive/blocks",        get(api::archive_blocks))
        .route("/archive/txs",           get(api::archive_txs))
        .route("/archive/history/:rid",  get(api::archive_history))
        .route("/archive/tx/:txid",      get(api::archive_tx))

        // --- staking wrappers (совместимость с фронтом) ---
        .route("/stake/delegate",   post(api::stake_delegate))
        .route("/stake/undelegate", post(api::stake_undelegate))
        .route("/stake/claim",      post(api::stake_claim))
        .route("/stake/my/:rid",    get(api::stake_my))
        .route("/stake/claim_settle", post(stake_claim::claim_settle))

        // --- bridge (durable + payout, Send-safe) ---
        // JSON endpoints для mTLS+HMAC периметра (Nginx rewrites → сюда)
        .route("/bridge/deposit_json", post(bridge::deposit_json))
        .route("/bridge/redeem_json",  post(bridge::redeem_json))

        // Оставляем «обычные» (внутренние) эндпоинты через безопасные замыкания
        .route(
            "/bridge/deposit",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::DepositReq>| async move {
                bridge::deposit(st, axum::Json(body)).await
            })
        )
        .route(
            "/bridge/redeem",
            post(|st: axum::extract::State<Arc<state::AppState>>,
                  axum::Json(body): axum::Json<bridge::RedeemReq>| async move {
                bridge::redeem(st, axum::Json(body)).await
            })
        )
        .route("/health/bridge", get(bridge::health))

        // --- version / metrics / openapi ---
        .route("/version",      get(version))
        .route("/metrics",      get(metrics::prometheus))
        .route("/openapi.json", get(openapi::serve))

        // --- admin / set balance ---
        .route("/admin/set_balance", post(admin::set_balance))
        .route("/admin/bump_nonce",  post(admin::bump_nonce))
        .route("/admin/set_nonce",   post(admin::set_nonce))
        .route("/admin/mint",        post(admin::mint))
        .route("/admin/burn",        post(admin::burn))

        // --- legacy (если используются) ---
        .merge(wallet::routes())
        .merge(stake::routes())

        // --- layers/state ---
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(axum::middleware::from_fn(guard::rate_limit_mw))
                .layer(axum::middleware::from_fn(metrics::track))
        )
}

/// Точка входа (Axum 0.7 канон): tokio-listener + serve(app).await?
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .init();

    // secrets/keys
    auth::assert_secrets_on_start().expect("secrets missing");

    // app state
    let app_state = Arc::new(state::AppState::new()?);

    // optional archive (инициализируем backend при наличии конфига)
    if let Some(ar) = archive::Archive::new_from_env().await {
        unsafe {
            let p = Arc::as_ptr(&app_state) as *mut state::AppState;
            (*p).archive = Some(ar);
        }
        info!("archive backend initialized");
    } else {
        warn!("archive disabled");
    }

    // producer
    info!("producer start");
    let _producer = producer::run(app_state.clone());

    // bridge retry worker
    tokio::spawn(bridge::retry_worker(app_state.clone()));

    // bind & serve (Axum 0.7 «канон»)
    let addr = state::bind_addr();
    let listener = TcpListener::bind(addr).await?;
    info!("logos_node listening on {}", addr);

    Server::bind(axum::serve(listener, router(app_state).into_make_service()).await?;addr).serve(router(app_state).into_make_service()).await?;

    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/main.rs.bak.20250922T042341Z  (size=7211b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/node/src/main.rs.bak.20250922T044532Z  (size=7088b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/node/src/metrics.rs  (size=3544b)
```rust
use once_cell::sync::Lazy;
use prometheus::{
    Encoder, HistogramVec, IntCounter, IntCounterVec, IntGauge, TextEncoder,
    register_histogram_vec, register_int_counter, register_int_counter_vec, register_int_gauge,
};
use std::time::Instant;
use axum::{
    http::{header, HeaderValue, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};
use axum::http::Request as HttpRequest;
use axum::body::Body;

pub static REQUESTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "logos_http_requests_total","HTTP requests total",&["method","path","code"]
    ).expect("register REQUESTS_TOTAL")
});
pub static HTTP_LATENCY: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "logos_http_duration_seconds","HTTP request latency",&["method","path"]
    ).expect("register HTTP_LATENCY")
});
pub static TX_ACCEPTED: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!("logos_tx_accepted_total","Accepted transactions total")
    .expect("register TX_ACCEPTED")
});
pub static TX_REJECTED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "logos_tx_rejected_total","Rejected transactions total",&["reason"]
    ).expect("register TX_REJECTED")
});
pub static BLOCKS_PRODUCED: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!("logos_blocks_produced_total","Produced blocks total")
    .expect("register BLOCKS_PRODUCED")
});
pub static HEAD_HEIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!("logos_head_height","Current head height")
    .expect("register HEAD_HEIGHT")
});
pub static FINALIZED_HEIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!("logos_finalized_height","Current finalized height")
    .expect("register FINALIZED_HEIGHT")
});
pub static ADMIN_OPS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!("logos_admin_ops_total","Admin operations total",&["op"])
    .expect("register ADMIN_OPS_TOTAL")
});

// безопасная конверсия u64 -> i64 (для IntGauge)
#[inline]
fn to_i64(v: u64) -> i64 { i64::try_from(v).unwrap_or(i64::MAX) }

pub fn inc_tx_accepted(){ TX_ACCEPTED.inc(); }
pub fn inc_tx_rejected(reason:&str){ TX_REJECTED.with_label_values(&[reason]).inc(); }
pub fn inc_block_produced(){ BLOCKS_PRODUCED.inc(); }
pub fn set_chain(head_u: u64, finalized_u: u64){
    HEAD_HEIGHT.set(to_i64(head_u));
    FINALIZED_HEIGHT.set(to_i64(finalized_u));
}
pub fn inc_total(op:&str){ ADMIN_OPS_TOTAL.with_label_values(&[op]).inc(); }

// Axum 0.7: Next без дженерика, Request — конкретный Request<Body>
pub async fn track(req: HttpRequest<Body>, next: Next) -> Response {
    let method = req.method().clone();
    let path = req.uri().path().to_string();
    let start = Instant::now();
    let res = next.run(req).await;
    let code = res.status().as_u16().to_string();
    REQUESTS_TOTAL.with_label_values(&[method.as_str(),&path,&code]).inc();
    HTTP_LATENCY.with_label_values(&[method.as_str(),&path]).observe(start.elapsed().as_secs_f64());
    res
}

pub async fn prometheus() -> Response {
    let metric_families = prometheus::gather();
    let mut buf = Vec::new();
    let encoder = TextEncoder::new();

    if let Err(e) = encoder.encode(&metric_families, &mut buf) {
        return (StatusCode::INTERNAL_SERVER_ERROR, format!("encode error: {e}")).into_response();
    }

    (
        [(header::CONTENT_TYPE, HeaderValue::from_static("text/plain; charset=utf-8"))],
        buf
    ).into_response()
}

```

## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```json
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi/openapi.json  (size=8704b)
```json
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB API", "version": "0.1.0" },
  "paths": {
    "/healthz": {
      "get": { "summary": "health", "responses": { "200": { "description": "OK" } } }
    },
    "/livez": {
      "get": { "summary": "liveness", "responses": { "200": { "description": "alive" } } }
    },
    "/readyz": {
      "get": {
        "summary": "readiness",
        "responses": {
          "200": { "description": "ready" },
          "503": { "description": "not ready" }
        }
      }
    },
    "/version": { "get": { "summary": "build info", "responses": { "200": { "description": "OK" } } } },
    "/metrics": { "get": { "summary": "prometheus metrics", "responses": { "200": { "description": "OK" } } } },

    "/head": {
      "get": {
        "summary": "current head heights",
        "responses": {
          "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" } } } }
        }
      }
    },

    "/submit_tx": {
      "post": {
        "summary": "submit transaction (Ed25519 verified)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TxIn" } } } },
        "responses": {
          "200": { "description": "accepted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" } } } },
          "401": { "description": "bad signature" },
          "409": { "description": "nonce reuse" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "submit batch of transactions (Ed25519 verified)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitBatchReq" } } } },
        "responses": {
          "200": { "description": "per-item results", "content": { "application/json": { "schema": { "type": "array", "items": { "$ref": "#/components/schemas/SubmitBatchItem" } } } } }
        }
      }
    },

    "/archive/blocks": {
      "get": {
        "summary": "recent blocks",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "before_height", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/txs": {
      "get": {
        "summary": "recent txs",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "rid", "in": "query", "schema": { "type": "string" } },
          { "name": "before_ts", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/history/{rid}": {
      "get": {
        "summary": "history by rid",
        "parameters": [ { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/tx/{txid}": {
      "get": {
        "summary": "tx by id",
        "parameters": [ { "name": "txid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" }, "404": { "description": "not found" } }
      }
    },

    "/stake/delegate": {
      "post": {
        "summary": "delegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/undelegate": {
      "post": {
        "summary": "undelegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/claim": {
      "post": {
        "summary": "claim rewards (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/my/{rid}": {
      "get": {
        "summary": "my delegations + rewards (compat wrapper)",
        "parameters": [ { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/claim_settle": {
      "post": {
        "summary": "settle reward into ledger",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/ClaimSettle" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },

    "/bridge/deposit_json": {
      "post": {
        "summary": "bridge deposit (mTLS + HMAC)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeDeposit" } } } },
        "responses": { "200": { "description": "idempotent OK" }, "202": { "description": "queued/retry" }, "401": { "description": "unauthorized (key/HMAC/nonce)" } }
      }
    },
    "/bridge/redeem_json": {
      "post": {
        "summary": "bridge redeem (mTLS + HMAC)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeRedeem" } } } },
        "responses": { "200": { "description": "ok" }, "202": { "description": "queued/retry" }, "401": { "description": "unauthorized (key/HMAC/nonce)" } }
      }
    }
  },

  "components": {
    "schemas": {
      "Head": {
        "type": "object",
        "required": ["height","finalized"],
        "properties": {
          "height":   { "type": "integer", "format": "uint64" },
          "finalized":{ "type": "integer", "format": "uint64" }
        }
      },
      "Balance": {
        "type": "object",
        "required": ["rid","balance","nonce"],
        "properties": {
          "rid":     { "type": "string" },
          "balance": { "type": "integer", "format": "uint128" },
          "nonce":   { "type": "integer", "format": "uint64" }
        }
      },
      "TxIn": {
        "type": "object",
        "required": ["from","to","amount","nonce","sig_hex"],
        "properties": {
          "from":    { "type": "string", "description": "base58(pubkey)" },
          "to":      { "type": "string" },
          "amount":  { "type": "integer", "format": "uint64" },
          "nonce":   { "type": "integer", "format": "uint64" },
          "sig_hex": { "type": "string" },
          "memo":    { "type": "string", "nullable": true }
        }
      },
      "SubmitResult": {
        "type": "object",
        "required": ["ok","info"],
        "properties": {
          "ok":   { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" }
        }
      },
      "SubmitBatchReq": {
        "type": "object",
        "required": ["txs"],
        "properties": {
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/TxIn" } }
        }
      },
      "SubmitBatchItem": {
        "type": "object",
        "required": ["ok","info","index"],
        "properties": {
          "ok":    { "type": "boolean" },
          "txid":  { "type": "string", "nullable": true },
          "info":  { "type": "string" },
          "index": { "type": "integer" }
        }
      },
      "StakeAction": {
        "type": "object",
        "required": ["rid"],
        "properties": {
          "rid":       { "type": "string" },
          "validator": { "type": "string" },
          "amount":    { "type": "integer", "format": "uint64", "nullable": true }
        }
      },
      "ClaimSettle": {
        "type": "object",
        "required": ["rid","amount"],
        "properties": {
          "rid":    { "type": "string" },
          "amount": { "type": "integer", "format": "uint64" }
        }
      },
      "BridgeDeposit": {
        "type": "object",
        "required": ["rid","amount","ext_txid"],
        "properties": {
          "rid":      { "type": "string" },
          "amount":   { "type": "integer", "format": "uint64" },
          "ext_txid": { "type": "string" }
        }
      },
      "BridgeRedeem": {
        "type": "object",
        "required": ["rid","amount","ext_txid"],
        "properties": {
          "rid":      { "type": "string" },
          "amount":   { "type": "integer", "format": "uint64" },
          "ext_txid": { "type": "string" }
        }
      }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi/openapi.json.bak  (size=6276b)
```text
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB API", "version": "0.1.0" },
  "paths": {
    "/healthz": { "get": { "summary": "health", "responses": { "200": { "description": "OK" } } } },
    "/version": { "get": { "summary": "build info", "responses": { "200": { "description": "OK" } } } },

    "/head": {
      "get": {
        "summary": "current head heights",
        "responses": {
          "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" } } } }
        }
      }
    },

    "/metrics": { "get": { "summary": "prometheus metrics", "responses": { "200": { "description": "OK" } } } },

    "/submit_tx": {
      "post": {
        "summary": "submit transaction (Ed25519 verified)",
        "requestBody": {
          "required": true,
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TxIn" } } }
        },
        "responses": {
          "200": { "description": "accepted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" } } } },
          "401": { "description": "bad signature" },
          "409": { "description": "nonce reuse" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "submit batch of transactions (Ed25519 verified)",
        "requestBody": {
          "required": true,
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitBatchReq" } } }
        },
        "responses": {
          "200": {
            "description": "per-item results",
            "content": { "application/json": { "schema": { "type": "array", "items": { "$ref": "#/components/schemas/SubmitBatchItem" } } } }
          }
        }
      }
    },

    "/archive/blocks": {
      "get": {
        "summary": "recent blocks",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "before_height", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },

    "/archive/txs": {
      "get": {
        "summary": "recent txs",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "rid", "in": "query", "schema": { "type": "string" } },
          { "name": "before_ts", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },

    "/archive/history/{rid}": {
      "get": {
        "summary": "history by rid",
        "parameters": [
          { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },

    "/archive/tx/{txid}": {
      "get": {
        "summary": "tx by id",
        "parameters": [
          { "name": "txid", "in": "path", "required": true, "schema": { "type": "string" } }
        ],
        "responses": {
          "200": { "description": "OK" },
          "404": { "description": "not found" }
        }
      }
    },

    "/stake/delegate": {
      "post": {
        "summary": "delegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/undelegate": {
      "post": {
        "summary": "undelegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/claim": {
      "post": {
        "summary": "claim rewards (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/my/{rid}": {
      "get": {
        "summary": "my delegations + rewards (compat wrapper)",
        "parameters": [
          { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    }
  },

  "components": {
    "schemas": {
      "Head": {
        "type": "object",
        "required": ["height","finalized"],
        "properties": {
          "height":   { "type": "integer", "format": "uint64" },
          "finalized":{ "type": "integer", "format": "uint64" }
        }
      },

      "TxIn": {
        "type": "object",
        "required": ["from","to","amount","nonce","sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "base58(pubkey)" },
          "to":     { "type": "string" },
          "amount": { "type": "integer", "format": "uint64" },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string" },
          "memo":   { "type": "string", "nullable": true }
        }
      },

      "SubmitResult": {
        "type": "object",
        "required": ["ok","info"],
        "properties": {
          "ok":   { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" }
        }
      },

      "SubmitBatchReq": {
        "type": "object",
        "required": ["txs"],
        "properties": {
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/TxIn" } }
        }
      },

      "SubmitBatchItem": {
        "type": "object",
        "required": ["ok","info","index"],
        "properties": {
          "ok":   { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" },
          "index":{ "type": "integer" }
        }
      },

      "StakeAction": {
        "type": "object",
        "required": ["rid"],
        "properties": {
          "rid":       { "type": "string" },
          "validator": { "type": "string" },
          "amount":    { "type": "integer", "format": "uint64", "nullable": true }
        }
      }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi.rs  (size=441b)
```rust
use axum::response::{IntoResponse, Response};
use axum::http::{HeaderValue, StatusCode};

static SPEC: &str = include_str!("../openapi/openapi.json");

pub async fn serve() -> Response {
    let mut resp = (StatusCode::OK, SPEC).into_response();
    let headers = resp.headers_mut();
    let _ = headers.insert(
        axum::http::header::CONTENT_TYPE,
        HeaderValue::from_static("application/json; charset=utf-8"),
    );
    resp
}

```

## FILE: /root/logos_lrb/node/src/payout_adapter.rs  (size=1748b)
```rust
//! External payout adapter for rToken redeem (HTTP).
//! ENV:
//!   BRIDGE_PAYOUT_URL   — базовый URL payout-сервиса (https://bridge.example.com)
//!   BRIDGE_PAYOUT_PATH  — относительный путь (по умолчанию: /api/payout)
//!   LRB_BRIDGE_KEY      — общий секрет (заголовок X-Bridge-Key)

use anyhow::{Result,anyhow};
use reqwest::Client;
use serde::Serialize;

#[derive(Clone)]
pub struct PayoutAdapter{
    base: String,
    path: String,
    key:  String,
    http: Client,
}

#[derive(Serialize)]
struct PayoutReq<'a>{
    rid:    &'a str,
    amount: u64,
    ext_txid: &'a str,
}

impl PayoutAdapter{
    pub fn from_env() -> Result<Self>{
        let base = std::env::var("BRIDGE_PAYOUT_URL")
            .map_err(|_| anyhow!("BRIDGE_PAYOUT_URL not set"))?;
        let path = std::env::var("BRIDGE_PAYOUT_PATH").unwrap_or_else(|_| "/api/payout".to_string());
        let key  = std::env::var("LRB_BRIDGE_KEY")
            .map_err(|_| anyhow!("LRB_BRIDGE_KEY not set"))?;
        Ok(Self{ base, path, key, http: Client::new() })
    }

    #[inline]
    fn url(&self)->String { format!("{}{}", self.base.trim_end_matches('/'), self.path) }

    pub async fn send_payout(&self, rid:&str, amount:u64, ext_txid:&str) -> Result<()>{
        let body = PayoutReq{ rid, amount, ext_txid };
        let resp = self.http.post(self.url())
            .header("X-Bridge-Key", &self.key)
            .json(&body)
            .send().await?;

        let status = resp.status();
        let text   = resp.text().await.unwrap_or_default();

        if !status.is_success(){
            return Err(anyhow!("payout_http_{}: {}", status.as_u16(), text));
        }
        Ok(())
    }
}

```

## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```rust
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```

## FILE: /root/logos_lrb/node/src/producer.rs  (size=1701b)
```rust
use std::sync::Arc;
use tokio::time::{sleep, Duration};
use tracing::{info, warn};
use blake3::Hasher;
use lrb_core::ledger::now_ms;
use crate::state::AppState;
use crate::metrics;

pub fn run(state: Arc<AppState>) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let slot_ms: u64 = std::env::var("LRB_SLOT_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(2000);
        loop {
            {
                let l = state.ledger.write().await;
                let h_now = l.height().unwrap_or(0);
                let next_h = h_now.saturating_add(1);

                let prev = l.get_block_by_height(h_now).map(|v| v.block_hash).unwrap_or_default();
                let ts = now_ms() as u128;

                let mut hasher = Hasher::new();
                hasher.update(prev.as_bytes());
                hasher.update(&next_h.to_be_bytes());
                hasher.update(&ts.to_be_bytes());
                let hash = hasher.finalize().to_hex().to_string();

                if let Err(e) = l.set_head(next_h, &hash) {
                    warn!("producer: set_head failed: {e}");
                } else {
                    let finalized = next_h.saturating_sub(1);
                    if next_h > 1 {
                        if let Err(e) = l.set_finalized(finalized) {
                            warn!("producer: set_finalized failed: {e}");
                        }
                    }
                    metrics::inc_block_produced();
                    metrics::set_chain(next_h, finalized);
                    info!("produced block {next_h} ({hash})");
                }
            }
            sleep(Duration::from_millis(slot_ms)).await;
        }
    })
}

```

## FILE: /root/logos_lrb/node/src/stake_api.rs  (size=2668b)
```rust
use axum::{extract::State, Json};
use serde_json::Value;
use crate::AppState;

fn parse_req(v:&Value)->Option<(String,u64)>{
    let o=v.as_object()?;
    let rid = o.get("rid").or_else(||o.get("validator")).and_then(|x|x.as_str()).unwrap_or("").to_string();
    let amt = o.get("amount").and_then(|x|x.as_u64()).or_else(||o.get("value").and_then(|x|x.as_u64())).unwrap_or(0);
    if rid.is_empty() || amt==0 { return None; }
    Some((rid,amt))
}

pub async fn stake_pending(State(st): State<AppState>, axum::extract::Path(rid): axum::extract::Path<String>) -> Json<Value> {
    Json(serde_json::json!({"rid":rid,"pending":st.ledger.stake_pending_of(&rid)}))
}
pub async fn delegate(State(st): State<AppState>, Json(body): Json<Value>) -> Json<Value> {
    if let Some((rid,amount)) = parse_req(&body) {
        let ok = st.ledger.stake_delegate(&rid, amount).unwrap_or(false);
        return Json(serde_json::json!({"ok":ok,"rid":rid,"amount":amount}));
    }
    Json(serde_json::json!({"ok":false,"error":"bad_request"}))
}
pub async fn undelegate(State(st): State<AppState>, Json(body): Json<Value>) -> Json<Value> {
    if let Some((rid,amount)) = parse_req(&body) {
        let ok = st.ledger.stake_undelegate(&rid, amount).unwrap_or(false);
        return Json(serde_json::json!({"ok":ok,"rid":rid,"amount":amount}));
    }
    Json(serde_json::json!({"ok":false,"error":"bad_request"}))
}
pub async fn claim(State(st): State<AppState>, Json(body): Json<Value>) -> Json<Value> {
    let rid = body.get("rid").or_else(||body.get("validator")).and_then(|x|x.as_str()).unwrap_or("").to_string();
    if rid.is_empty(){ return Json(serde_json::json!({"ok":false,"error":"bad_request"})); }
    let claimed = st.ledger.stake_claim(&rid).unwrap_or(0);
    Json(serde_json::json!({"ok":claimed>0,"rid":rid,"claimed":claimed}))
}
pub async fn summary(State(st): State<AppState>, axum::extract::Path(rid): axum::extract::Path<String>) -> Json<Value> {
    let delegated = st.ledger.stake_pending_of(&rid);
    let prefix = format!("hist:{rid}:").into_bytes();
    let mut entries:u64 = 0; let mut after_claim=true;
    for kv in st.ledger.iter_prefix(&prefix) {
        if let Ok((_k,v)) = kv {
            if let Ok(evt) = serde_json::from_slice::<Value>(v.as_ref()) {
                match evt.get("type").and_then(|x|x.as_str()) {
                    Some("stake_claim") => { entries=0; after_claim=true; }
                    Some("stake_delegate") if after_claim => entries+=1,
                    _ => {}
                }
            }
        }
    }
    Json(serde_json::json!({ "rid":rid, "delegated":delegated, "entries":entries, "claimable":delegated }))
}

```

## FILE: /root/logos_lrb/node/src/stake_claim.rs  (size=938b)
```rust
use axum::{extract::State, http::StatusCode, Json};
use serde::Deserialize;
use std::sync::Arc;
use crate::state::AppState;

#[derive(Deserialize)]
pub struct ClaimReq { pub rid:String, pub amount:u64 }

/// Финализация награды: зачисляем в ledger (при необходимости добавь запись в историю)
pub async fn claim_settle(State(st):State<Arc<AppState>>, Json(req):Json<ClaimReq>) -> (StatusCode,String){
    {
        let l = st.ledger.write().await;
        let bal = l.get_balance(&req.rid).unwrap_or(0);
        let newb = bal.saturating_add(req.amount);
        if let Err(e) = l.set_balance(&req.rid, newb as u128) {
            return (StatusCode::INTERNAL_SERVER_ERROR, format!("{{\"error\":\"{e}\"}}"));
        }
        // Если хочешь — вставь спец-tx «reward» в историю (StoredTx).
    }
    (StatusCode::OK, "{\"ok\":true}".into())
}

```

## FILE: /root/logos_lrb/node/src/stake.rs  (size=7704b)
```rust
use axum::{routing::{get, post}, Router, extract::{State, Path}, Json};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tracing::{info, warn};
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use crate::state::AppState;

const RATE_NUM: u128 = 1;      // 1 микро-LGN за высоту на каждые RATE_DEN единиц
const RATE_DEN: u128 = 100_000; // тюнимо (пример: 1e5 = 0.000001 за 1e5 делегата/высоту)

#[derive(Deserialize)]
pub struct StakeTxIn {
    pub from: String,
    pub op: String,       // "delegate" | "undelegate" | "claim"
    pub validator: String,
    pub amount: u64,
    pub nonce: u64,
    pub sig_hex: String,
}

#[derive(Serialize)]
pub struct StakeResp { pub ok: bool, pub info: String }

#[derive(Serialize)]
pub struct DelegRow { pub validator:String, pub amount:u64, pub since_height: Option<u64> }

#[derive(Serialize)]
pub struct RewardRow { pub validator:String, pub pending:u64, pub last_height: Option<u64> }

pub fn routes() -> Router<Arc<AppState>> {
    Router::new()
        .route("/stake/submit", post(stake_submit))
        .route("/stake/delegations/:rid", get(delegations))
        .route("/stake/rewards/:rid",     get(rewards))
}

fn build_msg(from:&str, op:&str, validator:&str, amount:u64, nonce:u64) -> Vec<u8> {
    format!("{}|{}|{}|{}|{}", from, op, validator, amount, nonce).into_bytes()
}

fn vk_from_base58_rid(rid:&str) -> anyhow::Result<VerifyingKey> {
    let pk = bs58::decode(rid).into_vec().map_err(|_| anyhow::anyhow!("bad rid b58"))?;
    let arr:[u8;32] = pk.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad pubkey len"))?;
    let vk = VerifyingKey::from_bytes(&arr).map_err(|_| anyhow::anyhow!("bad ed25519 pubkey"))?;
    Ok(vk)
}

// начисление pending по текущей высоте
fn accrue_pending(db:&sled::Db, from:&str, val:&str, now_h:u64) {
    let amt_key   = format!("staking:deleg:{}:{}", from, val);
    let last_key  = format!("staking:last:{}:{}", from, val);
    let pend_key  = format!("staking:pend:{}:{}", from, val);
    let amt = db.get(amt_key.as_bytes()).ok().flatten()
        .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]))).unwrap_or(0);
    if amt==0 { // нечего начислять
        db.insert(last_key.as_bytes(), &now_h.to_be_bytes()).ok(); return;
    }
    let last = db.get(last_key.as_bytes()).ok().flatten()
        .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]))).unwrap_or(now_h);
    let delta_h = now_h.saturating_sub(last);
    if delta_h==0 { return; }

    let prev_pending = db.get(pend_key.as_bytes()).ok().flatten()
        .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]))).unwrap_or(0);
    // простая формула: pending += delta_h * amt * RATE_NUM / RATE_DEN
    let add = ((delta_h as u128) * (amt as u128) * RATE_NUM / RATE_DEN) as u64;
    let new_pending = prev_pending.saturating_add(add);

    db.insert(pend_key.as_bytes(), &new_pending.to_be_bytes()).ok();
    db.insert(last_key.as_bytes(), &now_h.to_be_bytes()).ok();
}

async fn stake_submit(State(app): State<Arc<AppState>>, Json(tx): Json<StakeTxIn>) -> Json<StakeResp> {
    // verify
    let vk = match vk_from_base58_rid(&tx.from) { Ok(v)=>v, Err(e)=>return Json(StakeResp{ok:false,info:format!("bad rid/pubkey: {e}")}) };
    let msg = build_msg(&tx.from,&tx.op,&tx.validator,tx.amount,tx.nonce);
    let sig_bytes = match hex::decode(tx.sig_hex.trim()){ Ok(v)=>v, Err(_)=>return Json(StakeResp{ok:false,info:"bad signature hex".into()}) };
    let sig = match Signature::from_slice(&sig_bytes){ Ok(s)=>s, Err(_)=>return Json(StakeResp{ok:false,info:"bad signature size".into()}) };
    if let Err(e)=vk.verify(&msg,&sig){ warn!("stake verify failed: {e}"); return Json(StakeResp{ok:false,info:"bad signature".into()}); }

    // state
    let db = app.sled();
    let height = app.ledger.read().await.height().unwrap_or(0);

    // сначала доначислим pending до текущей высоты
    accrue_pending(&db, &tx.from, &tx.validator, height);

    let amt_key   = format!("staking:deleg:{}:{}", &tx.from, &tx.validator);
    let since_key = format!("staking:since:{}:{}", &tx.from, &tx.validator);
    let pend_key  = format!("staking:pend:{}:{}", &tx.from, &tx.validator);

    let prev_amt = db.get(amt_key.as_bytes()).ok().flatten()
        .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]))).unwrap_or(0);

    let new_amt = match tx.op.as_str() {
        "delegate"   => prev_amt.saturating_add(tx.amount),
        "undelegate" => prev_amt.saturating_sub(tx.amount),
        "claim"      => {
            // списываем pending в ноль; интеграцию с ledger (зачислить на баланс) добавим следующим патчем
            db.insert(pend_key.as_bytes(), &0u64.to_be_bytes()).ok();
            prev_amt
        },
        _ => return Json(StakeResp{ok:false, info:"bad op".into()}),
    };

    db.insert(amt_key.as_bytes(), &new_amt.to_be_bytes()).ok();
    if tx.op=="delegate" && db.get(since_key.as_bytes()).ok().flatten().is_none() {
        db.insert(since_key.as_bytes(), &height.to_be_bytes()).ok();
    }
    db.flush_async().await.ok();

    info!("stake ok op={} from={} val={} amt={} nonce={} h={}", tx.op, tx.from, tx.validator, tx.amount, tx.nonce, height);
    Json(StakeResp{ ok:true, info:"accepted".into() })
}

async fn delegations(State(app): State<Arc<AppState>>, Path(rid): Path<String>) -> Json<Vec<DelegRow>> {
    let db = app.sled();
    let prefix = format!("staking:deleg:{}:", rid);
    let mut out = Vec::new();
    for kv in db.scan_prefix(prefix.as_bytes()) {
        if let Ok((k,v)) = kv {
            let key_str = String::from_utf8_lossy(k.as_ref());
            let validator = key_str.rsplit(':').next().unwrap_or("").to_string();
            let amount = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            let since_key = format!("staking:since:{}:{}", rid, validator);
            let since = db.get(since_key.as_bytes()).ok().flatten()
                .map(|b| u64::from_be_bytes(b.as_ref().try_into().unwrap_or([0u8;8])));
            if amount>0 { out.push(DelegRow{ validator, amount, since_height: since }); }
        }
    }
    Json(out)
}

async fn rewards(State(app): State<Arc<AppState>>, Path(rid): Path<String>) -> Json<Vec<RewardRow>> {
    let db = app.sled();
    let now_h = app.ledger.read().await.height().unwrap_or(0);

    // на лету доначислим для всех пар rid:*
    let prefix = format!("staking:deleg:{}:", rid);
    for kv in db.scan_prefix(prefix.as_bytes()) {
        if let Ok((k,_)) = kv {
            let key_str = String::from_utf8_lossy(k.as_ref());
            let validator = key_str.rsplit(':').next().unwrap_or("");
            accrue_pending(&db, &rid, validator, now_h);
        }
    }

    let mut out = Vec::new();
    let pend_prefix = format!("staking:pend:{}:", rid);
    for kv in db.scan_prefix(pend_prefix.as_bytes()) {
        if let Ok((k,v)) = kv {
            let key_str = String::from_utf8_lossy(k.as_ref());
            let validator = key_str.rsplit(':').next().unwrap_or("").to_string();
            let pending = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            let last_key = format!("staking:last:{}:{}", rid, validator);
            let last = db.get(last_key.as_bytes()).ok().flatten()
                .map(|b| u64::from_be_bytes(b.as_ref().try_into().unwrap_or([0u8;8])));
            out.push(RewardRow{ validator, pending, last_height: last });
        }
    }
    Json(out)
}

```

## FILE: /root/logos_lrb/node/src/staking.rs  (size=339b)
```rust
use time::{format_description::well_known::Rfc3339, OffsetDateTime};

pub fn utc_now_rfc3339() -> String {
    OffsetDateTime::now_utc()
        .format(&Rfc3339)
        .unwrap_or_else(|_| "n/a".into())
}

// остальные функции стейкинга можешь оставить, главное — не тянуть chrono

```

## FILE: /root/logos_lrb/node/src/state.rs  (size=850b)
```rust
use anyhow::Result;
use std::sync::Arc;
use tokio::sync::RwLock;
use lrb_core::ledger::Ledger;
use crate::archive::Archive;

pub struct AppState {
    pub ledger: Arc<RwLock<Ledger>>,
    pub archive: Option<Arc<Archive>>,
}

impl AppState {
    pub fn new() -> Result<Self> {
        let ledger = Ledger::open("/var/lib/logos/data.sled")?;
        Ok(Self {
            ledger: Arc::new(RwLock::new(ledger)),
            archive: None,
        })
    }

    pub fn with_archive(mut self, archive: Option<Arc<Archive>>) -> Self {
        self.archive = archive;
        self
    }

    /// Временная совместимость для старых модулей (лучше не использовать в новом коде).
    pub fn sled(&self) -> sled::Db {
        sled::open("/var/lib/logos/data.sled").expect("sled open")
    }
}

```

## FILE: /root/logos_lrb/node/src/storage.rs  (size=1031b)
```rust
use serde::{Deserialize, Serialize};

/// Вход транзакции — соответствуем полям, которые ожидает api.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TxIn {
    pub from: String,      // RID отправителя
    pub to: String,        // RID получателя
    pub amount: u64,       // количество
    pub nonce: u64,        // обязательный
    pub memo: Option<String>,
    pub sig_hex: String,   // подпись в hex
}

/// Элемент истории для /history/:rid
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub txid: String,
    pub height: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub ts: Option<u64>,
}

/// Состояние аккаунта (минимум, который использует api.rs)
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

```

## FILE: /root/logos_lrb/node/src/types.rs  (size=430b)
```rust
use serde::{Deserialize, Serialize};
use lrb_core::types::Rid;

#[derive(Debug, Deserialize)]
pub struct SubmitTxRequest {
    pub from: Rid,             // base58(pk)
    pub to: Rid,               // base58(pk)
    pub amount: u64,
    pub nonce: u64,
    pub signature_hex: String, // 64 байта ed25519 в hex
    pub ts_ms: Option<i64>,
}

#[derive(Debug, Serialize)]
pub struct SubmitTxResponse {
    pub txid: String,
}

```

## FILE: /root/logos_lrb/node/src/version.rs  (size=420b)
```rust
// Константы генерируются build.rs в $OUT_DIR/build_info.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

pub fn json() -> String {
    let dirty = if GIT_DIRTY == "1" { "+" } else { "" };
    format!(
        r#"{{"version":"{pkg}","git":"{git}{dirty}","build_ts":"{ts}"}}"#,
        pkg = PKG_VERSION,
        git = GIT_COMMIT_SHORT,
        dirty = dirty,
        ts = BUILD_TS
    )
}

```

## FILE: /root/logos_lrb/node/src/wallet.rs  (size=913b)
```rust
use axum::{routing::post, Router, extract::{State}, Json};
use serde::Deserialize;
use std::sync::Arc;
use tracing::info;
use crate::state::AppState;

#[derive(Deserialize)]
pub struct RegisterIn { pub rid: String, pub pub_hex: String }

#[derive(serde::Serialize)] pub struct OkResp { pub ok: bool }

pub fn routes() -> Router<Arc<AppState>> {
    Router::new()
        .route("/wallet/register", post(register))
}

async fn register(State(app): State<Arc<AppState>>, Json(inp): Json<RegisterIn>) -> Json<OkResp> {
    // сохраняем сопоставление RID -> pubkey (hex) в sled
    // ключ: "pk:<rid>" => pub_hex (bytes)
    let key = format!("pk:{}", inp.rid);
    let db = app.sled();
    db.insert(key.as_bytes(), inp.pub_hex.as_bytes()).ok();
    db.flush_async().await.ok();
    info!("wallet register rid={} pub_hex_len={}", inp.rid, inp.pub_hex.len());
    Json(OkResp{ ok:true })
}

```

## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```bash
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```

## FILE: /root/logos_lrb/src/bin/ai_signal_listener.rs  (size=8704b)
```rust

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```

## FILE: /root/logos_lrb/src/bin/orchestration_control.rs  (size=6987b)
```rust
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/rcp_engine.rs  (size=4122b)
```rust
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```

## FILE: /root/logos_lrb/src/bin/resonance_mesh.rs  (size=8051b)
```rust
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/resonance_sync.rs  (size=11282b)
```rust
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/sigma_t.rs  (size=3522b)
```rust

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```

## FILE: /root/logos_lrb/src/bin/Λ0.rs  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/src/core/biosphere_scanner.rs  (size=5196b)
```rust
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```

## FILE: /root/logos_lrb/src/core/dao.rs  (size=2106b)
```rust

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/logos_self.rs  (size=2771b)
```rust

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/phase.rs  (size=5790b)
```rust

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/resonance.rs  (size=3016b)
```rust

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/tx_spam_guard.rs  (size=3175b)
```rust

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/lib.rs  (size=921b)
```rust

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```

## FILE: /root/logos_lrb/src/utils/filters.rs  (size=322b)
```rust

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```

## FILE: /root/logos_lrb/src/utils/frequency.rs  (size=380b)
```rust

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```

## FILE: /root/logos_lrb/src/utils/math.rs  (size=394b)
```rust

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```

## FILE: /root/logos_lrb/src/utils/types.rs  (size=215b)
```rust

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```

## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```bash
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```

## FILE: /root/logos_lrb/tools/batch.json  (size=0b)
(SKIPPED, binary/non-text: inode/x-empty; charset=binary)

## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```go
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```

## FILE: /root/logos_lrb/tools/book_make.sh  (size=3692b)
```bash
#!/usr/bin/env bash
set -euo pipefail

# Куда писать книгу
DATE_UTC=$(date -u +%Y-%m-%dT%H-%M-%SZ)
BOOK="docs/LOGOS_LRB_BOOK_${DATE_UTC}.txt"

# Корень репозитория (чтобы пути были относительные)
REPO_ROOT="/root/logos_lrb"
cd "$REPO_ROOT"

echo "[*] Building book: $BOOK"
mkdir -p docs

# --- списки включений/исключений ---
# Git-трекаемые файлы + критичные конфиги вне репы
INCLUDE_LIST="$(mktemp)"
EXTRA_LIST="$(mktemp)"

# 1) всё полезное из git (код/конфиги), без мусора
git ls-files \
  | grep -Ev '^(\.gitignore|README\.md|LICENSE|^docs/LOGOS_LRB_BOOK_|^docs/.*\.pdf$)' \
  | grep -Ev '(^target/|/target/|^node_modules/|/node_modules/|\.DS_Store|\.swp$|\.sqlite$|/data\.sled|/data\.sled/|\.pem$|\.key$)' \
  > "$INCLUDE_LIST"

# 2) системные файлы вне репы (если существуют)
add_extra() { [[ -f "$1" ]] && echo "$1" >> "$EXTRA_LIST"; }
add_extra "/etc/systemd/system/logos-node.service"
for f in /etc/systemd/system/logos-node.service.d/*.conf; do [[ -f "$f" ]] && echo "$f" >> "$EXTRA_LIST"; done
add_extra "/etc/nginx/conf.d/10_lrb_https.conf"
add_extra "/etc/prometheus/prometheus.yml"
for f in /etc/prometheus/rules/*.yml; do [[ -f "$f" ]] && echo "$f" >> "$EXTRA_LIST"; done
# Grafana provisioning/дашборды (если есть)
for f in /etc/grafana/provisioning/dashboards/*.yaml /var/lib/grafana/dashboards/*.json; do
  [[ -f "$f" ]] && echo "$f" >> "$EXTRA_LIST"
done
# OpenAPI (в репе уже есть), APK/лендинг укажем ссылкой — бинарники в книгу не кладём

# --- заголовок книги ---
{
  echo "LOGOS LRB — FULL LIVE BOOK (${DATE_UTC})"
  echo
  echo "Содержимое: весь код репозитория + ключевая инфраструктура (systemd/nginx/prometheus/grafana),"
  echo "формат: секции BEGIN/END FILE c sha256 и блочным EOF. Бинарники (APK, sled, pem) не включаются."
  echo
  echo "Репозиторий: $REPO_ROOT"
  echo
} > "$BOOK"

emit_file () {
  local src="$1" dst
  # внутри репо пишем относительные пути; вне — абсолютные
  if [[ "$src" == $REPO_ROOT/* ]]; then
    dst="/${src#$REPO_ROOT/}"
  else
    dst="$src"
  fi
  # пропуск «мусора»
  if [[ -d "$src" ]]; then return 0; fi
  if [[ ! -f "$src" ]]; then return 0; fi
  # вычисляем sha256
  local sum
  sum=$(sha256sum "$src" | awk '{print $1}')
  {
    echo "===== BEGIN FILE $dst ====="
    echo "# sha256: $sum"
    echo "<<'EOF'"
    cat "$src"
    echo "EOF"
    echo "===== END FILE $dst ====="
    echo
  } >> "$BOOK"
}

echo "[*] Emitting repo files..."
while IFS= read -r p; do emit_file "$REPO_ROOT/$p"; done < "$INCLUDE_LIST"

echo "[*] Emitting extra system files..."
if [[ -s "$EXTRA_LIST" ]]; then
  while IFS= read -r p; do emit_file "$p"; done < "$EXTRA_LIST"
fi

# --- прикладываем «паспорт» окружения ---
{
  echo "===== BEGIN FILE /docs/ENV_SNAPSHOT.txt ====="
  echo "# sha256: N/A"
  echo "<<'EOF'"
  echo "[systemd env]"
  systemctl show logos-node -p Environment | sed 's/^Environment=//'
  echo
  echo "[nginx -v]"
  nginx -v 2>&1 || true
  echo
  echo "[prometheus rules list]"
  ls -1 /etc/prometheus/rules 2>/dev/null || true
  echo
  echo "[grafana dashboards list]"
  ls -1 /var/lib/grafana/dashboards 2>/dev/null || true
  echo "EOF"
  echo "===== END FILE /docs/ENV_SNAPSHOT.txt ====="
  echo
} >> "$BOOK"

echo "[*] Book is ready: $BOOK"

```

## FILE: /root/logos_lrb/tools/book_restore.sh  (size=2514b)
```bash
#!/usr/bin/env bash
set -euo pipefail

BOOK="${1:-}"
if [[ -z "$BOOK" || ! -f "$BOOK" ]]; then
  echo "usage: $0 /path/to/LOGOS_LRB_BOOK_*.txt"; exit 1
fi

echo "[*] Restoring files from: $BOOK"
RESTORED=0
BADHASH=0

# прочитаем книгу и вытащим секции
# формат: BEGIN FILE <path>\n# sha256: <hex>\n<<'EOF'\n...EOF\nEND FILE
awk '
  /^===== BEGIN FILE / {
    inblock=1
    path=""
    sha=""
    gsub(/^===== BEGIN FILE /,"")
    gsub(/ =====$/,"")
    path=$0
    next
  }
  inblock && /^# sha256:/ {
    sha=$2
    next
  }
  inblock && /^<<'\''EOF'\''/ { collecting=1; content=""; next }
  collecting && /^EOF$/ { collecting=0; inblock=2; next }
  inblock==1 && !collecting { next }
  collecting { content = content $0 "\n"; next }
  inblock==2 && /^===== END FILE / {
    # записываем файл
    # создадим директорию
    cmd = "mkdir -p \"" path "\""
    sub(/\/[^\/]+$/, "", cmdpath=path) # dir part
    if (cmdpath != "") {
      system("mkdir -p \"" cmdpath "\"")
    }
    # записываем
    f = path
    gsub(/\r$/,"",content)
    # защитимся от /etc/... если нет прав — предложим sudo
    # но здесь просто пишем как есть
    outfile = path
    # если путь абсолютный, пишем в тот же абсолютный; если относительный — относительно cwd
    # создадим временный и заменим
    tmpfile = outfile ".tmp.restore"
    # в shell передам через printf
    print content > tmpfile
    close(tmpfile)
    # проверка sha256 если есть
    if (sha != "" && sha != "N/A") {
      cmdsum = "sha256sum \"" tmpfile "\" | awk '\''{print $1}'\''"
      cmdsum | getline got
      close(cmdsum)
      if (got != sha) {
        print "[WARN] sha256 mismatch for " outfile " expected=" sha " got=" got
        BADHASH++
      }
    }
    system("install -m 0644 \"" tmpfile "\" \"" outfile "\"")
    system("rm -f \"" tmpfile "\"")
    print "[OK] restored " outfile
    RESTORED++
    inblock=0
    next
  }
  END {
    # summary в AWK не выведем; сделаем в оболочке
  }
' "$BOOK"

echo "[*] Restored files: $RESTORED"
if [[ "${BADHASH:-0}" -gt 0 ]]; then
  echo "[!] WARNING: sha256 mismatches: $BADHASH"
fi

echo "[*] Done. Проверь права на системные файлы, возможно потребуется sudo chown/chmod."

```

## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```python
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```

## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```text
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```

## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```text
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```go
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```go
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/k6_smoke.js  (size=408b)
```javascript
import http from 'k6/http';
import { sleep } from 'k6';

export const options = {
  vus: 50,
  duration: '60s',
  thresholds: {
    http_req_failed: ['rate<0.01'],
    http_req_duration: ['p(95)<500', 'p(99)<1500'],
  },
};

export default function () {
  http.get('http://127.0.0.1:8080/healthz');
  http.get('http://127.0.0.1:8080/economy');
  http.get('http://127.0.0.1:8080/balance/A');
  sleep(0.05);
}

```

## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```text
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```

## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```text
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```bash
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```

## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```go
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```

## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```bash
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```

## FILE: /root/logos_lrb/tools/make_book_and_push.sh  (size=6625b)
```bash
#!/usr/bin/env bash
# /root/logos_lrb/tools/make_book_and_push.sh
# Сборка ТОЛЬКО текстовой книги (полный срез) и пуш в репозиторий.
# Без копий sled/ключей/ENV/БД. Чисто текст.
set -euo pipefail

# --- Параметры ---
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DOCS="$ROOT/docs"
NOW_UTC="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
OUT="$DOCS/LOGOS_LRB_FULL_BOOK_${NOW_UTC}.md"

# Секции: чтобы удобно писать заголовки в книгу
h1(){ echo -e "\n# $*"; }
h2(){ echo -e "\n## $*"; }
h3(){ echo -e "\n### $*"; }

# Утилиты
has(){ command -v "$1" >/dev/null 2>&1; }
line(){ printf '%*s\n' "${1:-80}" '' | tr ' ' -; }

mkdir -p "$DOCS"
TMPDIR="$(mktemp -d)"
trap 'rm -rf "$TMPDIR"' EXIT

# ---------------------------
#   1) ШАПКА / МЕТАДАННЫЕ
# ---------------------------
{
  h1 "LOGOS LRB — FULL BOOK SNAPSHOT"
  echo "**Дата (UTC):** ${NOW_UTC}"
  echo "**Репозиторий:** $ROOT"
  echo "**Хост:** $(hostname) | **Пользователь:** $(whoami)"
  echo "**Kernel:** $(uname -srmo 2>/dev/null || echo n/a)"
  if has lsb_release; then
    echo "**OS:** $(lsb_release -ds)"
  fi

  # Git информация
  h2 "Git"
  if [ -d "$ROOT/.git" ]; then
    echo "- **Remote(s):**"
    (cd "$ROOT" && git remote -v | sed 's/^/  /') || true
    echo "- **Текущая ветка:** $(cd "$ROOT" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo n/a)"
    echo "- **HEAD коммит:** $(cd "$ROOT" && git rev-parse HEAD 2>/dev/null || echo n/a)"
    echo "- **Статус:**"
    (cd "$ROOT" && git status -sb || true)
  else
    echo "_Внимание: .git не найден — репозиторий не инициализирован._"
  fi

  # Версии инструментов
  h2 "Инструменты"
  echo "- **Rust:** $(rustc --version 2>/dev/null || echo n/a)"
  echo "- **Cargo:** $(cargo --version 2>/dev/null || echo n/a)"
  echo "- **OpenSSL:** $(openssl version 2>/dev/null || echo n/a)"
  echo "- **jq:** $(jq --version 2>/dev/null || echo n/a)"
  echo "- **tree:** $(tree --version 2>/dev/null | head -n1 || echo n/a)"
} > "$OUT"

# ---------------------------------
#   2) ДЕРЕВО ПРОЕКТА (чистое)
# ---------------------------------
{
  h1 "Структура проекта (/root/logos_lrb)"
  echo "_Скрытые и тяжёлые директории исключены: .git, target, node_modules, dist, build._"
  if has tree; then
    (cd "$ROOT" && \
      tree -a -I '.git|target|node_modules|dist|build|.turbo|.cache' \
           -L 4 \
    ) || true
  else
    echo "_tree не установлен — fallback на find_"
    (cd "$ROOT" && \
      find . -maxdepth 4 \
        -not -path '*/.git/*' \
        -not -path '*/target/*' \
        -not -path '*/node_modules/*' \
        -not -path '*/dist/*' \
        -not -path '*/build/*' \
      | sort
    ) || true
  fi
} >> "$OUT"

# ---------------------------------
#   3) КЛЮЧЕВЫЕ ФАЙЛЫ / ПАПКИ
# ---------------------------------
append_file_excerpt(){
  local path="$1" ; local max_lines="${2:-200}"
  if [ -f "$path" ]; then
    h3 "$path"
    echo '```'$( [ "${path##*.}" = "rs" ] && echo rust || [ "${path##*.}" = "json" ] && echo json || echo )
    nl -ba "$path" | sed -n "1,${max_lines}p"
    [ "$(wc -l < "$path")" -gt "$max_lines" ] && echo "... (truncated)"
    echo '```'
  fi
}

{
  h1 "Ключевые файлы"
  # OpenAPI (если есть) — первые ~300 строк
  append_file_excerpt "$ROOT/node/src/openapi/openapi.json" 300

  # Основные точки входа
  append_file_excerpt "$ROOT/node/src/main.rs" 300
  append_file_excerpt "$ROOT/lrb_core/src/lib.rs" 200
  append_file_excerpt "$ROOT/lrb_core/src/ledger.rs" 200
  append_file_excerpt "$ROOT/lrb_core/src/mempool.rs" 200
  append_file_excerpt "$ROOT/lrb_core/src/dynamic_balance.rs" 200
  append_file_excerpt "$ROOT/lrb_core/src/spam_guard.rs" 200

  # Конфиги (без секретов — просто превью)
  append_file_excerpt "$ROOT/configs/genesis.yaml" 200
  append_file_excerpt "$ROOT/configs/logos_config.yaml" 200

  # Документация/README
  append_file_excerpt "$ROOT/README.md" 200
} >> "$OUT"

# ---------------------------------
#   4) API / САНИТИ (локальные ручки)
# ---------------------------------
{
  h1 "Sanity (локальный узел)"
  echo "_Если узел запущен: curl к локальным ручкам._"
  BASE="http://127.0.0.1:8080"
  for ep in /livez /readyz /healthz /health/bridge /version /head; do
    echo
    h3 "GET ${ep}"
    if curl -m 2 -sSf "$BASE$ep" >/dev/null 2>&1; then
      echo '```'
      curl -m 2 -s "$BASE$ep" | sed 's/[[:cntrl:]]//g'
      echo
      echo '```'
    else
      echo "_недоступно_"
    fi
  done

  # Метрики (только срез интересующих префиксов)
  h2 "Метрики Prometheus (срез)"
  if curl -m 2 -sSf "$BASE/metrics" >/dev/null 2>&1; then
    echo '```'
    curl -m 2 -s "$BASE/metrics" | \
      grep -E '^logos_(head|finalized|blocks|tx_|bridge|archive|mempool)' | head -n 200
    echo '```'
  else
    echo "_/metrics недоступен_"
  fi
} >> "$OUT" || true

# ---------------------------------
#   5) СБОРКА (опционально, без пуша бинарей)
# ---------------------------------
{
  h1 "Сборка (cargo check --release)"
  echo '```'
  (cd "$ROOT" && cargo check --release || true)
  echo '```'
} >> "$OUT"

# ---------------------------------
#   6) ИТОГ / ВЕС / ПОДПИСЬ
# ---------------------------------
{
  h1 "Итог"
  echo "- Книга собрана: $OUT"
  echo "- Размер репозитория:"
  (cd "$ROOT" && du -sh . 2>/dev/null || echo n/a)
  echo "- Кол-во строк кода (примерно):"
  (cd "$ROOT" && { has cloc && cloc . || (echo "cloc не установлен, считаю через wc"; find . -name '*.*' -not -path '*/.git/*' -not -path '*/target/*' -not -path '*/node_modules/*' -type f -print0 | xargs -0 cat 2>/dev/null | wc -l); } ) || true
} >> "$OUT"

# ---------------------------
#   7) GIT COMMIT & PUSH
# ---------------------------
echo "[*] Книга готова: $OUT"
(cd "$ROOT" && git add "$OUT" node/src/openapi/openapi.json 2>/dev/null || true)
(cd "$ROOT" && git commit -m "docs: FULL BOOK (snapshot ${NOW_UTC})" || true)
(cd "$ROOT" && git push || true)

echo "[✓] Готово."

```

## FILE: /root/logos_lrb/tools/make_book_and_push.shy  (size=3726b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/make_book_and_push_v2.sh  (size=826b)
```bash
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT"

# 0) Проверка сборки
cargo build --release -p logos_node

# 1) Сборка книги
log="$(mktemp)"
./tools/make_full_book_v2.sh | tee "$log" >/dev/null
OUT="$(grep -o '::out::.*' "$log" | tail -n1 | sed 's/^::out:://')"
test -n "$OUT" && test -f "$OUT"

# 2) Публикация
git pull --rebase --autostash origin "$(git rev-parse --abbrev-ref HEAD)" || true
git add "$OUT" || true
# При желании можно добавить ещё openapi:
[ -f node/src/openapi/openapi.json ] && git add node/src/openapi/openapi.json || true

git commit -m "docs: FULL BOOK snapshot ($(date -u +%Y-%m-%dT%H:%M:%SZ))" || true
git push origin "$(git rev-parse --abbrev-ref HEAD)"

echo "Published: $OUT"

```

## FILE: /root/logos_lrb/tools/make_codebook.sh  (size=4987b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/make_full_book.sh  (size=6769b)
```bash
#!/usr/bin/env bash
# /root/logos_lrb/tools/make_full_book.sh
# Полная текстовая книга (все исходники/конфиги/доки) + git push.
# Без сборки бинарей. С фильтрами по маскам и размеру.
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DOCS="${ROOT}/docs"
NOW_UTC="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
OUT="${DOCS}/LOGOS_LRB_FULL_BOOK_${NOW_UTC}.md"

mkdir -p "${DOCS}"

h1(){ printf "\n# %s\n" "$*"; }
h2(){ printf "\n## %s\n" "$*"; }
h3(){ printf "\n### %s\n" "$*"; }

lang_by_ext(){
  case "${1##*.}" in
    rs) echo "rust" ;;
    toml) echo "toml" ;;
    json) echo "json" ;;
    yaml|yml) echo "yaml" ;;
    sh|bash) echo "bash" ;;
    sql) echo "sql" ;;
    js|mjs|cjs|ts|tsx) echo "ts" ;;
    html|htm) echo "html" ;;
    css) echo "css" ;;
    ini|conf|cfg|service|timer|socket|md|txt) echo "" ;;
    *) echo "" ;;
  esac
}

is_text(){
  local f="$1"
  local mt
  mt="$(file -b --mime-type "$f" 2>/dev/null || echo unknown)"
  case "$mt" in
    text/*|application/json|application/x-yaml|application/xml) return 0 ;;
    *) return 1 ;;
  esac
}

print_file(){
  local f="$1"; local rel="${f#$ROOT/}"; local lang; lang="$(lang_by_ext "$f")"
  h3 "$rel"
  if [ -n "$lang" ]; then printf '```%s\n' "$lang"; else printf '```\n'; fi
  cat "$f"
  printf '\n```\n'
}

# каталоги-исключения
EXCLUDES=(
  -path "$ROOT/.git" -prune -o
  -path "$ROOT/target" -prune -o
  -path "$ROOT/node_modules" -prune -o
  -path "$ROOT/dist" -prune -o
  -path "$ROOT/build" -prune -o
  -path "$ROOT/.turbo" -prune -o
  -path "$ROOT/.cache" -prune -o
)

# маски бинарей/архивов/медиа/дампов — в книгу не включаем
SKIP_GLOB=(
  '*.db' '*.sqlite*' '*.rdb' '*.bin' '*.pack' '*.idx' '*.lock' '*.tmp'
  '*.tar' '*.tar.*' '*.zip' '*.gz' '*.xz' '*.zst' '*.7z'
  '*.pdf' '*.png' '*.jpg' '*.jpeg' '*.gif' '*.svg' '*.webp'
  '*.mp4' '*.mov' '*.avi' '*.mp3' '*.wav' '*.ogg'
  '*.wasm' '*.class' '*.o' '*.a' '*.so' '*.dylib' '*.dll' '*.exe'
  '*.log' '*.trace' '*.pcap' '*.dump' '*.core' '*.bak'
)

# порог размера файла (КБ) — всё больше НЕ включаем
MAX_KB=5120   # 5MB (можно поднять до 10240 при необходимости)

# ---------- СБОРКА КНИГИ ----------
{
  h1 "LOGOS LRB — FULL BOOK SNAPSHOT"
  printf "**Дата (UTC):** %s\n" "$NOW_UTC"
  printf "**Репозиторий:** %s\n" "$ROOT"
  printf "**Пользователь:** %s\n" "$(whoami)"
  printf "**Kernel:** %s\n" "$(uname -srm 2>/dev/null || echo n/a)"
  OS_STR="$(lsb_release -ds 2>/dev/null || awk -F= '/^PRETTY_NAME=/ {print $2}' /etc/os-release 2>/dev/null | tr -d '\"')"
  [ -z "$OS_STR" ] && OS_STR="n/a"
  printf "**OS:** %s\n" "$OS_STR"

  h2 "Git"
  if [ -d "$ROOT/.git" ]; then
    echo "**Remote(s):**"
    (cd "$ROOT" && git remote -v | sed 's/^/  /') || true
    printf "**Текущая ветка:** %s\n" "$(cd "$ROOT" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo n/a)"
    printf "**HEAD commit:** %s\n" "$(cd "$ROOT" && git rev-parse HEAD 2>/dev/null || echo n/a)"
    echo "**Статус:**"
    (cd "$ROOT" && git status -sb | sed 's/^/  /') || true
  else
    echo "_Внимание: .git не найден — репозиторий не инициализирован._"
  fi

  h2 "Инструменты"
  printf "**rustc:** %s\n" "$(rustc --version 2>/dev/null || echo n/a)"
  printf "**cargo:** %s\n" "$(cargo --version 2>/dev/null || echo n/a)"
  printf "**jq:** %s\n" "$(jq --version 2>/dev/null || echo n/a)"
  TR_VER="$(tree --version 2>/dev/null | head -n1 || true)"; [ -z "$TR_VER" ] && TR_VER="n/a"
  printf "**tree:** %s\n" "$TR_VER"

  h2 "Структура проекта (чистое дерево)"
  if command -v tree >/dev/null 2>&1; then
    (cd "$ROOT" && tree -a -I '.git|target|node_modules|dist|build|.turbo|.cache' -L 4)
  else
    (cd "$ROOT" && find . -maxdepth 4 \
      -not -path './.git*' -not -path './target*' -not -path './node_modules*' \
      -not -path './dist*' -not -path './build*' -not -path './.turbo*' -not -path './.cache*')
  fi

  h2 "Ключевые файлы (OpenAPI и точки входа)"
  [ -f "$ROOT/node/src/openapi/openapi.json" ] && print_file "$ROOT/node/src/openapi/openapi.json" || true

  for f in \
    "$ROOT/node/src/main.rs" \
    "$ROOT/node/src/metrics.rs" \
    "$ROOT/node/src/guard.rs" \
    "$ROOT/node/src/bridge.rs" \
    "$ROOT/node/src/admin.rs" \
    "$ROOT/node/src/api/tx.rs" \
    "$ROOT/node/src/archive/mod.rs" \
    "$ROOT/node/src/producer.rs" \
    "$ROOT/node/Cargo.toml" \
    "$ROOT/lrb_core/src/lib.rs" \
    "$ROOT/lrb_core/src/ledger.rs" \
    "$ROOT/lrb_core/src/mempool.rs" \
    "$ROOT/configs/genesis.yaml" \
    "$ROOT/configs/logos_config.yaml" \
    "$ROOT/README.md" \
  ; do
    [ -f "$f" ] && print_file "$f" || true
  done

  h2 "Все текстовые файлы (полный текст)"
  while IFS= read -r -d '' f; do
    # уже включённые выше — пропускаем
    case "$f" in
      "$ROOT/node/src/openapi/openapi.json"|\
      "$ROOT/node/src/main.rs"|\
      "$ROOT/node/src/metrics.rs"|\
      "$ROOT/node/src/guard.rs"|\
      "$ROOT/node/src/bridge.rs"|\
      "$ROOT/node/src/admin.rs"|\
      "$ROOT/node/src/api/tx.rs"|\
      "$ROOT/node/src/archive/mod.rs"|\
      "$ROOT/node/src/producer.rs"|\
      "$ROOT/node/Cargo.toml"|\
      "$ROOT/lrb_core/src/lib.rs"|\
      "$ROOT/lrb_core/src/ledger.rs"|\
      "$ROOT/lrb_core/src/mempool.rs"|\
      "$ROOT/configs/genesis.yaml"|\
      "$ROOT/configs/logos_config.yaml"|\
      "$ROOT/README.md") continue;;
    esac

    # маски
    bn="$(basename "$f")"; skip=0
    for g in "${SKIP_GLOB[@]}"; do
      [[ "$bn" == $g ]] && skip=1 && break
    done
    (( skip )) && continue

    # порог размера
    kb="$(du -k "$f" 2>/dev/null | awk '{print $1}')"
    [[ -n "$kb" && "$kb" -gt "$MAX_KB" ]] && continue

    # только явный текст по MIME
    if is_text "$f"; then print_file "$f"; fi
  done < <(find "$ROOT" "${EXCLUDES[@]}" -type f -print0)

  h2 "Итог"
  printf "**Книга собрана:** %s\n" "$OUT"
  printf "**Размер репозитория:** %s\n" "$(cd "$ROOT" && du -sh . 2>/dev/null || echo n/a)"
  printf "**Размер книги:** %s\n" "$(du -h "$OUT" 2>/dev/null | awk '{print $1" ("$2")"}' || echo n/a)"
} > "$OUT"

echo "[*] Книга готова: $OUT"

# git commit & push
(cd "$ROOT" && git add "$OUT" node/src/openapi/openapi.json 2>/dev/null || true)
(cd "$ROOT" && git commit -m "docs: FULL BOOK (snapshot ${NOW_UTC})" || true)
(cd "$ROOT" && git push || true)

```

## FILE: /root/logos_lrb/tools/make_full_book_v2.sh  (size=3981b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/make_full_snapshot_live.sh  (size=4401b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/make_tx.rs  (size=1324b)
```rust
use ed25519_dalek::{Keypair, Signer};
use rand::rngs::OsRng;
use bs58;
use sha2::{Sha256, Digest};

fn main() {
    // 1) Генерим новую пару
    let mut csprng = OsRng{};
    let keypair: Keypair = Keypair::generate(&mut csprng);

    // 2) Строим RID = base58(public_key)
    let rid_from = bs58::encode(keypair.public.to_bytes()).into_string();
    let rid_to   = "recipientRIDbase58".to_string(); // сюда подставь реальный RID получателя

    // 3) Параметры tx
    let amount: u64 = 12345;
    let nonce: u64  = 1;
    let memo = Some("hello world".to_string());

    // 4) txid = SHA256(from|to|amount|nonce)
    let mut hasher = Sha256::new();
    hasher.update(rid_from.as_bytes());
    hasher.update(rid_to.as_bytes());
    hasher.update(&amount.to_be_bytes());
    hasher.update(&nonce.to_be_bytes());
    let txid = hasher.finalize();
    let txid_hex = hex::encode(&txid);

    // 5) Подпись приватным ключом
    let sig = keypair.sign(&txid);
    let sig_hex = hex::encode(sig.to_bytes());

    // 6) Печатаем готовый JSON для submit_tx
    println!(r#"{{
  "from":"{}",
  "to":"{}",
  "amount":{},
  "nonce":{},
  "memo":"{}",
  "sig_hex":"{}"
}}"#, rid_from, rid_to, amount, nonce, memo.unwrap(), sig_hex);
}

```

## FILE: /root/logos_lrb/tools/prepare_payer.sh  (size=1165b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/repo_audit.sh  (size=3155b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/tools/scan_modules.sh  (size=4647b)
```bash
#!/usr/bin/env bash
set -euo pipefail

ROOT="/root/logos_lrb"
OUT_DIR="$ROOT/docs"
TS="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
TXT="$OUT_DIR/MODULES_INVENTORY_${TS}.txt"
CSV="$OUT_DIR/MODULES_INVENTORY_${TS}.csv"
JSON="$OUT_DIR/MODULES_INVENTORY_${TS}.json"

mkdir -p "$OUT_DIR"

EXCL=( -path "$ROOT/target" -o -path "$ROOT/**/target" -o
       -path "$ROOT/.git"   -o -path "$ROOT/**/.git"   -o
       -path "$ROOT/**/node_modules" -o
       -path "$ROOT/**/.venv" -o
       -path "$ROOT/**/dist"  -o
       -path "$ROOT/**/build" )

print_hdr(){ printf "%s\n\n" "$1" >>"$TXT"; }
add_csv(){ printf "%s\n" "$1" >>"$CSV"; }
sha_or_dash(){ [ -f "$1" ] && sha256sum "$1" | awk '{print $1}' || printf "-"; }
safe_wc(){ [ -f "$1" ] && wc -l < "$1" | tr -d ' ' || printf "0"; }

# header
{
  echo "# LOGOS LRB — modules inventory (UTC $TS)"
  echo "ROOT: $ROOT"
  echo
} >"$TXT"
echo "path,ext,size_bytes,lines,sha256" >"$CSV"
echo '{"generated":"'"$TS"'","files":[' >"$JSON"

emit_file(){
  local f="$1"; [ -f "$f" ] || return 0
  local rel="${f#"$ROOT/"}"; local ext="${f##*.}"
  local size lines hash
  size=$(stat -c '%s' "$f" 2>/dev/null || echo 0)
  lines=$(safe_wc "$f"); hash=$(sha_or_dash "$f")
  add_csv "$rel,$ext,$size,$lines,$hash"
  printf '{"path":"%s","ext":"%s","size":%s,"lines":%s,"sha256":"%s"},\n' \
    "$rel" "$ext" "$size" "$lines" "$hash" >>"$JSON"
}

scan_dir_ext(){ # dir ext
  local d="$1" ext="$2"; [ -d "$d" ] || return 0
  find "$d" -type f -name "$ext" \( ! \( "${EXCL[@]}" \) \) -print0 2>/dev/null \
    | sort -z | while IFS= read -r -d '' f; do emit_file "$f"; done
}

scan_multi(){ local d="$1"; shift; for e in "$@"; do scan_dir_ext "$d" "$e"; done; }

# --- SCAN ---
print_hdr "## CORE (lrb_core)"
emit_file "$ROOT/lrb_core/Cargo.toml"
scan_dir_ext "$ROOT/lrb_core/src" "*.rs"

print_hdr "## NODE (node)"
emit_file "$ROOT/node/Cargo.toml"
emit_file "$ROOT/node/build.rs"
scan_dir_ext "$ROOT/node/src" "*.rs"
scan_dir_ext "$ROOT/node/src/archive" "*.rs"
scan_dir_ext "$ROOT/node/src/bin" "*.rs"
scan_multi   "$ROOT/node/src/openapi" "*.json" "*.yaml" "*.yml"

print_hdr "## MODULES (service modules)"
scan_multi "$ROOT/modules" "*.rs" "*.toml" "*.sh" "*.yaml" "*.yml" "*.json" "*.py"

print_hdr "## WWW (wallet/explorer static)"
scan_multi "$ROOT/www" "*.html" "*.js" "*.ts" "*.css" "*.json"

print_hdr "## CONFIGS"
scan_multi "$ROOT/configs" "*.yaml" "*.yml" "*.toml" "*.json"
scan_multi "$ROOT/configs/env" "*.example" "*.sample" "*.template"

print_hdr "## SCRIPTS"
scan_dir_ext "$ROOT/scripts" "*.sh"

print_hdr "## INFRA (systemd/nginx templates)"
scan_multi "$ROOT/infra/systemd" "*.service" "*.conf"
scan_dir_ext "$ROOT/infra/nginx" "*.conf"

# --- SUMMARY ---
TOTAL_FILES=$(tail -n +2 "$CSV" | wc -l | tr -d ' ')
TOTAL_LOC=$(tail -n +2 "$CSV" | awk -F, '{sum+=$4} END{print sum+0}')
TOTAL_SIZE=$(tail -n +2 "$CSV" | awk -F, '{sum+=$3} END{print sum+0}')
{
  echo
  echo "## SUMMARY"
  echo "files_total: $TOTAL_FILES"
  echo "lines_total: $TOTAL_LOC"
  echo "size_total_bytes: $TOTAL_SIZE"
} >>"$TXT"

# --- CONSISTENCY ---
print_hdr "## CONSISTENCY CHECKS"

MAIN="$ROOT/node/src/main.rs"
if [ -f "$MAIN" ]; then
  echo "main.rs -> module presence:" >>"$TXT"
  grep -E '^\s*(pub\s+)?mod\s+[A-Za-z_][A-Za-z0-9_]*\s*;' "$MAIN" \
   | sed -E 's/^\s*(pub\s+)?mod\s+([A-Za-z_][A-Za-z0-9_]*)\s*;.*/\2/' \
   | sort -u \
   | while read -r m; do
      FILE="$ROOT/node/src/${m}.rs"
      DIRMOD="$ROOT/node/src/${m}/mod.rs"
      if   [ -f "$FILE" ];  then echo "  OK: $m => node/src/${m}.rs" >>"$TXT"
      elif [ -f "$DIRMOD" ]; then echo "  OK: $m => node/src/${m}/mod.rs" >>"$TXT"
      else echo "  MISS: $m => node/src/${m}.rs | node/src/${m}/mod.rs (not found)" >>"$TXT"
      fi
    done
  echo >>"$TXT"
fi

OPENAPI="$ROOT/node/src/openapi.rs"
if [ -f "$OPENAPI" ]; then
  echo "openapi.rs -> include_str! payloads:" >>"$TXT"
  sed -n -E 's/.*include_str!\("\.\.\/(openapi\/[^"]+)"\).*/\1/p' "$OPENAPI" \
    | sort -u | while read -r p; do
      FULL="$ROOT/node/src/$p"
      if [ -f "$FULL" ]; then
        echo "  OK: node/src/$p" >>"$TXT"
      else
        echo "  MISS: node/src/$p (not found)" >>"$TXT"
      fi
    done
  echo >>"$TXT"
fi

for D in "$ROOT/lrb_core/src" "$ROOT/node/src" "$ROOT/modules" "$ROOT/www" "$ROOT/configs" "$ROOT/scripts"; do
  if [ -d "$D" ]; then echo "DIR OK: ${D#$ROOT/}" >>"$TXT"; else echo "DIR MISS: ${D#$ROOT/}" >>"$TXT"; fi
done

# --- finalize JSON ---
if [ -s "$JSON" ]; then TMP="$JSON.tmp"; sed '$ s/},/}/' "$JSON" >"$TMP" || true; mv -f "$TMP" "$JSON" || true; fi
echo ']}' >>"$JSON"

echo "[*] Inventory ready:"
echo "    $TXT"
echo "    $CSV"
echo "    $JSON"

```

## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```go
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```

## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```go
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```javascript
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```javascript
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```

## FILE: /root/logos_lrb/tools/seed_balance/Cargo.toml  (size=138b)
```toml
[package]
name = "seed_balance"
version = "0.1.0"
edition = "2021"

[dependencies]
sled = { workspace = true }
hex = { workspace = true }

```

## FILE: /root/logos_lrb/tools/seed_balance/src/main.rs  (size=582b)
```rust
use std::env;

/// usage: seed_balance <sled_path> <rid> <amount>
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 4 {
        eprintln!("usage: {} <sled_path> <rid> <amount>", args[0]);
        std::process::exit(1);
    }
    let sled_path = &args[1];
    let rid = &args[2];
    let amount: u64 = args[3].parse().expect("amount u64");

    let db = sled::open(sled_path).expect("open sled");
    db.insert(format!("bal:{rid}"), amount.to_be_bytes().to_vec())
        .expect("write bal");
    println!("OK: set balance of {rid} = {amount}");
}

```

## FILE: /root/logos_lrb/tools/targets.jsonl  (size=256277b)
```text
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzLCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5LCJtZW1vIjoibG9hZCIsInNpZ19oZXgiOiIwMCJ9","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjE5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjIzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjI5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjMzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjM5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjQ5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjUzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjU5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjYzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjY5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjcyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjczOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjc5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjgzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjg5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkwOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkxOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkyOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzMCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzMSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzMiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzMywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzNCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzNSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzNiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzNywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzOCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjkzOSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk0OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk1OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk2OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk3OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk4OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5MCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5MSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5MiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5MywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5NCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5NSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5NiwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5NywibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5OCwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjk5OSwibWVtbyI6ImxvYWQiLCJzaWdfaGV4IjoiMDAifQ==","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMDksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMTksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMjksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwMzksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNDksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNTksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNjksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwNzksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwODksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjEwOTksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMDksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMTksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMjksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExMzksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDIsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDMsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDQsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDUsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDYsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDcsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDgsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNDksIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNTAsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}
{"method":"POST","url":"http://127.0.0.1:8080/submit_tx","body":"eyJmcm9tIjoiUEFZRVIiLCJ0byI6IlJDViIsImFtb3VudCI6MSwibm9uY2UiOjExNTEsIm1lbW8iOiJsb2FkIiwic2lnX2hleCI6IjAwIn0=","header":{"Content-Type":["application/json"]}}

```

## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```bash
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```

## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```bash
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```

## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```bash
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```

## FILE: /root/logos_lrb/tools/vegeta_submit_live.sh  (size=2683b)
```bash
#!/usr/bin/env bash
set -euo pipefail

# === defaults ===
API="http://127.0.0.1:8080"
FROM="PAYER"
TO="RCV"
AMOUNT=1
RATE=500
DURATION="60s"
START_NONCE=1
COUNT=10000
REPORT_EVERY=30   # секунд

# === parse KEY=VALUE ===
for kv in "$@"; do
  case "$kv" in
    API=*) API=${kv#API=} ;;
    FROM=*) FROM=${kv#FROM=} ;;
    TO=*) TO=${kv#TO=} ;;
    AMOUNT=*) AMOUNT=${kv#AMOUNT=} ;;
    RATE=*) RATE=${kv#RATE=} ;;
    DURATION=*) DURATION=${kv#DURATION=} ;;
    START_NONCE=*) START_NONCE=${kv#START_NONCE=} ;;
    COUNT=*) COUNT=${kv#COUNT=} ;;
    REPORT_EVERY=*) REPORT_EVERY=${kv#REPORT_EVERY=} ;;
    *) echo "[WARN] unknown arg: $kv" ;;
  esac
done

command -v vegeta >/dev/null 2>&1 || { echo "[ERR] vegeta not found"; exit 1; }

echo "[*] attack: rate=${RATE} for ${DURATION} | from=${FROM} to=${TO} amount=${AMOUNT} nonces=${START_NONCE}..$((START_NONCE+COUNT-1))"

# === generate JSONL targets ===
TARGETS="targets.jsonl"
RESULTS="results.bin"
rm -f "$TARGETS" "$RESULTS"

gen_targets_json() {
  local n=${START_NONCE}
  local end=$((START_NONCE + COUNT - 1))
  while [[ $n -le $end ]]; do
    local body b64
    body=$(printf '{"from":"%s","to":"%s","amount":%d,"nonce":%d,"memo":"load","sig_hex":"00"}' \
      "$FROM" "$TO" "$AMOUNT" "$n")
    b64=$(printf '%s' "$body" | openssl base64 -A)
    printf '{"method":"POST","url":"%s/submit_tx","body":"%s","header":{"Content-Type":["application/json"]}}\n' \
      "$API" "$b64"
    n=$((n+1))
  done
}

gen_targets_json > "$TARGETS"

# === start attack in background ===
( vegeta attack -format=json -rate="${RATE}" -duration="${DURATION}" -targets="$TARGETS" > "$RESULTS" ) &
VEG_PID=$!

# cleanup & final report on Ctrl+C / TERM
finish() {
  echo
  echo "[*] stopping attack (pid=$VEG_PID) and printing final report..."
  kill "$VEG_PID" 2>/dev/null || true
  wait "$VEG_PID" 2>/dev/null || true

  echo "[*] FINAL SUMMARY:"
  vegeta report "$RESULTS"

  echo "[*] FINAL HISTOGRAM:"
  vegeta report -type='hist[0,500us,1ms,2ms,5ms,10ms,20ms,50ms,100ms]' "$RESULTS"

  echo "[*] JSON metrics -> results.json"
  vegeta report -type=json "$RESULTS" > results.json

  # archive sample (если включён /archive)
  if curl -sf "${API}/archive/history/${FROM}" >/dev/null 2>&1; then
    echo "[*] archive sample:"
    curl -sf "${API}/archive/history/${FROM}" | jq '.[0:5]' || true
  fi
  exit 0
}
trap finish INT TERM

# === live progress loop ===
START_TS=$(date +%s)
while kill -0 "$VEG_PID" 2>/dev/null; do
  sleep "$REPORT_EVERY"
  NOW=$(date +%s); ELAPSED=$((NOW-START_TS))
  echo
  echo "[*] PROGRESS t=${ELAPSED}s:"
  vegeta report "$RESULTS" || true
done

# wait and final when finished naturally
finish

```

## FILE: /root/logos_lrb/tools/vegeta_submit.sh  (size=1977b)
```bash
#!/usr/bin/env bash
set -euo pipefail

# --- дефолты ---
API="http://127.0.0.1:8080"
FROM="PAYER"
TO="RCV"
AMOUNT=1
RATE=500
DURATION="60s"
START_NONCE=1
COUNT=10000

# --- парсинг KEY=VALUE из аргументов ---
for kv in "$@"; do
  case "$kv" in
    API=*) API=${kv#API=} ;;
    FROM=*) FROM=${kv#FROM=} ;;
    TO=*) TO=${kv#TO=} ;;
    AMOUNT=*) AMOUNT=${kv#AMOUNT=} ;;
    RATE=*) RATE=${kv#RATE=} ;;
    DURATION=*) DURATION=${kv#DURATION=} ;;
    START_NONCE=*) START_NONCE=${kv#START_NONCE=} ;;
    COUNT=*) COUNT=${kv#COUNT=} ;;
    *) echo "[WARN] unknown arg: $kv" ;;
  esac
done

command -v vegeta >/dev/null 2>&1 || { echo "[ERR] vegeta not found in PATH"; exit 1; }

echo "[*] attack: rate=${RATE} for ${DURATION} | from=${FROM} to=${TO} amount=${AMOUNT} nonces=${START_NONCE}..$((START_NONCE+COUNT-1))"

gen_targets_json() {
  local n=${START_NONCE}
  local end=$((START_NONCE + COUNT - 1))
  while [[ $n -le $end ]]; do
    local body b64
    body=$(printf '{"from":"%s","to":"%s","amount":%d,"nonce":%d,"memo":"load","sig_hex":"00"}' \
      "$FROM" "$TO" "$AMOUNT" "$n")
    b64=$(printf '%s' "$body" | openssl base64 -A)
    printf '{"method":"POST","url":"%s/submit_tx","body":"%s","header":{"Content-Type":["application/json"]}}\n' \
      "$API" "$b64"
    n=$((n+1))
  done
}

# атака: live-репорт каждые 30s + финальные отчёты
gen_targets_json \
  | vegeta attack -format=json -rate="${RATE}" -duration="${DURATION}" \
  | tee results.bin \
  | vegeta report -every 30s

echo "[*] latency histogram:"
vegeta report -type='hist[0,500us,1ms,2ms,5ms,10ms,20ms,50ms,100ms]' results.bin

echo "[*] JSON metrics -> results.json"
vegeta report -type=json results.bin > results.json

# срез архива (если включён /archive)
if curl -sf "${API}/archive/history/${FROM}" >/dev/null 2>&1; then
  echo "[*] archive sample:"
  curl -sf "${API}/archive/history/${FROM}" | jq '.[0:5]' || true
fi

```

## FILE: /root/logos_lrb/wallet-proxy/app.py  (size=7115b)
(SKIPPED, looks secret-bearing)

## FILE: /root/logos_lrb/wallet-proxy/requirements.txt  (size=1147b)
```text
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```

## FILE: /root/logos_lrb/wallet-proxy/scanner.py  (size=5538b)
```python
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```

## FILE: /root/logos_lrb/www/explorer/explorer.css  (size=898b)
```css
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /root/logos_lrb/www/explorer/explorer.js  (size=3977b)
```javascript
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /root/logos_lrb/www/explorer/index.html  (size=1880b)
```html
<!doctype html><html lang="ru"><head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self'; img-src 'self'; script-src 'self'; style-src 'self'">
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LOGOS Explorer</title>
<style>
body{font-family:system-ui,Roboto,Arial,sans-serif;background:#0b0e11;color:#e6e6e6;margin:0}
header{padding:16px 20px;background:#12161a;border-bottom:1px solid #1b2026}
main{padding:20px}
table{width:100%;border-collapse:collapse}
th,td{padding:8px 10px;border-bottom:1px solid #1b2026;font-size:14px}
th{text-align:left;color:#a6a6a6}.muted{color:#8c8c8c;font-size:12px}
</style></head><body>
<header><h3>LOGOS Explorer</h3><div class="muted" id="head"></div></header>
<main>
  <h4>Последние блоки</h4>
  <table><thead><tr><th>Высота</th><th>Хеш</th><th>Tx</th><th>Время</th></tr></thead><tbody id="blocks"></tbody></table>
</main>
<script>
async function getHead(){ return (await fetch('/api/head')).json(); }
async function getBlocks(){ return (await fetch('/api/archive/blocks?limit=50')).json(); }
function fmtTs(ts){ const d=new Date((ts||0)*1000); return isNaN(d)?'-':d.toLocaleString(); }
async function tick(){
  try{
    const h=await getHead();
    document.getElementById('head').textContent=`head.height=${h.height} (finalized=${h.finalized})`;
    const data=await getBlocks();
    const rows=(data.blocks||[]).map(b=>{
      const hash=b.hash||b.block_hash||''; const ts=b.ts||b.ts_sec||0; const txc=b.tx_count??b.txs??0;
      return `<tr><td>${b.height}</td><td class="muted">${String(hash).slice(0,16)}…</td><td>${txc}</td><td>${fmtTs(ts)}</td></tr>`;
    }).join('');
    document.getElementById('blocks').innerHTML=rows;
  }catch(e){ console.error(e); }
}
setInterval(tick,1500); tick();
</script></body></html>

```

## FILE: /root/logos_lrb/www/index.html  (size=4902b)
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LOGOS Wallet</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:#0c0f13; color:#e8eef6; }
    .wrap { max-width: 860px; margin: 24px auto; padding: 0 16px; }
    h1 { margin: 0 0 16px; font-size: 22px; }
    h2 { margin: 24px 0 12px; font-size: 18px; }
    .box { background:#121821; border:1px solid #1e2633; border-radius:12px; padding:16px; margin:12px 0; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#151c27; border:1px solid #283044; font-size:13px; }
    input, textarea { width:100%; background:#0d1219; color:#e8eef6; border:1px solid #283044; border-radius:10px; padding:10px 12px; outline:none; }
    input:focus, textarea:focus { border-color:#3a70ff; box-shadow:0 0 0 2px #3a70ff22; }
    button { background:#1f5eff; border:none; color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; }
    button.secondary { background:#182133; }
    pre { white-space:pre-wrap; word-break:break-word; font-size:12px; background:#0a0e14; border:1px solid #1c2432; padding:12px; border-radius:10px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 720px){ .grid2 { grid-template-columns: 1fr; } }
    .muted { color:#9fb0c7; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>LOGOS Wallet</h1>

    <!-- ПРОФИЛЬ -->
    <div class="box">
      <h2>Профиль</h2>
      <div class="row">
        <span class="pill">balance: <b id="balanceBadge">-</b></span>
        <span class="pill">nonce: <b id="nonceBadge">-</b></span>
      </div>
      <div class="grid2">
        <div>
          <label class="muted">RID (текущий аккаунт)</label>
          <input id="ridInput" placeholder="RID (base58 pubkey)" />
        </div>
        <div class="row" style="align-items:end;">
          <button id="btnBalance">Баланс</button>
          <button id="btnSync" class="secondary">SYNC</button>
        </div>
      </div>
      <pre id="outBox">{}</pre>
    </div>

    <!-- ОТПРАВКА -->
    <div class="box">
      <h2>Отправка</h2>
      <div class="grid2">
        <div>
          <label class="muted">RID получателя</label>
          <input id="toRid" placeholder="RID получателя" />
        </div>
        <div>
          <label class="muted">Сумма</label>
          <input id="sendAmount" type="number" min="1" step="1" placeholder="amount (u64)" />
        </div>
      </div>

      <div class="grid2">
        <div>
          <label class="muted">SIG (HEX/Base64). Оставь пустым, если кошелёк подпишет локально</label>
          <input id="manualSig" placeholder="опционально: подпись" />
        </div>
        <div class="row" style="align-items:end;">
          <button id="btnSend">Отправить</button>
        </div>
      </div>

      <pre id="txOut">{}</pre>
    </div>

    <!-- СТЕЙКИНГ -->
    <div class="box">
      <h2>Стейкинг</h2>
      <div class="row">
        <span class="pill">delegated: <b id="chipDelegated">0</b></span>
        <span class="pill">entries: <b id="chipEntries">0</b></span>
        <span class="pill">claimable: <b id="chipClaimable">0</b></span>
      </div>

      <div class="grid2">
        <div>
          <label class="muted">RID валидатора (SELF = свой RID)</label>
          <input id="ridValidator" placeholder="RID валидатора" />
        </div>
        <div>
          <label class="muted">Сумма для Delegate</label>
          <input id="stakeAmount" type="number" min="1" step="1" placeholder="amount (u64)" />
        </div>
      </div>

      <div class="grid2">
        <div>
          <label class="muted">Сумма для Undelegate</label>
          <input id="unstakeAmount" type="number" min="1" step="1" placeholder="amount (u64)" />
        </div>
        <div class="row" style="align-items:end;">
          <button id="btnStakeDelegate">Delegate</button>
          <button id="btnStakeUndelegate" class="secondary">Undelegate</button>
          <button id="btnStakeClaim" class="secondary">Claim</button>
        </div>
      </div>

      <pre id="stakeOut">{}</pre>
    </div>

    <!-- ИСТОРИЯ -->
    <div class="box">
      <h2>История операций</h2>
      <div class="row" style="align-items:end;">
        <button id="btnShowHist">Показать</button>
      </div>
      <pre id="historyBox">{}</pre>
    </div>
  </div>

  <script src="wallet.js?v=1757914832"></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet3/app.v3.js  (size=6763b)
```javascript
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const t = await r.text();
  try { const j = t?JSON.parse(t):{}; if(!r.ok) throw j; return j; }
  catch(e){ throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(t||'not json'), status:r.status||0 }; }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('../wallet/login.html'); throw new Error('locked'); } // переиспользуем старую страницу логина

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('../wallet/login.html'); return; }
  KEYS=await importKey(PASS, META);
})();

// canonical + sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API
const getBalance=(rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch=(txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim=(delegator,validator)=>fetchJSON(`${API}stake/claim`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy=(rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=$('#nonce'); if(n) n.value=String(j.nonce||0); }catch(e){}
});
$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(), amount=$('#amount')?.value.trim(), nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});

```

## FILE: /root/logos_lrb/www/wallet3/index.html  (size=3528b)
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self'; img-src 'self'; script-src 'self'; style-src 'self'">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LOGOS Wallet (v3)</title>
  <style>
    body{font-family:system-ui,Roboto,Arial,sans-serif;background:#0b0e11;color:#e6e6e6;margin:0}
    header{padding:12px 20px;background:#12161a;border-bottom:1px solid #1b2026}
    main{padding:20px} h3{margin:0}
    section{margin-bottom:20px}
    input,button{padding:8px 10px;border-radius:6px;border:none;font-size:14px}
    button{background:#2d6cdf;color:#fff;cursor:pointer;margin:4px 2px}
    .out{margin-top:10px;font-family:monospace;font-size:13px;white-space:pre-wrap}
  </style>
  <script>
    (async()=>{ // убьём SW/Cache на всякий случай
      try{
        if('serviceWorker' in navigator){
          for(const r of await navigator.serviceWorker.getRegistrations()) try{await r.unregister()}catch{}
        }
        if(window.caches){ for(const k of await caches.keys()) try{await caches.delete(k)}catch{} }
      }catch(e){}
    })();
  </script>
</head>
<body>
<header>
  <h3>LOGOS Wallet (v3)</h3>
  <div>node: <span id="node-url"></span> | head: <span id="head"></span></div>
</header>
<main>
  <section>
    <h4>Настройки</h4>
    <div>RID: <span id="rid"></span></div>
    <div>Баланс: <span id="balance"></span> | Nonce: <span id="nonce-show"></span></div>
    <input id="rid-balance" placeholder="RID для проверки"/>
    <button id="btn-balance">Баланс</button>
    <div id="out-balance" class="out"></div>
  </section>

  <section>
    <h4>Отправка</h4>
    <input id="to" placeholder="RID получателя"/>
    <input id="amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <input id="nonce" type="number" placeholder="Nonce"/>
    <button id="btn-nonce">NONCE</button>
    <button id="btn-send">Отправить</button>
    <div id="out-send" class="out"></div>
  </section>

  <section>
    <h4>Стейкинг</h4>
    <input id="validator" placeholder="RID валидатора"/>
    <input id="stake-amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <button id="btn-delegate">Delegate</button>
    <button id="btn-undelegate">Undelegate</button>
    <button id="btn-claim">Claim</button>
    <button id="btn-my">Мои делегации</button>
    <div id="out-stake" class="out"></div>
    <div id="out-my" class="out"></div>
  </section>
</main>

<script src="app.v3.js?v=3"></script>
<script>
  document.getElementById('node-url').textContent = location.origin;
  (async function tick(){
    try{
      const h=await (await fetch(location.origin+'/api/head')).json();
      document.getElementById('head').textContent=h.height;
      const rid=sessionStorage.getItem('logos_rid');
      if(rid){
        const bj=await (await fetch(location.origin+'/api/balance/'+encodeURIComponent(rid))).json();
        document.getElementById('rid').textContent=rid;
        document.getElementById('balance').textContent=bj.balance;
        document.getElementById('nonce-show').textContent=bj.nonce;
      }
    }catch(e){}
    setTimeout(tick,1500);
  })();
</script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.html  (size=3367b)
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.js  (size=7641b)
```javascript
// === БАЗА ===
const API = location.origin + '/api/';     // ГАРАНТИРОВАННЫЙ префикс
const enc = new TextEncoder();

const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));

function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// === НАДЁЖНЫЙ fetchJSON: ВСЕГДА JSON (даже при ошибке) ===
async function fetchJSON(url, opts) {
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const json = text ? JSON.parse(text) : {};
    if (!r.ok) throw json;
    return json;
  } catch(e) {
    // если прилетел текст/HTML — упакуем в JSON с сообщением
    throw { ok:false, error: (typeof e==='object' && e.error) ? e.error : (text || 'not json') };
  }
}

// === КЛЮЧИ/SESSION ===
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey = await deriveKey(pass, new Uint8Array(meta.salt));
  const pkcs8  = await aesDecrypt(aesKey, new Uint8Array(meta.iv_priv), new Uint8Array(meta.priv));
  const pubraw = await aesDecrypt(aesKey, new Uint8Array(meta.iv_pub),  new Uint8Array(meta.pub));
  const privateKey = await crypto.subtle.importKey('pkcs8', pkcs8, {name:'Ed25519'}, false, ['sign']);
  const publicKey  = await crypto.subtle.importKey('raw',   pubraw, {name:'Ed25519'}, true,  ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}

let KEYS=null, META=null;
(async ()=>{
  META = await idbGet('acct:'+RID);
  if (!META) { sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS = await importKey(PASS, META);
  $('#pub') && ($('#pub').value = `RID: ${RID}\npub: ${KEYS.pub_hex}`);
  $('#rid-balance') && ($('#rid-balance').value = RID);
})();

// === КАНОНИКА/ПОДПИСЬ ===
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(privateKey, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', privateKey, msg);
  return toHex(sig);
}

// === API HELPERS ===
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ txs })
  });
}
async function stakeDelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/delegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeUndelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/undelegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeClaim(delegator, validator){
  return fetchJSON(`${API}stake/claim`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:0 })
  });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// === UI ===
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid = ($('#rid-balance')?.value || RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to     = $('#to')?.value.trim();
    const amount = $('#amount')?.value.trim();
    const nonce  = $('#nonce')?.value.trim();
    if (!to || !amount || !nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{
    const res = await stakeMy(RID);
    $('#out-my') && ($('#out-my').textContent = JSON.stringify(res));
  }catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// кнопка NONCE (если есть)
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); $('#nonce') && ($('#nonce').value = String(j.nonce||0)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});

```

## FILE: /root/logos_lrb/www/wallet/app.v2.js  (size=7526b)
```javascript
// == CONFIG ==
const API = location.origin + '/api/';
const enc = new TextEncoder();

// == utils ==
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// == robust fetch: always JSON ==
async function fetchJSON(url, opts){
  try{
    const r = await fetch(url, opts);
    const text = await r.text();
    try {
      const js = text ? JSON.parse(text) : {};
      if(!r.ok) throw js;
      return js;
    } catch(parseErr){
      throw { ok:false, error:(text||'not json'), status:r.status||0 };
    }
  }catch(netErr){
    throw { ok:false, error:(netErr?.message||'network error') };
  }
}

// == session/keys ==
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  $('#pub') && ($('#pub').value=`RID: ${RID}\npub: ${KEYS.pub_hex}`);
  ($('#rid-balance')||{}).value = RID;
})();

// == canonical/sign ==
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// == API wrappers ==
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ txs }) });
}
async function stakeDelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/delegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeUndelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/undelegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeClaim(delegator,validator){
  return fetchJSON(`${API}stake/claim`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:0}) });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// == UI handlers ==
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to = ($('#to')||$('#rid-to'))?.value.trim();
    const amount = ($('#amount')||$('#sum')||$('#stake-amount'))?.value.trim();
    const nonce  = ($('#nonce')||$('#tx-nonce'))?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res = await stakeMy(RID); $('#out-my') && ($('#out-my').textContent = JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// nonce helper
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); ($('#nonce')||$('#tx-nonce')) && ((($('#nonce')||$('#tx-nonce')).value)=String(j.nonce||0)); }
  catch(e){ /* ignore */ }
});

```

## FILE: /root/logos_lrb/www/wallet/app.v3.js  (size=6952b)
```javascript
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// robust fetch → всегда JSON
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const js = text ? JSON.parse(text) : {};
    if (!r.ok) throw js;
    return js;
  } catch(e) {
    throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(text||'not json'), status:r.status||0 };
  }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  const pubEl=$('#pub'); if(pubEl) pubEl.value=`RID: ${RID}\npub: ${KEYS.pub_hex}`;
  const rb=$('#rid-balance'); if(rb) rb.value=RID;
})();

// canonical+sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API wrappers
const getBalance = (rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch = (txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate   = (delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,  {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate = (delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim      = (delegator,validator)=>fetchJSON(`${API}stake/claim`,            {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy         = (rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI handlers
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=($('#nonce')); if(n) n.value=String(j.nonce||0); } catch(e){}
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(); const amount=$('#amount')?.value.trim(); const nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});

```

## FILE: /root/logos_lrb/www/wallet/auth.js  (size=6002b)
```javascript
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /root/logos_lrb/www/wallet/index.html  (size=4490b)
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <!-- Жёсткое отключение кэша на уровне страницы -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self'; img-src 'self'; script-src 'self'; style-src 'self'">
  <title>LOGOS Wallet</title>
  <style>
    body{font-family:system-ui,Roboto,Arial,sans-serif;background:#0b0e11;color:#e6e6e6;margin:0}
    header{padding:12px 20px;background:#12161a;border-bottom:1px solid #1b2026}
    main{padding:20px}
    h3{margin:0;font-size:18px}
    section{margin-bottom:20px}
    input,button{padding:8px 10px;border-radius:6px;border:none;font-size:14px}
    button{background:#2d6cdf;color:white;cursor:pointer;margin:4px 2px}
    button:hover{background:#1b4fb5}
    .out{margin-top:10px;font-family:monospace;font-size:13px;white-space:pre-wrap}
  </style>
  <script>
    // Кардинально: на входе очищаем SW и Cache API,
    // чтобы ни одна старая версия не мешала.
    (async ()=>{
      try{
        if ('serviceWorker' in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          for (const r of regs) { try { await r.unregister(); } catch{} }
        }
        if (window.caches) {
          const keys = await caches.keys();
          for (const k of keys) { try { await caches.delete(k); } catch{} }
        }
        // Стираем старые версии из localStorage/sessionStorage, кроме наших полей
        const keep = new Set(['logos_pass','logos_rid']);
        for (const k of Object.keys(localStorage)) if (!keep.has(k)) localStorage.removeItem(k);
        for (const k of Object.keys(sessionStorage)) if (!keep.has(k)) sessionStorage.removeItem(k);
      }catch(e){}
    })();
  </script>
</head>
<body>
  <header>
    <h3>LOGOS Wallet</h3>
    <div id="node-info" class="muted">node: <span id="node-url"></span> | head: <span id="head"></span></div>
  </header>
  <main>
    <section>
      <h4>Настройки</h4>
      <div>RID: <span id="rid"></span></div>
      <div>Баланс: <span id="balance"></span> | Nonce: <span id="nonce-show"></span></div>
      <input id="rid-balance" placeholder="RID для проверки"/>
      <button id="btn-balance">Баланс</button>
      <div id="out-balance" class="out"></div>
    </section>

    <section>
      <h4>Отправка</h4>
      <input id="to" placeholder="RID получателя"/>
      <input id="amount" type="number" placeholder="Сумма (микро-LGN)"/>
      <input id="nonce" type="number" placeholder="Nonce"/>
      <button id="btn-nonce">NONCE</button>
      <button id="btn-send">Отправить</button>
      <div id="out-send" class="out"></div>
    </section>

    <section>
      <h4>Стейкинг</h4>
      <input id="validator" placeholder="RID валидатора"/>
      <input id="stake-amount" type="number" placeholder="Сумма (микро-LGN)"/>
      <button id="btn-delegate">Delegate</button>
      <button id="btn-undelegate">Undelegate</button>
      <button id="btn-claim">Claim</button>
      <button id="btn-my">Мои делегации</button>
      <div id="out-stake" class="out"></div>
      <div id="out-my" class="out"></div>
    </section>
  </main>

  <!-- новый js с версией (cache-buster) -->
  <script src="app.v3.js?v=3"></script>
  <script>
    document.getElementById('node-url').textContent = location.origin;
    async function updHead(){
      try{
        const r=await fetch(location.origin+'/api/head');
        const j=await r.json();
        document.getElementById('head').textContent=j.height;
        const rid=sessionStorage.getItem('logos_rid');
        if(rid){
          const br=await fetch(location.origin+'/api/balance/'+encodeURIComponent(rid));
          const bj=await br.json();
          document.getElementById('rid').textContent = rid;
          document.getElementById('balance').textContent = bj.balance;
          document.getElementById('nonce-show').textContent = bj.nonce;
        }
      }catch(e){}
    }
    setInterval(updHead,1500); updHead();
  </script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet.js  (size=5287b)
```javascript
// ===== CONFIG =====
const API_BASE = "/api"; // всё уходит через Nginx → 127.0.0.1:8080

// ===== UTILS =====
async function apiGet(path){
  const r = await fetch(`${API_BASE}${path}`, {method:'GET'});
  if(!r.ok) throw new Error(`GET ${path} -> ${r.status}`);
  return r.json();
}
async function apiPost(path, body){
  const r = await fetch(`${API_BASE}${path}`, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if(!r.ok){
    const t = await r.text().catch(()=> '');
    throw new Error(`POST ${path} -> ${r.status} ${t.slice(0,200)}`);
  }
  return r.json();
}
function $(q){ return document.querySelector(q); }
function setJson(el, obj){ el.textContent = JSON.stringify(obj, null, 2); }

// ===== PROFILE / BALANCE / NONCE =====
async function syncProfile(){
  const rid = $('#ridInput').value.trim();
  const prof = await apiGet(`/profile/${rid}`);
  $('#balanceBadge').textContent = prof.balance ?? '-';
  $('#nonceBadge').textContent   = (prof.nonce && prof.nonce.next) ?? '-';
  setJson($('#outBox'), prof);
  await refreshStakeChips(); // обновим чипы стейкинга
}

// ===== HISTORY =====
async function showHistory(){
  const rid = $('#ridInput').value.trim();
  const hist = await apiGet(`/history/${rid}`);
  setJson($('#historyBox'), hist);
}

// ===== STAKING =====
async function refreshStakeChips(){
  const rid = $('#ridValidator').value.trim() || $('#ridInput').value.trim();
  const s = await apiGet(`/stake/summary/${rid}`);
  $('#chipDelegated').textContent = String(s.delegated ?? 0);
  $('#chipEntries').textContent   = String(s.entries ?? 0);
  $('#chipClaimable').textContent = String(s.claimable ?? 0);
}
async function stakeDelegate(){
  const rid = $('#ridValidator').value.trim();
  const amount = Number($('#stakeAmount').value);
  const res = await apiPost(`/stake/delegate`, {validator: rid, amount});
  setJson($('#stakeOut'), res);
  await refreshStakeChips();
}
async function stakeUndelegate(){
  const rid = $('#ridValidator').value.trim();
  const amount = Number($('#unstakeAmount').value);
  const res = await apiPost(`/stake/undelegate`, {validator: rid, amount});
  setJson($('#stakeOut'), res);
  await refreshStakeChips();
}
async function stakeClaim(){
  const rid = $('#ridValidator').value.trim();
  const res = await apiPost(`/stake/claim`, {rid});
  setJson($('#stakeOut'), res);
  await refreshStakeChips();
}

// ===== TRANSFER =====
// Если у тебя есть локальная функция подписи → реализуй window.walletSign(canonBytes) и оставь поле #manualSig пустым.
// Иначе вставляй готовую подпись в #manualSig (HEX/Base64).
function toBE8(n){
  const a = new Uint8Array(8);
  new DataView(a.buffer).setBigUint64(0, BigInt(n));
  return a;
}
function concatBytes(...xs){
  let len = 0; for(const x of xs) len += x.length;
  const out = new Uint8Array(len);
  let off = 0; for(const x of xs){ out.set(x, off); off += x.length; }
  return out;
}
function canonBytes(from, to, amount, nonce){
  const enc = new TextEncoder();
  const sep = new Uint8Array([0x7c]); // '|'
  return concatBytes(
    enc.encode(from), sep,
    enc.encode(to), sep,
    toBE8(amount), sep,
    toBE8(nonce),
  );
}
async function sendTxSigned(tx){
  const res = await apiPost(`/submit_tx`, tx);
  setJson($('#txOut'), res);
  await syncProfile();
  await showHistory();
}

async function onSend(){
  const from = $('#ridInput').value.trim();
  const to   = $('#toRid').value.trim();
  const amount = Number($('#sendAmount').value);
  const nn = await apiGet(`/nonce/${from}`);
  const nonce = nn.next;

  let sig = $('#manualSig').value.trim();
  if(!sig && typeof window.walletSign === 'function'){
    const canon = canonBytes(from, to, amount, nonce);
    sig = await window.walletSign(canon); // должен вернуть HEX или Base64
  }
  if(!sig){
    setJson($('#txOut'), {ok:false, error:'Нет подписи: вставь HEX/Base64 в поле или реализуй walletSign(canon) в браузере'});
    return;
  }
  await sendTxSigned({from, to, amount, nonce, sig});
}

// ===== BINDINGS =====
window.addEventListener('DOMContentLoaded', ()=>{
  // Профиль
  $('#btnBalance').addEventListener('click', ()=> syncProfile().catch(e=> setJson($('#outBox'), {ok:false,error:e.message})));
  $('#btnSync').addEventListener('click', ()=> syncProfile().catch(e=> setJson($('#outBox'), {ok:false,error:e.message})));

  // История
  $('#btnShowHist').addEventListener('click', ()=> showHistory().catch(e=> setJson($('#historyBox'), {ok:false,error:e.message})));

  // Стейкинг
  $('#btnStakeDelegate').addEventListener('click', ()=> stakeDelegate().catch(e=> setJson($('#stakeOut'), {ok:false,error:e.message})));
  $('#btnStakeUndelegate').addEventListener('click', ()=> stakeUndelegate().catch(e=> setJson($('#stakeOut'), {ok:false,error:e.message})));
  $('#btnStakeClaim').addEventListener('click', ()=> stakeClaim().catch(e=> setJson($('#stakeOut'), {ok:false,error:e.message})));

  // Перевод
  $('#btnSend').addEventListener('click', ()=> onSend().catch(e=> setJson($('#txOut'), {ok:false,error:e.message})));
});

```

## FILE: /root/logos_lrb/www/wallet/login.html  (size=2647b)
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/staking.js  (size=2843b)
```javascript
// LOGOS Wallet — staking (prod)
async function stakeSign(op, validator, amount, nonce){
  const msg = `${session.rid}|${op}|${validator}|${amount||0}|${nonce}`;
  return await crypto.subtle.sign('Ed25519', session.privKey, new TextEncoder().encode(msg)).then(buf=>{
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  });
}
document.getElementById('btnDelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('delegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'delegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Delegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка delegate'; }
};
document.getElementById('btnUndelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('undelegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'undelegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Undelegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка undelegate'; }
};
document.getElementById('btnClaim').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('claim',validator,0,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'claim',validator,amount:0,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Claim OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка claim'; }
};

```

## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```css
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /root/logos_lrb/www/wallet/wallet.js  (size=9153b)
```javascript
// LOGOS Wallet core — PROD
// Подключение к API через /api (nginx proxy)
const BASE = location.origin + '/api';

// ===== IndexedDB =====
const DB_NAME='logos_wallet', DB_STORE='keys';
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=e=>{const db=e.target.result;if(!db.objectStoreNames.contains(DB_STORE))db.createObjectStore(DB_STORE,{keyPath:'rid'})};r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});}
async function idbPut(rec){const db=await idbOpen();await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readwrite');tx.objectStore(DB_STORE).put(rec);tx.oncomplete=res;tx.onerror=()=>rej(tx.error)});db.close();}
async function idbGet(rid){const db=await idbOpen();return await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readonly');const rq=tx.objectStore(DB_STORE).get(rid);rq.onsuccess=()=>res(rq.result||null);rq.onerror=()=>rej(rq.error);tx.oncomplete=()=>db.close()});}

// ===== UI refs =====
const ui={
  loginRid:document.getElementById('loginRid'), loginPass:document.getElementById('loginPass'),
  btnLogin:document.getElementById('btnLogin'), loginStatus:document.getElementById('loginStatus'),
  newPass:document.getElementById('newPass'), btnCreate:document.getElementById('btnCreate'), createStatus:document.getElementById('createStatus'),
  panel:document.getElementById('walletPanel'),
  ridView:document.getElementById('ridView'), balView:document.getElementById('balView'), nonceView:document.getElementById('nonceView'),
  toRid:document.getElementById('toRid'), amount:document.getElementById('amount'), btnSend:document.getElementById('btnSend'), sendStatus:document.getElementById('sendStatus'),
  ridStake:document.getElementById('ridStake'),
  histBody:document.getElementById('histBody'), btnMoreHist:document.getElementById('btnMoreHist'),
  tabs:[...document.querySelectorAll('.tab')],
  btnExport:document.getElementById('btnExport'), btnImport:document.getElementById('btnImport'), impFile:document.getElementById('impFile'),
  settingsInfo:document.getElementById('settingsInfo'), exportStatus:document.getElementById('exportStatus')
};

// ===== WebCrypto helpers =====
function hex(buf){return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function sha256(s){const h=await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return hex(h);}
async function pbkdf2(pass,salt,iters=300000){const key=await crypto.subtle.importKey('raw', new TextEncoder().encode(pass), 'PBKDF2', false, ['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2', hash:'SHA-256', salt, iterations:iters}, key, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);}
async function signHex(bytes){const sig=await crypto.subtle.sign('Ed25519', session.privKey, bytes); return hex(sig);}

// ===== Anti-bot PoW (на создание) =====
async function powCreate(){const ts=Date.now().toString();let n=0;for(;;){const h=await sha256(ts+'|'+n);if(h.startsWith('00000'))return{ts,nonce:n,h};n++; if(n%5000===0) await new Promise(r=>setTimeout(r));}}

// ===== Session =====
let session={rid:null, privKey:null, pubKeyRaw:null};

// ===== Balance/nonce =====
async function refreshBalance(){
  const enc=encodeURIComponent(session.rid);
  const r=await fetch(`${BASE}/balance/${enc}`); const j=await r.json();
  ui.balView.textContent=j.balance??0; ui.nonceView.textContent=j.nonce??0;
  return j;
}

// ===== Create wallet =====
ui.btnCreate.onclick = async ()=>{
  try{
    ui.createStatus.textContent='Генерация…';
    const pass = ui.newPass.value.trim();
    if(pass.length<8){ ui.createStatus.textContent='Сложнее пароль'; return; }
    await powCreate();

    const kp = await crypto.subtle.generateKey({name:'Ed25519'}, true, ['sign','verify']);
    const pubRaw = await crypto.subtle.exportKey('raw', kp.publicKey);
    const privRaw = await crypto.subtle.exportKey('pkcs8', kp.privateKey);

    const rid = 'Λ0@7.83Hzφ' + (await sha256(hex(pubRaw))).slice(0,6);

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const aek  = await pbkdf2(pass, salt);
    const enc  = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aek, privRaw);

    await idbPut({ rid, pub_hex: hex(pubRaw), enc_priv_b64: btoa(String.fromCharCode(...new Uint8Array(enc))), salt_hex: hex(salt), iv_hex: hex(iv) });

    ui.loginRid.value = rid; ui.loginPass.value = pass;
    ui.createStatus.textContent='OK — кошелёк создан';
  }catch(e){ console.error(e); ui.createStatus.textContent='Ошибка создания'; }
};

// ===== Login =====
ui.btnLogin.onclick = async ()=>{
  try{
    ui.loginStatus.textContent = 'Поиск…';
    const rid = ui.loginRid.value.trim(), pass = ui.loginPass.value.trim();
    const rec = await idbGet(rid);
    if(!rec){ ui.loginStatus.textContent = 'RID не найден в этом браузере'; return; }

    const salt = Uint8Array.from(rec.salt_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const iv   = Uint8Array.from(rec.iv_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const enc  = Uint8Array.from(atob(rec.enc_priv_b64), c=>c.charCodeAt(0));
    const aek  = await pbkdf2(pass, salt);
    const privRaw = await crypto.subtle.decrypt({name:'AES-GCM', iv}, aek, enc);
    const privKey = await crypto.subtle.importKey('pkcs8', privRaw, {name:'Ed25519'}, false, ['sign']);

    session = { rid, privKey, pubKeyRaw: Uint8Array.from(rec.pub_hex.match(/.{2}/g).map(h=>parseInt(h,16))).buffer };

    // UI
    document.getElementById('walletPanel').style.display='';
    document.getElementById('ridView').textContent = rid;
    document.getElementById('ridStake').textContent = rid;
    ui.loginStatus.textContent='OK';

    await refreshBalance();
    histCursor=null; ui.histBody.innerHTML=''; await loadHistoryPage();
  }catch(e){ console.error(e); ui.loginStatus.textContent='Ошибка входа'; }
};

// ===== Send TX =====
ui.btnSend.onclick = async ()=>{
  try{
    ui.sendStatus.textContent='Отправка…';
    const b=await refreshBalance();
    const to=ui.toRid.value.trim();
    const amt=Number(ui.amount.value);
    const nonce=(b.nonce??0)+1;

    const msg=`${session.rid}|${to}|${amt}|${nonce}`;
    const sig_hex = await signHex(new TextEncoder().encode(msg));

    // Лёгкий локальный троттлинг (anti-bot throttle)
    await new Promise(r=>setTimeout(r, 300 + Math.random()*500));

    const res = await fetch(`${BASE}/submit_tx`,{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,to,amount:amt,nonce,sig_hex})
    });
    const j=await res.json();
    ui.sendStatus.textContent = j.ok ? ('OK: '+(j.txid||'')) : ('ERR: '+j.info);
    await refreshBalance();
  }catch(e){ console.error(e); ui.sendStatus.textContent='Ошибка'; }
};

// ===== History (пагинация by height) =====
let histCursor=null;
async function loadHistoryPage(){
  const enc=encodeURIComponent(session.rid);
  let url=`${BASE}/archive/history/${enc}`; if(histCursor!=null) url+=`?before_height=${histCursor}`;
  const r=await fetch(url); const list=await r.json(); if(!Array.isArray(list) || list.length===0) return;
  histCursor = Number(list[list.length-1].height) - 1;
  const frag=document.createDocumentFragment();
  for(const t of list){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td class="mono">${String(t.txid).slice(0,16)}…</td><td class="mono">${t.from}</td><td class="mono">${t.to}</td><td>${t.amount}</td><td>${t.height}</td><td>${t.ts??''}</td>`;
    ui.histBody.appendChild(tr);
  }
}
ui.btnMoreHist.onclick = ()=> loadHistoryPage();

// ===== Tabs =====
ui.tabs.forEach(tab=>{
  tab.onclick=()=>{
    ui.tabs.forEach(t=>t.classList.remove('active')); tab.classList.add('active');
    const name=tab.dataset.tab;
    document.getElementById('tab-send').classList.toggle('hide', name!=='send');
    document.getElementById('tab-stake').classList.toggle('hide', name!=='stake');
    document.getElementById('tab-history').classList.toggle('hide', name!=='history');
    document.getElementById('tab-settings').classList.toggle('hide', name!=='settings');
  };
});

// ===== Export / Import =====
ui.btnExport.onclick = async ()=>{
  const rec = await idbGet(session.rid);
  const blob = new Blob([JSON.stringify(rec)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `logos_wallet_${session.rid}.json`; a.click();
  ui.exportStatus.textContent='Экспортирован зашифрованный бэкап';
};
ui.btnImport.onclick = ()=> ui.impFile.click();
ui.impFile.onchange = async (e)=>{
  try{
    const f=e.target.files[0]; const text=await f.text(); const rec=JSON.parse(text);
    if(!rec.rid || !rec.enc_priv_b64) throw new Error('bad backup');
    await idbPut(rec); ui.exportStatus.textContent='Импорт OK';
  }catch(err){ ui.exportStatus.textContent='Ошибка импорта'; }
};

```

--
_Generated by tools/make_full_book_v2.sh on 2025-09-24 14:38:05 UTC_

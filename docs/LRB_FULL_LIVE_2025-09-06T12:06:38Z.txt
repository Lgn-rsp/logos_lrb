# FULL LIVE SNAPSHOT — 2025-09-06T12:06:38Z
# sources: /root/logos_lrb + infra (/etc, /opt)
# size limit per file: 2000000 bytes


## FILE: /root/logos_lrb/Cargo.toml  (size=713b)
```
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```

## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/genesis.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
```
# LOGOS node (пример ENV)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_SLOT_MS=500
LRB_MAX_BLOCK_TX=10000
LRB_MEMPOOL_CAP=100000
LRB_MAX_AMOUNT=18446744073709551615
LRB_BRIDGE_MAX_PER_TX=10000000

# Секреты — задаются ТОЛЬКО вне репозитория:
# LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
# LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=<optional>

```

## FILE: /root/logos_lrb/configs/logos_config.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
```
# Wallet Proxy / Scanner (пример ENV)
# !!! НЕ коммить настоящие ключи/приватники !!!
ETH_PROVIDER_URL=https://mainnet.infura.io/v3/XXXX...
USDT_CONTRACT=0xdAC17F958D2ee523a2206206994597C13D831ec7

# hot-кошелёк оператора (для withdraw/fee)
HOT_WALLET_ADDRESS=0x...
HOT_WALLET_PRIVATE_KEY= # НЕ класть в git, подставлять только в прод окружении

```

## FILE: /root/logos_lrb/core/beta_rollout.yaml  (size=3586b)
```
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```

## FILE: /root/logos_lrb/core/offline_resonance.py  (size=5400b)
```
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```

## FILE: /root/logos_lrb/core/onboarding_sim.py  (size=5458b)
```
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```

## FILE: /root/logos_lrb/core/onboarding_ui.py  (size=5974b)
```
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```

## FILE: /root/logos_lrb/core/__pycache__/offline_resonance.cpython-312.pyc  (size=8437b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/onboarding_sim.cpython-312.pyc  (size=8606b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/onboarding_ui.cpython-312.pyc  (size=9904b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/resonance_analyzer.cpython-312.pyc  (size=5297b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/rid_builder.cpython-312.pyc  (size=7379b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/ritual_quest.cpython-312.pyc  (size=10852b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/rLGN_converter.cpython-312.pyc  (size=8767b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/resonance_analyzer.py  (size=3470b)
```
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```

## FILE: /root/logos_lrb/core/rid_builder.py  (size=5229b)
```
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```

## FILE: /root/logos_lrb/core/ritual_quest.py  (size=7912b)
```
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```

## FILE: /root/logos_lrb/core/rLGN_converter.py  (size=5518b)
```
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```

## FILE: /root/logos_lrb/docs/architecture.md  (size=10559b)
```
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```

## FILE: /root/logos_lrb/docs/LOGOS_LRB_BOOK/LOGOS_LRB_BOOK.md  (size=6534b)
```
# LOGOS LRB — Книга системы

---

## Глава 1. Архитектура репозитория

### 1. Дерево `/root/logos_lrb`
/root/logos_lrb
├── Cargo.toml / README.md
├── lrb_core/                  # Rust-ядро L1
│   └── src/{ledger.rs, rcp_engine.rs, phase_integrity.rs,
│            dynamic_balance.rs, spam_guard.rs, resonance.rs,
│            phase_consensus.rs, phase_filters.rs, quorum.rs, types.rs,…}
├── node/                      # Узел (Axum REST + gossip + метрики)
│   ├── Cargo.toml
│   ├── openapi/openapi.json
│   └── src/{main.rs, api.rs, admin.rs, bridge.rs, guard.rs,
│            gossip.rs, state.rs, peers.rs, fork.rs, metrics.rs, …}
├── modules/                   # uplink_*, external_phase_*, parser/…
├── www/
│   ├── wallet/                # Web Wallet (IndexedDB+WebCrypto)
│   └── explorer/              # Explorer (inline-JS, самодостаточный)
├── tools/                     # bench v4, e2e/load, SDK (TS)
├── scripts/                   # bootstrap_node.sh, healthcheck.sh, …
├── core/                      # аналитика/симуляции (py)
├── wallet-proxy/              # вспомогательные утилиты (py)
└── configs/                   # env-шаблоны, genesis.yaml

### 2. Роли директорий
- **lrb_core/** — ядро L1: ledger (sled), mempool, spam_guard, dynamic_balance, фазовые фильтры, Σ(t), финализация quorum=1.
- **node/** — REST-узел: `/healthz`, `/head`, `/balance/:rid`, `/submit_tx`, `/submit_tx_batch`, `/bridge/*`, `/economy`, `/history/:rid`, `/openapi.json`.
- **modules/** — uplink, external_phase, ritual_engine, analytics.
- **www/wallet/** — кошелёк: RID+пароль, AES-GCM (PBKDF2), Ed25519 (WebCrypto), batch-tx.
- **www/explorer/** — explorer: поиск RID/блока/nonce, история, последние блоки, автообновление.
- **tools/** — bench v4 (~10k tx/s), SDK (TS), e2e/load.
- **scripts/** — утилиты запуска/снапшотов.
- **configs/** — env и genesis.

---

## Глава 2. Инфраструктура (вне репозитория)

### 2.1 Пути/данные
/opt/logos/www/                 # прод-статика (wallet, explorer)  
/var/lib/logos/data.sled        # база блокчейна (sled)  
/var/lib/logos/node_key         # ключ ноды (если используется)  

### 2.2 systemd
/etc/systemd/system/logos-node.service  
/etc/systemd/system/logos-node.service.d/  
  ├─ data.conf        # LRB_DATA_PATH=/var/lib/logos/data.sled  
  ├─ zz-keys.conf     # ключи / ENV  
  ├─ ratelimit.conf   # лимиты QPS/Burst, bypass localhost  
  ├─ runas.conf       # user/group logos  
  ├─ security.conf    # ProtectSystem, NoNewPrivileges  
  └─ override.conf    # расширения  

### 2.3 nginx + TLS
/etc/nginx/conf.d/  
  ├─ 00_redirect_80.conf   # redirect 80→443  
  └─ 10_lrb_https.conf     # HTTPS, CSP, /api, /wallet, /explorer  

TLS: /etc/letsencrypt/live/<домен>/{fullchain.pem, privkey.pem}  

**CSP**:  
`default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'`  

**/explorer/**:  
`Cache-Control: no-store, no-cache, must-revalidate, max-age=0`  
`Pragma: no-cache`  
`Expires: 0`  

### 2.4 Мониторинг
- Prometheus: /etc/prometheus/prometheus.yml  
- Rules: /etc/prometheus/rules/lrb_core.yml  
- Alertmanager: /etc/alertmanager/alertmanager.yml (+ secrets.env: TELEGRAM_BOT_TOKEN, CHAT_ID)  
- Grafana: /etc/grafana/provisioning/{datasources,dashboards}/  
- Dashboards: /var/lib/grafana/dashboards/lrb_core.json  
- NodeExporter: 9100, Prometheus:9094, Alertmanager:9093, Grafana:3000  

### 2.5 Порты
| Компонент    | Порт | Комментарий           |
|--------------|------|-----------------------|
| nginx HTTPS  | 443  | wallet, explorer, API |
| nginx HTTP   | 80   | redirect → 443        |
| logos_node   | 8080 | REST (за nginx)       |
| prometheus   | 9094 |                       |
| alertmanager | 9093 |                       |
| node_exporter| 9100 |                       |
| grafana      | 3000 |                       |

---

## Глава 3. Функционал

- **Ledger**: sled, mempool, spam_guard, dynamic_balance.  
- **Consensus**: Σ(t), slot producer, финализация (quorum=1).  
- **Filters**: фазовые, phase_integrity.  
- **Crypto**: XChaCha20-Poly1305 (AEAD).  
- **REST**: healthz, head, balance, submit_tx, bridge, economy, history, openapi.json.  
- **Bridge**: idempotency, tickets, verify.  
- **Gossip**: блоки, голоса, Σ-подписи.  
- **Wallet**: WebCrypto, IndexedDB, batch-tx.  
- **Explorer**: история, поиск RID/блока, автообновление.  
- **Monitoring**: Prometheus/Grafana, alerting → Telegram.  
- **Bench v4**: ~10.6k tx/s.  

---

## Глава 4. Что работает сейчас

✔ Ядро (ledger, mempool, spam_guard, dynamic_balance).  
✔ REST-узел Axum 0.7 (все базовые маршруты).  
✔ Gossip, Σ(t) подписи.  
✔ rToken-мост (боевой, idempotent).  
✔ Экономика: hard-cap 81M, supply= minted−burned.  
✔ Инфра: systemd sandbox, nginx+TLS, healthcheck.timer.  
✔ Web Wallet (MVP), Explorer (inline-JS).  
✔ Prometheus+Grafana+Alertmanager+Telegram.  
✔ Bench v4: 10.6k tx/s.  

---

## Глава 5. Доработки до продакшена

1. Кворум >1, распределённый fork-choice.  
2. История блоков/tx (архив, индексы, полный explorer).  
3. Unit/chaos-тесты ядра.  
4. Мобильный кошелёк (Flutter).  
5. Web Wallet → WebCrypto+IndexedDB полностью.  
6. OpenAPI/SDK автоген (Go/Rust).  
7. Grafana-дашборды и оповещения.  
8. REST-защита: ACL/DoS guard с логированием атак.  

---

⚡ **Цель**: LOGOS LRB — резонансный блокчейн продакшен-уровня, готовый к миллионам пользователей, с web/mobile кошельком, безопасный и масштабируемый.

```

## FILE: /root/logos_lrb/docs/LRB_SNAPSHOT_20250904_1426.txt  (size=384296b)
```
# FULL CODE SNAPSHOT (logos_lrb) - Thu Sep  4 02:26:11 PM BST 2025
# root: /root/logos_lrb



## FILE: AUDIT_REPORT.md  (size=4963b)
```text
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: Cargo.toml  (size=713b)
```text
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: README.md  (size=841b)
```text
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: configs/genesis.yaml  (size=0b)
```text

```


## FILE: configs/logos_config.yaml  (size=0b)
```text

```


## FILE: core/beta_rollout.yaml  (size=3586b)
```text
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: core/offline_resonance.py  (size=5400b)
```text
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: core/onboarding_sim.py  (size=5458b)
```text
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: core/onboarding_ui.py  (size=5974b)
```text
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: core/rLGN_converter.py  (size=5518b)
```text
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: core/resonance_analyzer.py  (size=3470b)
```text
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: core/rid_builder.py  (size=5229b)
```text
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: core/ritual_quest.py  (size=7912b)
```text
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: docs/WORKFLOW.md  (size=5440b)
```text
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: docs/architecture.md  (size=10559b)
```text
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: infra/nginx/lrb_wallet.conf  (size=2666b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: infra/systemd/exec.conf  (size=85b)
```text
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/keys.conf  (size=226b)
```text
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/logos-node.service  (size=369b)
```text
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/logos-snapshot.service  (size=271b)
```text
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: infra/systemd/logos-snapshot.timer  (size=163b)
```text
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: infra/systemd/lrb-proxy.service  (size=395b)
```text
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/lrb-scanner.service  (size=378b)
```text
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/override.conf  (size=575b)
```text
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: infra/systemd/runas.conf  (size=143b)
```text
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: infra/systemd/security.conf  (size=337b)
```text
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/tuning.conf  (size=156b)
```text
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: infra/systemd/zz-consensus.conf  (size=137b)
```text
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: infra/systemd/zz-keys.conf  (size=417b)
```text
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/zz-logging.conf  (size=36b)
```text
[Service]
Environment=RUST_LOG=info

```


## FILE: lrb_core/Cargo.toml  (size=654b)
```text
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = { workspace = true }
thiserror = { workspace = true }
serde = { workspace = true }
serde_json.workspace = true
blake3 = { workspace = true }
bs58 = { workspace = true }
ed25519-dalek = { workspace = true }
rand = { workspace = true }
rand_core = { workspace = true }
sled = { workspace = true }
once_cell = { workspace = true }
uuid = { workspace = true }
time = { workspace = true }
tokio = { workspace = true }
base64.workspace = true
hex.workspace = true
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
sha2 = "0.10.9"

```


## FILE: lrb_core/src/anti_replay.rs  (size=947b)
```text
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self { ttl_ms, map: HashMap::new() }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: lrb_core/src/beacon.rs  (size=1781b)
```text
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::{time::Duration};
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop { t.tick().await; }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers.iter().any(|p| !(p.starts_with("http://") || p.starts_with("https://"))) {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: lrb_core/src/dynamic_balance.rs  (size=576b)
```text
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self { base_cost_microunits: base, slope_per_tx: slope }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: lrb_core/src/heartbeat.rs  (size=2076b)
```text
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(rid, HeartbeatState { last_seen_ms: now_ms });
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter().map(|(r, s)| (r.clone(), s.last_seen_ms)).collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: lrb_core/src/ledger.rs  (size=11298b)
```text
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: lrb_core/src/lib.rs  (size=552b)
```text
pub mod types;
pub mod phase_integrity;
pub mod spam_guard;
pub mod dynamic_balance;
pub mod ledger;
pub mod rcp_engine;
pub mod heartbeat;
pub mod beacon;
pub mod resonance;
pub mod quorum;
pub mod phase_consensus;
pub mod phase_filters;
pub mod sigpool;

pub use types::*;
pub use phase_integrity::*;
pub use spam_guard::*;
pub use dynamic_balance::*;
pub use ledger::*;
pub use rcp_engine::*;
pub use heartbeat::*;
pub use beacon::*;
pub use resonance::*;
pub use quorum::*;
pub use phase_consensus::*;
pub use phase_filters::*;
pub use sigpool::*;

```


## FILE: lrb_core/src/phase_consensus.rs  (size=1769b)
```text
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize { self.quorum_n }
    pub fn finalized(&self) -> u64 { self.finalized_h }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes.get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: lrb_core/src/phase_filters.rs  (size=1684b)
```text
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN").ok().map(|v| v == "1").unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',').filter_map(|s| s.trim().parse::<f64>().ok()).collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE").ok().and_then(|s| s.parse::<f64>().ok()).unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() { return 1.0; }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() { return true; }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: lrb_core/src/phase_integrity.rs  (size=544b)
```text
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig).map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: lrb_core/src/quorum.rs  (size=1192b)
```text
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, VerifyingKey, Verifier};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: lrb_core/src/rcp_engine.rs  (size=7015b)
```text
use crate::{ledger::Ledger, spam_guard::SpamGuard, dynamic_balance::DynamicBalance, types::*, phase_integrity};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use crate::sigpool::filter_valid_sigs_parallel;
use anyhow::Result;
use std::{sync::{Arc, Mutex}, time::{Duration, SystemTime, UNIX_EPOCH}};
use tokio::sync::{mpsc::{UnboundedSender, unbounded_channel}, broadcast};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key).ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key).ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap   = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx  = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount    = env_u64("LRB_MAX_AMOUNT",   u64::MAX/2);
        let slot_ms       = env_u64("LRB_SLOT_MS",      500);
        let quorum_n      = env_usize("LRB_QUORUM_N",   1);
        let sig_workers   = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> { self.ledger.clone() }
    pub fn proposer(&self) -> Rid { self.proposer.clone() }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) { *self.commit_tx.lock().unwrap() = Some(sender); }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> { self.guard.check_amount(amount) }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> { self.mempool_tx.clone() }
    pub fn mempool_len(&self) -> usize { self.mempool.lock().unwrap().len() }
    pub fn finalized_height(&self) -> u64 { self.consensus.lock().unwrap().finalized() }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() { continue; }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() { continue; }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() { continue; }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: lrb_core/src/resonance.rs  (size=1122b)
```text
use blake3::Hasher;
use crate::types::{Block, Tx};

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS { h.update(tag); }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs { mix_tx(&mut h, tx) }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: lrb_core/src/sigpool.rs  (size=1040b)
```text
use crate::types::Tx;
use crate::phase_integrity::verify_tx_signature;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() { return txs; }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res { out.append(&mut v); }
    }
    out
}

```


## FILE: lrb_core/src/spam_guard.rs  (size=782b)
```text
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self { max_mempool, max_tx_per_block, max_amount }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize { self.max_tx_per_block }
}

```


## FILE: lrb_core/src/types.rs  (size=3294b)
```text
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String,             // blake3 of canonical form
    pub from: Rid,              // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>,    // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,     // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 { return Err(anyhow!("bad pubkey len")); }
        if self.signature.len() != 64 { return Err(anyhow!("bad signature len")); }
        if self.amount == 0 { return Err(anyhow!("amount must be > 0")); }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: modules/beacon_emitter.rs  (size=7378b)
```text
// LOGOS Beacon Emitter — Λ0 Signal Broadcaster
// Автор: LOGOS Core Dev

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::{HashMap, HashSet};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct BeaconSignal {
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub channel: String, // "file", "radio", "json", "stdout", "lora", "ble", "satellite"
}

pub struct BeaconEmitter {
    pub default_symbol: String,
    pub default_freq: f64,
    pub default_phase: f64,
    pub channels: Vec<String>,
    pub log_file: String,
    pub last_emit_time: u64,
    pub min_interval_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl BeaconEmitter {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        BeaconEmitter {
            default_symbol: "Λ0".to_string(),
            default_freq: 7.83,
            default_phase: 0.0,
            channels: vec!["file".to_string(), "stdout".to_string(), "lora".to_string(), "ble".to_string(), "satellite".to_string()],
            log_file: "beacon_emitter_log.json".to_string(),
            last_emit_time: 0,
            min_interval_sec: 60,
            valid_symbols,
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_parameters(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Проверка символа, частоты и фазы
        self.valid_symbols.contains(symbol) &&
        (0.1 <= frequency && frequency <= 10000.0) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase)
    }

    pub fn emit(&mut self) -> bool {
        let now = Self::current_time();
        if now - self.last_emit_time < self.min_interval_sec {
            self.log_event("[SKIP] Beacon too frequent");
            return false;
        }

        // Проверка параметров
        if !self.validate_parameters(&self.default_symbol, self.default_freq, self.default_phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: symbol={}, freq={}, phase={}",
                self.default_symbol, self.default_freq, self.default_phase
            ));
            return false;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp() {
            self.log_event("[!] RCP не подтвердил сигнал");
            return false;
        }

        for ch in &self.channels {
            let signal = BeaconSignal {
                symbol: self.default_symbol.clone(),
                frequency: self.default_freq,
                phase: self.default_phase,
                timestamp: now,
                channel: ch.clone(),
            };

            match ch.as_str() {
                "file" => self.write_to_file(&signal),
                "stdout" => println!("[BEACON] {} @ {}Hz φ = {:.4}", signal.symbol, signal.frequency, signal.phase),
                "json" => self.export_to_json(&signal),
                "lora" => self.emit_to_lora(&signal), // Заглушка для LoRa
                "ble" => self.emit_to_ble(&signal),   // Заглушка для BLE
                "satellite" => self.emit_to_satellite(&signal), // Заглушка для satellite
                _ => self.log_event(&format!("[WARN] Unsupported channel: {}", ch)),
            }
        }

        self.last_emit_time = now;
        self.log_event(&format!(
            "[BEACON] Emitted: {} @ {}Hz φ={:.4} on channels: {:?}", 
            self.default_symbol, self.default_freq, self.default_phase, self.channels
        ));
        true
    }

    fn validate_with_rcp(&self) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        self.default_symbol == "Λ0" && (self.default_freq - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, signal: &BeaconSignal) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("beacon_emitter_out.txt")
        {
            let _ = writeln!(
                file,
                "[BEACON] {} @ {}Hz φ={:.4} [{}]",
                signal.symbol, signal.frequency, signal.phase, signal.timestamp
            );
        }
    }

    fn export_to_json(&self, signal: &BeaconSignal) {
        let json = serde_json::to_string_pretty(signal).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("beacon_emitter_out.json")
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn emit_to_lora(&self, signal: &BeaconSignal) {
        // Заглушка для LoRa
        self.log_event(&format!("[LORA] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_ble(&self, signal: &BeaconSignal) {
        // Заглушка для BLE
        self.log_event(&format!("[BLE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_satellite(&self, signal: &BeaconSignal) {
        // Заглушка для satellite
        self.log_event(&format!("[SATELLITE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"beacon_emitter\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/env_impact_tracker.py  (size=5447b)
```text
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: modules/external_phase_broadcaster.rs  (size=7992b)
```text
rust
// LOGOS External Phase Broadcaster
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BroadcastPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub confidence: f64,
    pub timestamp: u64,
    pub destination: String,    // "file", "sound", "radio", "ble"
}

pub struct ExternalPhaseBroadcaster {
    pub valid_symbols: HashSet<String>,
    pub supported_channels: HashSet<String>,
    pub lambda_zero: String,
    pub min_confidence: f64,
    pub log_file: String,
    pub state_file: String,
    pub last_broadcast: HashMap<String, u64>, // destination -> timestamp
    pub last_broadcast_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_interval_sec: u64,
    pub cipher_key: Vec<u8>,
}

impl ExternalPhaseBroadcaster {
    pub fn new() -> Self {
        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        let mut channels = HashSet::new();
        channels.insert("file".to_string());
        channels.insert("sound".to_string());
        channels.insert("radio".to_string());
        channels.insert("ble".to_string());

        ExternalPhaseBroadcaster {
            valid_symbols: symbols,
            supported_channels: channels,
            lambda_zero: "Λ0".to_string(),
            min_confidence: 0.6,
            log_file: "external_phase_broadcast_log.json".to_string(),
            state_file: "external_phase_broadcast_state.json".to_string(),
            last_broadcast: HashMap::new(),
            last_broadcast_rid: HashMap::new(),
            min_interval_sec: 30,
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate(&self, phase: &BroadcastPhase) -> bool {
        self.valid_symbols.contains(&phase.symbol) &&
        self.supported_channels.contains(&phase.destination) &&
        (0.1..=10000.0).contains(&phase.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase.phase) &&
        phase.confidence >= self.min_confidence &&
        self.validate_rid(&phase.rid)
    }

    pub fn broadcast(&mut self, phase: BroadcastPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты по каналу
        let last = self.last_broadcast.get(&phase.destination).cloned().unwrap_or(0);
        let adjusted_interval = if phase.symbol == self.lambda_zero {
            self.min_interval_sec / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval_sec
        };
        if now - last < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка по каналу");
            return false;
        }

        // Проверка частоты по RID
        let last_rid = self.last_broadcast_rid.get(&phase.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка от RID");
            return false;
        }

        // Валидация
        if !self.validate(&phase) {
            self.log_event(&phase, "[DROP] Неверная фаза, confidence или RID");
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&phase) {
            self.log_event(&phase, "[DROP] Analyzer отклонил фазу");
            return false;
        }

        match phase.destination.as_str() {
            "file" => self.write_to_file(&phase),
            "stdout" => println!("[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} (RID: {})", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid),
            "sound" => self.emit_sound(&phase),
            "radio" => self.emit_radio(&phase),
            "ble" => self.emit_ble(&phase),
            _ => self.log_event(&phase, "[WARN] Неизвестный канал"),
        }

        self.last_broadcast.insert(phase.destination.clone(), now);
        self.last_broadcast_rid.insert(phase.rid.clone(), now);
        self.save_state();
        self.log_event(&phase, "[BROADCAST] Фаза отправлена");
        true
    }

    fn validate_with_analyzer(&self, phase: &BroadcastPhase) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        phase.symbol == self.lambda_zero || (phase.frequency - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, phase: &BroadcastPhase) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("broadcast_phase_output.txt")
        {
            let _ = writeln!(file, "[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} RID={} [{}]", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, phase.timestamp);
        }
    }

    fn emit_sound(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_radio(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[RADIO] Эмиссия (не реализовано)");
    }

    fn emit_ble(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[BLE] Эмиссия (не реализовано)");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_broadcast).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, phase: &BroadcastPhase, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_broadcast\", \"symbol\": \"{}\", \"freq\": {:.2}, \"phase\": {:.3}, \"conf\": {:.2}, \"rid\": \"{}\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, message, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/external_phase_link.rs  (size=6896b)
```text
rust
// LOGOS External Phase Link — Bridge to External Phase Sources
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExternalPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub source: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub confidence: f64,        // Оценка достоверности [0.0 - 1.0]
}

pub struct ExternalPhaseLink {
    pub accepted_sources: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub min_confidence: f64,
    pub network_activity: f64,
    pub last_received: HashMap<String, u64>, // source -> timestamp
    pub min_receive_interval: u64,
}

impl ExternalPhaseLink {
    pub fn new() -> Self {
        let mut sources = HashSet::new();
        sources.insert("external_device".to_string());
        sources.insert("oracle_feed".to_string());
        sources.insert("bio_input".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        ExternalPhaseLink {
            accepted_sources: sources,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "external_phase_link_log.json".to_string(),
            state_file: "external_phase_link_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Заменить на реальный ключ
            min_confidence: 0.6,
            network_activity: 1.0,
            last_received: HashMap::new(),
            min_receive_interval: 60,
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Адаптивный порог достоверности
        self.network_activity = activity.clamp(0.1, 10.0);
        self.min_confidence = (0.6 / self.network_activity).clamp(0.4, 0.8);
        self.log_event(&format!(
            "[INFO] Network activity updated: {:.2}, min_confidence={:.2}",
            self.network_activity, self.min_confidence
        ));
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_input(&self, ep: &ExternalPhase) -> bool {
        self.accepted_sources.contains(&ep.source) &&
        self.valid_symbols.contains(&ep.symbol) &&
        (0.1..=10000.0).contains(&ep.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&ep.phase) &&
        ep.confidence >= self.min_confidence &&
        self.validate_rid(&ep.rid)
    }

    pub fn forward_phase(&self, ep: ExternalPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма
        let last = self.last_received.get(&ep.source).cloned().unwrap_or(0);
        let adjusted_interval = if ep.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last < adjusted_interval {
            self.log_event(&format!("[DROP] Слишком частый приём от '{}'", ep.source));
            return false;
        }

        // Валидация
        if !self.validate_input(&ep) {
            self.log_event(&format!("[DROP] Неверный сигнал от '{}': RID={}, symbol={}, conf={:.2}",
                ep.source, ep.rid, ep.symbol, ep.confidence));
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&ep) {
            self.log_event(&format!("[REJECT] RCP/analyzer отклонил фазу от '{}'", ep.source));
            return false;
        }

        // Сохранение состояния
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.last_received.insert(ep.source.clone(), now);
        self.save_state(&ep);

        self.log_event(&format!(
            "[LINK] Принята внешняя фаза от {}: RID={} {} @ {:.3}Hz φ={:.4}, conf={:.2}",
            ep.source, ep.rid, ep.symbol, ep.frequency, ep.phase, ep.confidence
        ));
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, ep: &ExternalPhase) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        ep.symbol == self.lambda_zero || (ep.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self, ep: &ExternalPhase) {
        let state = serde_json::to_string(ep).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
                let _ = file.write_all(b"\n");
            }
        }
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_link\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/genesis_fragment_seeds.rs  (size=6958b)
```text
rust
// LOGOS Genesis Fragment Seeds
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use shamirsecretsharing::{split_secret, recover_secret};

#[derive(Debug, Serialize, Deserialize)]
pub struct SeedFragment {
    pub node_id: String,
    pub fragment: Vec<u8>,
    pub timestamp: u64,
    pub symbol: String, // Связь с Λ0
}

pub struct GenesisFragmentSeeds {
    pub fragments: HashMap<String, SeedFragment>,
    pub required_shares: usize,
    pub total_shares: usize,
    pub original_seed: Vec<u8>,
    pub log_file: String,
    pub state_file: String,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub store_timestamps: HashMap<String, u64>, // node_id -> last store time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl GenesisFragmentSeeds {
    pub fn new(seed: Vec<u8>, total: usize, required: usize) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        GenesisFragmentSeeds {
            fragments: HashMap::new(),
            required_shares: required,
            total_shares: total,
            original_seed: seed,
            log_file: "genesis_fragment_log.json".to_string(),
            state_file: "genesis_fragment_state.json".to_string(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            store_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_node_id_and_symbol(&self, node_id: &str, symbol: &str) -> bool {
        node_id.contains(|c: char| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn generate_shards(&mut self) -> Vec<(usize, Vec<u8>)> {
        let shards = split_secret(self.total_shares, self.required_shares, &self.original_seed)
            .expect("Ошибка при фрагментации Λ0");
        self.log_event("[FRAG] Сгенерированы фрагменты ядра");
        shards
    }

    pub fn store_fragment(&mut self, node_id: &str, fragment: Vec<u8>, symbol: &str) -> bool {
        let now = Self::current_time();

        // Ограничение частоты
        let last_store = self.store_timestamps.get(node_id).cloned().unwrap_or(0);
        if now - last_store < 60 {
            self.log_event(&format!("[!] Слишком частое сохранение от {}", node_id));
            return false;
        }
        self.store_timestamps.insert(node_id.to_string(), now);

        // Валидация node_id и symbol
        if !self.validate_node_id_and_symbol(node_id, symbol) {
            self.log_event(&format!("[!] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        // Проверка связи с Λ0 (заглушка для resonance_analyzer.py)
        if symbol != self.lambda_zero && !self.validate_with_analyzer(node_id, symbol) {
            self.log_event(&format!("[!] Символ {} не связан с Λ0", symbol));
            return false;
        }

        let entry = SeedFragment {
            node_id: node_id.to_string(),
            fragment,
            timestamp: now,
            symbol: symbol.to_string(),
        };
        self.fragments.insert(node_id.to_string(), entry);
        self.save_state();
        self.log_event(&format!("[STORE] Фрагмент принят от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn recover_seed(&self) -> Option<Vec<u8>> {
        if self.fragments.len() < self.required_shares {
            self.log_event(&format!(
                "[WARN] Недостаточно фрагментов: {}/{}",
                self.fragments.len(), self.required_shares
            ));
            return None;
        }

        let shares: Vec<(usize, Vec<u8>)> = self
            .fragments
            .iter()
            .take(self.required_shares)
            .enumerate()
            .map(|(i, (_, frag))| (i + 1, frag.fragment.clone()))
            .collect();

        match recover_secret(&shares) {
            Ok(seed) => {
                self.log_event("[SUCCESS] Λ0 восстановлен из фрагментов");
                Some(seed)
            }
            Err(e) => {
                self.log_event(&format!("[FAIL] Ошибка восстановления Λ0: {}", e));
                None
            }
        }
    }

    fn validate_with_analyzer(&self, _node_id: &str, symbol: &str) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        symbol == self.lambda_zero
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.fragments).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"genesis_fragment\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/go_to_market.yaml  (size=3633b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: modules/heartbeat_monitor.rs  (size=7769b)
```text
rust
// LOGOS Network Heartbeat Monitor
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions, File};
use std::io::{Write, Read};
use std::net::{UdpSocket, SocketAddr};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

#[derive(Debug, Serialize, Deserialize)]
pub struct Heartbeat {
    pub rid: String,
    pub timestamp: u64,
    pub symbol: String,
    pub Σ_t: f64,
}

pub struct HeartbeatMonitor {
    pub active_nodes: HashMap<String, Heartbeat>,
    pub timeout_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub udp_port: u16,
    pub heartbeat_timestamps: HashMap<String, u64>, // RID -> last heartbeat time
}

impl HeartbeatMonitor {
    pub fn new(port: u16, timeout: u64) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        HeartbeatMonitor {
            active_nodes: HashMap::new(),
            timeout_sec: timeout,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "heartbeat_log.json".to_string(),
            state_file: "heartbeat_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            udp_port: port,
            heartbeat_timestamps: HashMap::new(),
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn listen(&mut self) {
        let socket = UdpSocket::bind(format!("0.0.0.0:{}", self.udp_port)).expect("Не удалось привязать сокет");
        let mut buf = [0u8; 1024];
        loop {
            match socket.recv_from(&mut buf) {
                Ok((len, addr)) => {
                    let raw = &buf[..len];
                    if let Some(hb) = self.parse_heartbeat(raw) {
                        self.register_heartbeat(hb, addr);
                    }
                }
                Err(e) => {
                    self.log_event(&format!("[ERR] UDP receive error: {}", e));
                }
            }
        }
    }

    pub fn parse_heartbeat(&self, raw: &[u8]) -> Option<Heartbeat> {
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut raw_buf = raw.to_vec();
        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut raw_buf) {
            if let Ok(hb) = serde_json::from_slice::<Heartbeat>(decrypted) {
                if self.validate_heartbeat(&hb) {
                    return Some(hb);
                }
            }
        }
        self.log_event("[ERR] Ошибка парсинга или валидации heartbeat");
        None
    }

    pub fn validate_heartbeat(&self, hb: &Heartbeat) -> bool {
        // Проверка RID, символа и Σ(t)
        let valid = self.validate_rid(&hb.rid) &&
                    self.valid_symbols.contains(&hb.symbol) &&
                    hb.Σ_t.is_finite() &&
                    // Проверка Λ0
                    (hb.symbol == self.lambda_zero || (hb.Σ_t.abs() < 10.0)); // Более мягкие условия для Λ0
        if !valid {
            self.log_event(&format!("[!] Недопустимый heartbeat от RID {}: symbol={}, Σ(t)={}", 
                hb.rid, hb.symbol, hb.Σ_t));
        }
        valid
    }

    pub fn register_heartbeat(&mut self, hb: Heartbeat, addr: SocketAddr) {
        let now = Self::current_time();

        // Проверка частоты heartbeat
        let last_heartbeat = self.heartbeat_timestamps.get(&hb.rid).cloned().unwrap_or(0);
        let adjusted_timeout = if hb.symbol == self.lambda_zero {
            self.timeout_sec * 2 // Увеличенный таймаут для Λ0
        } else {
            self.timeout_sec
        };
        if now - last_heartbeat < adjusted_timeout / 10 {
            self.log_event(&format!("[!] Слишком частый heartbeat от RID {}", hb.rid));
            return;
        }
        self.heartbeat_timestamps.insert(hb.rid.clone(), now);

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&hb) {
            self.log_event(&format!("[!] RCP не подтвердил heartbeat от RID {}", hb.rid));
            return;
        }

        self.active_nodes.insert(hb.rid.clone(), hb.clone());
        self.save_state();
        self.log_event(&format!(
            "[HEARTBEAT] RID {} — Σ(t) = {:.4} @ {} (from {})",
            hb.rid, hb.Σ_t, hb.timestamp, addr
        ));
    }

    pub fn validate_with_rcp(&self, _hb: &Heartbeat) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        true // TODO: Реализовать
    }

    pub fn purge_inactive(&mut self) {
        let now = Self::current_time();
        self.active_nodes.retain(|rid, hb| {
            let adjusted_timeout = if hb.symbol == self.lambda_zero {
                self.timeout_sec * 2
            } else {
                self.timeout_sec
            };
            if now - hb.timestamp <= adjusted_timeout {
                true
            } else {
                self.log_event(&format!("[CLEANUP] Удалён неактивный RID {}", rid));
                false
            }
        });
        self.save_state();
        self.log_event("[CLEANUP] Удалены неактивные узлы");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.active_nodes).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"heartbeat\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = log_entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/legacy_migrator.rs  (size=6851b)
```text
// LOGOS Legacy Blockchain Migrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct LegacyTx {
    pub origin_chain: String,
    pub legacy_address: String,
    pub tx_hash: String,
    pub amount: f64,
    pub timestamp: u64,
    pub symbol_hint: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MigratedTx {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub amount: f64,
    pub migrated_from: String,
    pub original_tx_hash: String,
    pub timestamp: u64,
}

pub struct LegacyMigrator {
    pub migration_log: String,
    pub symbol_map: HashMap<String, String>,
    pub frequency_map: HashMap<String, f64>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl LegacyMigrator {
    pub fn new() -> Self {
        let mut symbol_map = HashMap::new();
        symbol_map.insert("ethereum".to_string(), "☉".to_string());
        symbol_map.insert("cosmos".to_string(), "??".to_string());
        symbol_map.insert("polkadot".to_string(), "♁".to_string());

        let mut frequency_map = HashMap::new();
        frequency_map.insert("ethereum".to_string(), 432.0);
        frequency_map.insert("cosmos".to_string(), 7.83);
        frequency_map.insert("polkadot".to_string(), 1.618);

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        LegacyMigrator {
            migration_log: "legacy_migration_log.json".to_string(),
            symbol_map,
            frequency_map,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_tx(&self, tx: &LegacyTx) -> bool {
        // Проверка данных транзакции
        !tx.origin_chain.is_empty() &&
        !tx.legacy_address.is_empty() &&
        !tx.tx_hash.is_empty() &&
        tx.amount > 0.0 &&
        tx.timestamp > 0 &&
        tx.symbol_hint.as_ref().map_or(true, |s| self.valid_symbols.contains(s))
    }

    pub fn migrate(&self, legacy_tx: LegacyTx) -> Option<MigratedTx> {
        if !self.validate_tx(&legacy_tx) {
            self.log_migration_event(&format!(
                "[!] Недопустимая транзакция: chain={}, amount={}",
                legacy_tx.origin_chain, legacy_tx.amount
            ));
            return None;
        }

        let chain = legacy_tx.origin_chain.to_lowercase();
        let symbol = legacy_tx.symbol_hint.clone().unwrap_or_else(|| {
            self.symbol_map.get(&chain).cloned().unwrap_or(self.lambda_zero.clone())
        });

        if !self.valid_symbols.contains(&symbol) {
            self.log_migration_event(&format!("[!] Недопустимый символ: {}", symbol));
            return None;
        }

        let freq = self.frequency_map.get(&chain).cloned().unwrap_or(7.83);
        let phase = self.estimate_phase(&legacy_tx);

        // Проверка фазы через RCP (заглушка)
        if !self.validate_with_rcp(&symbol, freq, phase) {
            self.log_migration_event(&format!(
                "[!] RCP не подтвердил: {} @ {} Hz, φ={:.4}",
                symbol, freq, phase
            ));
            return None;
        }

        let rid = format!("{}@{}Hzφ{:.4}", symbol, freq, phase);

        let migrated = MigratedTx {
            rid: rid.clone(),
            symbol,
            frequency: freq,
            phase,
            amount: legacy_tx.amount,
            migrated_from: legacy_tx.origin_chain.clone(),
            original_tx_hash: legacy_tx.tx_hash.clone(),
            timestamp: legacy_tx.timestamp,
        };

        self.log_migration(&migrated);
        Some(migrated)
    }

    fn validate_with_rcp(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        symbol == self.lambda_zero || (frequency - 7.83).abs() < 0.1
    }

    fn estimate_phase(&self, tx: &LegacyTx) -> f64 {
        let h = tx.tx_hash.bytes().fold(0u64, |acc, b| acc.wrapping_add(b as u64));
        let phase = ((h % 6283) as f64 / 1000.0) - std::f64::consts::PI;
        phase
    }

    fn log_migration(&self, migrated: &MigratedTx) {
        let json = serde_json::to_string(migrated).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap(); // Заглушка для nonce
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.migration_log)
            {
                let _ = writeln!(file, "{}", String::from_utf8_lossy(&in_out));
            }
        }
    }

    fn log_migration_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"legacy_migration\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.migration_log)
        {
            let _ = file.write_all(log_entry.as_bytes());
        }
    }

    pub fn load_legacy_batch(&self, path: &str) -> Vec<LegacyTx> {
        if let Ok(mut f) = File::open(path) {
            let mut contents = String::new();
            if f.read_to_string(&mut contents).is_ok() {
                if let Ok(list) = serde_json::from_str::<Vec<LegacyTx>>(&contents) {
                    return list.into_iter().filter(|tx| self.validate_tx(tx)).collect();
                }
            }
        }
        self.log_migration_event(&format!("[!] Ошибка загрузки батча: {}", path));
        vec![]
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/maintenance_strategy.yaml  (size=2361b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: modules/resonance_analytics_frontend.tsx  (size=4632b)
```text
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: modules/resonance_emergency_plan.yaml  (size=3420b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: modules/resonance_meshmap.yaml  (size=1877b)
```text
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: modules/resonance_tutor.py  (size=6414b)
```text
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: modules/ritual_engine.rs  (size=7546b)
```text
rust
// LOGOS Ritual Engine
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualAction {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualDefinition {
    pub id: String,
    pub title: String,
    pub required_symbol: String,
    pub required_frequency: f64,
    pub required_phase: Option<f64>,
    pub min_phase: Option<f64>,
    pub max_phase: Option<f64>,
    pub reward_lgn: f64,
    pub repeatable: bool,
}

pub struct RitualEngine {
    pub rituals: HashMap<String, RitualDefinition>,
    pub completed: HashMap<String, Vec<String>>, // RID -> list of ritual IDs
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub action_timestamps: HashMap<String, u64>, // RID -> last action time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl RitualEngine {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        RitualEngine {
            rituals: HashMap::new(),
            completed: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "ritual_engine_log.json".to_string(),
            action_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_rid_and_symbol(&self, rid: &str, symbol: &str) -> bool {
        !rid.is_empty() &&
        rid.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn load_rituals(&mut self, path: &str) {
        if let Ok(file) = std::fs::read_to_string(path) {
            if let Ok(map) = serde_json::from_str::<Vec<RitualDefinition>>(&file) {
                for r in map {
                    if self.valid_symbols.contains(&r.required_symbol) {
                        self.rituals.insert(r.id.clone(), r);
                    } else {
                        self.log_event(&format!("[!] Недопустимый символ в ритуале: {}", r.required_symbol));
                    }
                }
                self.log_event("[INFO] Загружены ритуалы");
            } else {
                self.log_event("[!] Ошибка парсинга ритуалов");
            }
        } else {
            self.log_event(&format!("[!] Ошибка чтения файла ритуалов: {}", path));
        }
    }

    pub fn submit_action(&mut self, action: RitualAction) -> Option<f64> {
        let now = Self::current_time();

        // Проверка частоты действий
        let last_action = self.action_timestamps.get(&action.rid).cloned().unwrap_or(0);
        if now - last_action < 60 {
            self.log_event(&format!("[!] Слишком частое действие от RID {}", action.rid));
            return None;
        }
        self.action_timestamps.insert(action.rid.clone(), now);

        // Валидация RID и символа
        if !self.validate_rid_and_symbol(&action.rid, &action.symbol) {
            self.log_event(&format!("[!] Недопустимый RID или символ: {}, {}", action.rid, action.symbol));
            return None;
        }

        // Проверка параметров
        if action.frequency <= 0.0 || action.frequency > 10000.0 ||
           !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&action.phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: f={}, φ={:.4}",
                action.frequency, action.phase
            ));
            return None;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&action) {
            self.log_event(&format!(
                "[!] RCP не подтвердил: {} @ {}Hz φ={:.4}",
                action.symbol, action.frequency, action.phase
            ));
            return None;
        }

        for (id, ritual) in self.rituals.iter() {
            if !ritual.repeatable && self.completed.get(&action.rid).map_or(false, |r| r.contains(id)) {
                continue;
            }

            if ritual.required_symbol != action.symbol {
                continue;
            }

            if (ritual.required_frequency - action.frequency).abs() > 0.1 {
                continue;
            }

            if let Some(req_phase) = ritual.required_phase {
                if (req_phase - action.phase).abs() > 0.05 {
                    continue;
                }
            }

            if let Some(min) = ritual.min_phase {
                if action.phase < min {
                    continue;
                }
            }

            if let Some(max) = ritual.max_phase {
                if action.phase > max {
                    continue;
                }
            }

            let reward = if action.symbol == self.lambda_zero {
                ritual.reward_lgn * 1.2 // Бонус для Λ0
            } else {
                ritual.reward_lgn
            };

            self.completed
                .entry(action.rid.clone())
                .or_default()
                .push(ritual.id.clone());

            self.log_event(&format!(
                "[RITUAL] RID {} выполнил ритуал {}: {} (+{} LGN)",
                action.rid, ritual.id, ritual.title, reward
            ));
            return Some(reward);
        }

        self.log_event(&format!("[MISS] RID {} не активировал ни один ритуал", action.rid));
        None
    }

    fn validate_with_rcp(&self, action: &RitualAction) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        action.symbol == self.lambda_zero || (action.frequency - 7.83).abs() < 0.1
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"ritual_engine\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/symbolic_parser.py  (size=4615b)
```text
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: modules/uplink_controller.rs  (size=7680b)
```text
rust
// LOGOS Uplink Controller — External Uplink & Relay Orchestrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkEvent {
    pub symbol: String,
    pub channel: String, // "lora", "ble", "satellite", "sound", "qr"
    pub status: String,  // "emitted", "received", "failed"
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkController {
    pub supported_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>,
    pub log_file: String,
    pub emit_timestamps: HashMap<String, u64>, // channel -> last emit time
    pub min_emit_interval: u64, // Минимальный интервал в секундах
}

impl UplinkController {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("satellite".to_string());
        channels.insert("sound".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkController {
            supported_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            log_file: "uplink_log.json".to_string(),
            emit_timestamps: HashMap::new(),
            min_emit_interval: 60, // 1 минута
        }
    }

    pub fn validate_symbol(&self, symbol: &str) -> bool {
        self.valid_symbols.contains(symbol)
    }

    pub fn validate_channel(&self, channel: &str) -> bool {
        self.supported_channels.contains(channel)
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        // Проверка размера и формата payload
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn emit(&self, symbol: &str, channel: &str, payload: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты эмиссии
        let last_emit = self.emit_timestamps.get(channel).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_emit_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_emit_interval
        };
        if now - last_emit < adjusted_interval {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Слишком частая эмиссия");
            return false;
        }

        // Валидация
        if !self.validate_symbol(symbol) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый символ");
            return false;
        }

        if !self.validate_channel(channel) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый канал");
            return false;
        }

        if !self.validate_payload(payload) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый payload");
            return false;
        }

        // Реализация каналов
        let event = UplinkEvent {
            symbol: symbol.to_string(),
            channel: channel.to_string(),
            status: "emitted".to_string(),
            payload: payload.to_string(),
            timestamp: now,
        };

        match channel {
            "lora" => self.emit_to_lora(&event),
            "ble" => self.emit_to_ble(&event),
            "satellite" => self.emit_to_satellite(&event),
            "sound" => self.emit_to_sound(&event),
            "qr" => self.emit_to_qr(&event),
            _ => {
                self.log_event(event.clone(), &format!("[WARN] Unsupported channel: {}", channel));
                return false;
            }
        }

        // Обновление времени эмиссии
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.emit_timestamps.insert(channel.to_string(), now);
        self.log_event(event, "Успешная эмиссия");
        true
    }

    fn emit_to_lora(&self, event: &UplinkEvent) {
        // Заглушка для LoRa
        self.log_event(event.clone(), "[LORA] Эмиссия (не реализовано)");
    }

    fn emit_to_ble(&self, event: &UplinkEvent) {
        // Заглушка для BLE
        self.log_event(event.clone(), "[BLE] Эмиссия (не реализовано)");
    }

    fn emit_to_satellite(&self, event: &UplinkEvent) {
        // Заглушка для satellite
        self.log_event(event.clone(), "[SATELLITE] Эмиссия (не реализовано)");
    }

    fn emit_to_sound(&self, event: &UplinkEvent) {
        // Заглушка для sound
        self.log_event(event.clone(), "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_to_qr(&self, event: &UplinkEvent) {
        // Заглушка для QR
        self.log_event(event.clone(), "[QR] Эмиссия (не реализовано)");
    }

    fn log_event(&self, event: UplinkEvent, message: &str) {
        let json = serde_json::to_string(&event).unwrap_or_default();
        let log_entry = format!(
            "{{\"event\": \"uplink_controller\", \"message\": \"{}\", \"data\": {}, \"timestamp\": {}}}\n",
            message, json, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buffer = log_entry.as_bytes().to_vec();

        if aead.seal_in_place_append_tag(nonce, &[], &mut buffer).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buffer);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/uplink_router.rs  (size=7301b)
```text
rust
// LOGOS Uplink Router — External Signal Receiver
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkSignal {
    pub rid: String, // Добавлено для идентификации узла
    pub channel: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkRouter {
    pub valid_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub last_received: HashMap<String, u64>, // channel -> timestamp
    pub last_received_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_receive_interval: u64,
}

impl UplinkRouter {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("sound".to_string());
        channels.insert("satellite".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkRouter {
            valid_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "uplink_router_log.json".to_string(),
            state_file: "uplink_router_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            last_received: HashMap::new(),
            last_received_rid: HashMap::new(),
            min_receive_interval: 10,
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn receive(&mut self, signal: UplinkSignal) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма по каналу
        let last_channel = self.last_received.get(&signal.channel).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last_channel < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём по каналу");
            return false;
        }

        // Проверка частоты приёма по RID
        let last_rid = self.last_received_rid.get(&signal.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём от RID");
            return false;
        }

        // Валидация RID
        if !self.validate_rid(&signal.rid) {
            self.log_event(&signal, "[DROP] Недопустимый RID");
            return false;
        }

        // Валидация символа и канала
        if !self.valid_symbols.contains(&signal.symbol) {
            self.log_event(&signal, "[DROP] Недопустимый символ");
            return false;
        }
        if !self.valid_channels.contains(&signal.channel) {
            self.log_event(&signal, "[DROP] Недопустимый канал");
            return false;
        }

        // Проверка частоты/фазы
        if signal.frequency <= 0.0 || signal.frequency > 10000.0 || !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&signal.phase) {
            self.log_event(&signal, "[DROP] Неверная частота или фаза");
            return false;
        }

        // Проверка payload
        if !self.validate_payload(&signal.payload) {
            self.log_event(&signal, "[DROP] Недопустимый payload");
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&signal) {
            self.log_event(&signal, "[DROP] RCP или analyzer отклонил сигнал");
            return false;
        }

        self.last_received.insert(signal.channel.clone(), now);
        self.last_received_rid.insert(signal.rid.clone(), now);
        self.save_state();
        self.log_event(&signal, "[OK] Сигнал принят");
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, signal: &UplinkSignal) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_received).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, signal: &UplinkSignal, msg: &str) {
        let entry = format!(
            "{{\"event\":\"uplink_router\",\"message\":\"{}\",\"rid\":\"{}\",\"channel\":\"{}\",\"symbol\":\"{}\",\"frequency\":{},\"phase\":{},\"timestamp\":{}}}\n",
            msg, signal.rid, signal.channel, signal.symbol, signal.frequency, signal.phase, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: node/Cargo.toml  (size=557b)
```text
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
tokio = { version = "1", features = ["full"] }
axum = "0.6"
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls", "json"] }
tower = "0.4"
tower-http = { version = "0.4.4", features = ["cors"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.19"
prometheus = "0.13"
rand = "0.8"
ed25519-dalek = "2"
bs58 = "0.5"
hex = "0.4"
base64 = "0.22"
jsonwebtoken = "9"

lrb_core = { path = "../lrb_core" }

```


## FILE: node/src/admin.rs  (size=6316b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use serde::{Serialize, Deserialize};
use std::{fs, path::PathBuf};
use crate::{state::AppState, auth};

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub vk_b58: String,
    pub slot_ms: Option<u64>,
    pub max_block_txs: Option<usize>,
    pub mempool_cap: Option<usize>,
    pub env: serde_json::Value,
}

pub async fn node_info(Extension(st): Extension<AppState>) -> Json<NodeInfo> {
    let vk_b58 = bs58::encode(st.self_vk.to_bytes()).into_string();
    let rid = vk_b58.clone();
    let slot_ms = std::env::var("LRB_SLOT_MS").ok().and_then(|s| s.parse::<u64>().ok());
    let max_block_txs = std::env::var("LRB_MAX_BLOCK_TX").ok().and_then(|s| s.parse::<usize>().ok());
    let mempool_cap = std::env::var("LRB_MEMPOOL_CAP").ok().and_then(|s| s.parse::<usize>().ok());
    let keys = [
        "LRB_SLOT_MS","LRB_MAX_BLOCK_TX","LRB_MEMPOOL_CAP","LRB_MAX_AMOUNT",
        "LRB_DEV","LRB_PEERS","LRB_VALIDATORS","LRB_QUORUM_N",
        "LRB_BRIDGE_MAX_PER_TX","LRB_DATA_PATH","LRB_NODE_KEY_PATH",
    ];
    let mut envmap = serde_json::Map::new();
    for k in keys.iter() { if let Ok(val) = std::env::var(k) { envmap.insert((*k).to_string(), serde_json::Value::String(val)); } }
    Json(NodeInfo { rid, vk_b58, slot_ms, max_block_txs, mempool_cap, env: serde_json::Value::Object(envmap) })
}

/* ===== JWT mint для админки ===== */
#[derive(Serialize)] pub struct TokenResp { pub ok:bool, pub token:String, pub ttl_sec:usize }
pub async fn admin_token(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(q): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<TokenResp>, StatusCode> {
    // Требуем предъявить действительный ADMIN KEY (или Bearer KEY) для выдачи токена
    // IP ACL внутри require_admin
    let ip = None; // опционально можно протащить remote_ip из Tower layers
    auth::require_admin(&headers, ip)?;

    let ttl = q.get("ttl").and_then(|s| s.parse::<usize>().ok()).unwrap_or(600);
    let secret = std::env::var("LRB_ADMIN_JWT_SECRET").map_err(|_| StatusCode::UNAUTHORIZED)?;
    if secret.trim().is_empty() { return Err(StatusCode::UNAUTHORIZED); }
    let tok = auth::mint_jwt(&secret, "admin", ttl as i64)?;
    Ok(Json(TokenResp { ok:true, token: tok, ttl_sec: ttl }))
}

/* ===== Snapshot / Restore ===== */
#[derive(Serialize, Deserialize)]
pub struct Snapshot { pub head:u64, pub finalized:u64, pub lgn_balances:Vec<(String,u64)>, pub rlgn_balances:Vec<(String,u64)> }

pub async fn snapshot(Extension(st): Extension<AppState>, headers: HeaderMap)
-> Result<Json<Snapshot>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg }))
}

pub async fn snapshot_file(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let name = params.get("name").cloned().unwrap_or_else(|| format!("snap-{}.json", crate::state::now_ms()));
    let safe = name.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.');
    if !safe { return Err(StatusCode::BAD_REQUEST); }

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let snap = Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg };
    let data = serde_json::to_vec_pretty(&snap).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut path = PathBuf::from("/var/lib/logos/snapshots"); path.push(name);
    fs::write(&path, data).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "file": path.to_string_lossy()})))
}

#[derive(Deserialize)] pub struct RestoreReq { pub file: String }
pub async fn restore(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RestoreReq>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let safe = req.file.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.' || c=='/' );
    if !safe || !req.file.starts_with("/var/lib/logos/snapshots/") { return Err(StatusCode::BAD_REQUEST); }
    let data = fs::read(&req.file).map_err(|_| StatusCode::NOT_FOUND)?;
    let snap: Snapshot = serde_json::from_slice(&data).map_err(|_| StatusCode::BAD_REQUEST)?;
    for (rid_s, amt) in snap.lgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_balance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    for (rid_s, amt) in snap.rlgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_rbalance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    Ok(Json(serde_json::json!({"ok": true})))
}

/* validators info */
#[derive(Serialize)] pub struct ValidatorsInfo { pub validators: Vec<String>, pub quorum_n: usize }
pub async fn validators_info(Extension(st): Extension<AppState>) -> Json<ValidatorsInfo> {
    let vals = st.validators.iter().cloned().collect::<Vec<_>>();
    Json(ValidatorsInfo { validators: vals, quorum_n: st.quorum_n })
}

```


## FILE: node/src/api.rs  (size=10732b)
```text
use axum::{
    extract::{Path, Extension, Query},
    Json,
};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use lrb_core::*;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

use crate::state::*;

/* ---------- типы ---------- */
#[derive(Serialize)] pub struct Healthz { pub ok: bool }
#[derive(Deserialize)] pub struct SubmitTx {
    pub from:String, pub to:String, pub amount:u64, pub nonce:u64,
    pub public_key_b58:String, pub signature_b64:String
}
#[derive(Serialize)] pub struct SubmitResp { pub accepted: bool, pub tx_id: String, pub lgn_cost_microunits: u64 }
#[derive(Deserialize)] pub struct DebugCanonReq { pub from:String, pub to:String, pub amount:u64, pub nonce:u64, pub public_key_b58:String }
#[derive(Serialize)] pub struct DebugCanonResp { pub canon_hex:String, pub server_tx_id:String }

/* ---------- базовые ---------- */
pub async fn healthz() -> Json<Healthz> { Json(Healthz{ok:true}) }

pub async fn head(Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let (h, hash) = st.engine.ledger().head().unwrap_or((0, String::new()));
    let fin = st.engine.ledger().get_finalized().unwrap_or(0);
    Json(serde_json::json!({ "height": h, "hash": hash, "finalized": fin }))
}

pub async fn balance(Path(rid): Path<String>, Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let rid = Rid(rid); let bal = st.engine.ledger().get_balance(&rid);
    Json(serde_json::json!({ "rid": rid.as_str(), "balance": bal }))
}

/* ---------- состояние аккаунта ---------- */
pub async fn account_state(Path(rid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    let r = Rid(rid);
    let bal = st.engine.ledger().get_balance(&r);
    let n   = st.engine.ledger().get_nonce(&r);
    Ok(Json(serde_json::json!({ "rid": r.as_str(), "balance": bal, "nonce": n })))
}

/* ---------- одиночный submit ---------- */
pub async fn submit_tx(Extension(st): Extension<AppState>, Json(req): Json<SubmitTx>)
-> Result<Json<SubmitResp>, StatusCode> {
    if !st.rl_submit.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    TX_SUBMITTED.inc();
    if req.amount == 0 { return Err(StatusCode::BAD_REQUEST); }
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".into(), from:Rid(req.from.clone()), to:Rid(req.to.clone()),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:sig_bytes };
    let tx = Tx { id: tx.compute_id(), ..tx };
    if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    st.engine.mempool_sender().send(tx.clone()).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(SubmitResp { accepted:true, tx_id: tx.id, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- batch submit ---------- */
#[derive(Serialize)] pub struct BatchItem { pub tx_id:String, pub ok:bool, pub err:Option<String> }
#[derive(Serialize)] pub struct BatchResp { pub accepted:usize, pub rejected:usize, pub items:Vec<BatchItem>, pub lgn_cost_microunits:u64 }

pub async fn submit_tx_batch(Extension(st): Extension<AppState>, Json(reqs): Json<Vec<SubmitTx>>)
-> Result<Json<BatchResp>, StatusCode> {
    let n = reqs.len(); if n == 0 { return Err(StatusCode::BAD_REQUEST); }
    let maxb = std::env::var("LRB_MAX_BATCH").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(1000);
    if n > maxb { return Err(StatusCode::PAYLOAD_TOO_LARGE); }
    if !st.rl_submit.try_take(n as u64) { return Err(StatusCode::TOO_MANY_REQUESTS); }

    let mut items = Vec::with_capacity(n); let mut accepted = 0usize;
    let sender = st.engine.mempool_sender();
    for r in reqs {
        if r.amount == 0 {
            items.push(BatchItem{ tx_id:String::new(), ok:false, err:Some("amount=0".into())});
            continue;
        }
        let pk_bytes = match bs58::decode(&r.public_key_b58).into_vec() { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad public_key_b58".into())}); continue; } };
        let sig_bytes = match B64.decode(r.signature_b64.as_bytes()) { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad signature_b64".into())}); continue; } };
        let tx = Tx { id:String::new(), from:Rid(r.from), to:Rid(r.to), amount:r.amount, nonce:r.nonce, public_key:pk_bytes, signature:sig_bytes };
        let tx = Tx { id: tx.compute_id(), ..tx };
        if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("bad signature".into())}); continue; }
        if sender.send(tx.clone()).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("enqueue failed".into())}); continue; }
        items.push(BatchItem{tx_id:tx.id, ok:true, err:None}); accepted+=1;
    }
    TX_SUBMITTED.inc_by(accepted as u64);
    Ok(Json(BatchResp{ accepted, rejected: items.len()-accepted, items, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- debug / block / tx ---------- */
pub async fn debug_canon(Json(req): Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".to_string(), from:Rid(req.from), to:Rid(req.to),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:vec![0u8;64] };
    Ok(Json(DebugCanonResp { canon_hex: hex::encode(tx.canonical_bytes()), server_tx_id: tx.compute_id() }))
}

pub async fn get_block(Path(height): Path<u64>, Extension(st): Extension<AppState>)
-> Result<Json<Block>, StatusCode> {
    st.engine.ledger().get_block_by_height(height).map(Json).map_err(|_| StatusCode::NOT_FOUND)
}

/* простой ответ по tx: только высота, если есть */
pub async fn get_tx(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => Ok(Json(serde_json::json!({ "tx_id": txid, "height": h }))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

/* детальный ответ по tx (блок целиком) */
#[derive(Serialize)] pub struct TxFull { pub tx_id:String, pub height:u64, pub block:serde_json::Value, pub found:bool }
pub async fn get_tx_full(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<TxFull>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => {
            let blk = st.engine.ledger().get_block_by_height(h).map_err(|_| StatusCode::NOT_FOUND)?;
            let blk_json = serde_json::to_value(&blk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
            Ok(Json(TxFull{ tx_id: txid, height: h, block: blk_json, found:true }))
        }
        None => Ok(Json(TxFull{ tx_id: txid, height: 0, block: serde_json::json!({}), found:false })),
    }
}

/* ---------- история аккаунта (пагинация курсором) ---------- */
#[derive(Serialize)] pub struct AccountTxsPage {
    pub rid:String, pub limit:usize, pub items:Vec<serde_json::Value>,
    pub next_cursor_h: Option<u64>, pub next_cursor_seq: Option<u32>
}
pub async fn account_txs(
    Path(rid_s): Path<String>,
    Query(q): Query<HashMap<String,String>>,
    Extension(st): Extension<AppState>
) -> Result<Json<AccountTxsPage>, StatusCode> {
    let rid = Rid(rid_s);
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(100);
    let ch = q.get("cursor_h").and_then(|s| s.parse::<u64>().ok());
    let cs = q.get("cursor_seq").and_then(|s| s.parse::<u32>().ok());
    let (items, next_h, next_s) = st.engine.ledger().list_account_txs_page(&rid, ch, cs, limit)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(AccountTxsPage{
        rid: rid.as_str().to_string(), limit, items,
        next_cursor_h: next_h, next_cursor_seq: next_s
    }))
}

/* ---------- эксплорер (последние блоки/tx) ---------- */
#[derive(Serialize)] pub struct RecentBlocks { pub items: Vec<serde_json::Value> }
pub async fn recent_blocks(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentBlocks>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<u64>().ok()).unwrap_or(20);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    for _ in 0..limit {
        if h == 0 { break; }
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            out.push(serde_json::to_value(b).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?);
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentBlocks{ items: out }))
}

#[derive(Serialize)] pub struct RecentTxs { pub items: Vec<serde_json::Value> }
pub async fn recent_txs(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentTxs>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(50);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    while out.len() < limit && h > 0 {
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            for tx in b.txs.iter().rev() {
                if out.len() >= limit { break; }
                out.push(serde_json::json!({"height": b.height, "tx_id": tx.id, "from": tx.from.0, "to": tx.to.0, "amount": tx.amount}));
            }
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentTxs{ items: out }))
}

/* ---------- DEV faucet ---------- */
#[allow(dead_code)]
pub async fn faucet(Path((rid_s,amount_s)):Path<(String,String)>, Extension(st):Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    if !st.dev_mode { return Err(StatusCode::FORBIDDEN); }
    let rid = Rid(rid_s); let amount:u64 = amount_s.parse().map_err(|_| StatusCode::BAD_REQUEST)?;
    let cur = st.engine.ledger().get_balance(&rid); let newb = cur.saturating_add(amount);
    st.engine.ledger().set_balance(&rid, newb).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "rid": rid.as_str(), "balance": newb })))
}

```


## FILE: node/src/auth.rs  (size=5131b)
```text
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: node/src/bridge.rs  (size=3607b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signer, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};
use crate::state::{AppState, BR_DEPOSIT, BR_REDEEM, now_ms};
use crate::auth;

#[derive(Deserialize)] pub struct DepositReq { pub rid:String, pub amount:u64, pub ext_txid:String }
#[derive(Serialize)]   pub struct DepositResp { pub ok:bool, pub rid:String, pub r_balance:u64 }
#[derive(Deserialize)] pub struct RedeemReq { pub rid:String, pub amount:u64, pub request_id:String }
#[derive(Serialize)]   pub struct RedeemResp { pub ok:bool, pub rid:String, pub r_balance:u64, pub redeem_ticket:String, pub signature_b64:String }
#[derive(Deserialize)] pub struct VerifyReq { pub ticket:String, pub signature_b64:String, pub vk_b58:String }
#[derive(Serialize)]   pub struct VerifyResp { pub ok:bool }

pub async fn deposit(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<DepositReq>)
-> Result<Json<DepositResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?;  // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("dep:{}", req.ext_txid);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    BR_DEPOSIT.inc();
    Ok(Json(DepositResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb }))
}

pub async fn redeem(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RedeemReq>)
-> Result<Json<RedeemResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?; // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("red:{}", req.request_id);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;
    BR_REDEEM.inc();

    let ticket = format!("redeem:{}:{}:{}", rid.as_str(), req.amount, req.request_id);
    let sig = st.sk.sign(ticket.as_bytes());
    let signature_b64 = B64.encode(sig.to_bytes());
    Ok(Json(RedeemResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb, redeem_ticket: ticket, signature_b64 }))
}

pub async fn verify(Json(req): Json<VerifyReq>) -> Result<Json<VerifyResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.vk_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig = ed25519_dalek::Signature::from_bytes(&sig_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?);
    Ok(Json(VerifyResp { ok: vk.verify(req.ticket.as_bytes(), &sig).is_ok() }))
}

```


## FILE: node/src/fork.rs  (size=429b)
```text
use anyhow::Result;
use lrb_core::Block;
use crate::state::AppState;

/// Временная реализация: делаем вид, что реорг не требуется.
/// Когда включим полноценный fork-choice, сюда добавим сравнение sigma/weight.
pub fn apply_or_reorg_deep(_st: &AppState, _incoming: &Block, _sigma_hex: &str, _prev_hash: &str) -> Result<()> {
    Ok(())
}

```


## FILE: node/src/gossip.rs  (size=5147b)
```text
use anyhow::Result;
use axum::{extract::Extension, Json};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, Signer, VerifyingKey};
use serde::{Deserialize, Serialize};
use lrb_core::{Block, resonance, phase_filters::block_passes_phase};
use crate::state::{AppState, now_ms, GOSSIP_BLK_SENT, GOSSIP_BLK_RECV, GOSSIP_VOTE_SENT, GOSSIP_VOTE_RECV, CONS_VOTES, PHASE_BLOCK_ACCEPTED, PHASE_BLOCK_REJECTED};

#[derive(Serialize, Deserialize, Clone)]
pub struct GossipHeader { pub height:u64, pub prev_hash:String, pub block_hash:String, pub proposer_rid:String, pub timestamp_ms:u128, pub sigma_hex:String }
#[derive(Serialize, Deserialize, Clone)]
pub struct GossipBlockMsg { pub header:GossipHeader, pub block:Block, pub sender_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }
#[derive(Serialize, Deserialize, Clone)]
pub struct VoteMsg { pub height:u64, pub block_hash:String, pub sigma_hex:String, pub voter_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }

fn verify_gossip_sig(msg: &GossipBlockMsg) -> Result<()> {
    let pk_bytes = bs58::decode(&msg.sender_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(msg.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);
    let mut payload = Vec::new();
    payload.extend_from_slice(msg.header.sigma_hex.as_bytes());
    payload.extend_from_slice(msg.header.block_hash.as_bytes());
    payload.extend_from_slice(&msg.nonce_ms.to_le_bytes());
    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

pub async fn send_block(peers:&[String], st:&AppState, block:&Block) {
    let sigma_hex = resonance::sigma_digest_block_hex(block);
    let nonce_ms = now_ms();
    let mut pl = Vec::new();
    pl.extend_from_slice(sigma_hex.as_bytes());
    pl.extend_from_slice(block.block_hash.as_bytes());
    pl.extend_from_slice(&nonce_ms.to_le_bytes());
    let sig_b64 = B64.encode(st.sk.sign(&pl).to_bytes());
    let header = GossipHeader {
        height:block.height, prev_hash:block.prev_hash.clone(), block_hash:block.block_hash.clone(),
        proposer_rid:block.proposer.0.clone(), timestamp_ms:block.timestamp_ms, sigma_hex:sigma_hex.clone()
    };
    let msg = GossipBlockMsg {
        header, block:block.clone(),
        sender_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(),
        sig_b64, nonce_ms
    };
    for p in peers {
        let _ = st.http.post(&format!("{}/gossip/block", p.trim_end_matches('/'))).json(&msg).send().await;
        GOSSIP_BLK_SENT.inc();
    }

    let vote_nonce = now_ms();
    let mut pv = Vec::new();
    pv.extend_from_slice(sigma_hex.as_bytes());
    pv.extend_from_slice(block.block_hash.as_bytes());
    pv.extend_from_slice(&block.height.to_le_bytes());
    pv.extend_from_slice(&vote_nonce.to_le_bytes());
    let vote_sig_b64 = B64.encode(st.sk.sign(&pv).to_bytes());
    let vmsg = VoteMsg {
        height:block.height, block_hash:block.block_hash.clone(), sigma_hex: sigma_hex.clone(),
        voter_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(), sig_b64: vote_sig_b64, nonce_ms: vote_nonce
    };
    for p in peers { let _ = st.http.post(&format!("{}/gossip/vote", p.trim_end_matches('/'))).json(&vmsg).send().await; GOSSIP_VOTE_SENT.inc(); }
}

pub async fn gossip_block(Extension(st): Extension<AppState>, Json(msg): Json<GossipBlockMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    GOSSIP_BLK_RECV.inc();

    let local_sigma = resonance::sigma_digest_block_hex(&msg.block);
    if local_sigma != msg.header.sigma_hex { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if verify_gossip_sig(&msg).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }

    // фазовый фильтр: блоки вне фазы не принимаем
    if !block_passes_phase(&msg.block) {
        PHASE_BLOCK_REJECTED.inc();
        return Err(StatusCode::UNPROCESSABLE_ENTITY);
    }
    PHASE_BLOCK_ACCEPTED.inc();

    crate::fork::apply_or_reorg_deep(&st, &msg.block, &msg.header.sigma_hex, &msg.header.prev_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true})))
}

pub async fn gossip_vote(Extension(st): Extension<AppState>, Json(v): Json<VoteMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.validators.is_empty() && !st.validators.contains(&v.voter_pk_b58) { return Err(StatusCode::FORBIDDEN); }
    GOSSIP_VOTE_RECV.inc();
    let vv = lrb_core::quorum::Vote {
        height: v.height, block_hash: v.block_hash.clone(), sigma_hex: v.sigma_hex.clone(),
        voter_pk_b58: v.voter_pk_b58.clone(), sig_b64: v.sig_b64.clone(), nonce_ms: v.nonce_ms
    };
    if let Err(_) = lrb_core::quorum::verify_vote(&vv) { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if st.engine.register_vote(v.height, &v.block_hash, &v.voter_pk_b58) { CONS_VOTES.inc(); }
    Ok(Json(serde_json::json!({"ok": true})))
}

```


## FILE: node/src/main.rs  (size=5036b)
```text
// node/src/main.rs — прод-роутер с историей/индексами и базовой инициализацией
mod bridge;
mod admin;
mod fork;
mod state;
mod gossip;
mod metrics;
mod api;
mod peers;

use anyhow::Result;
use axum::{
    extract::DefaultBodyLimit,
    routing::{get, post},
    Extension, Router,
};
use std::{env, net::SocketAddr, time::Duration};
use tokio::{signal, time::interval};

use lrb_core::*;
use crate::state::AppState;

#[tokio::main]
async fn main() -> Result<()> {
    // --------- инициализация ключей/ledger/engine ----------
    // Ключи/ledger/engine инициализируй так, как у тебя уже сделано — здесь оставляем существующую логику.
    // Ниже только минимальные обязательные шаги, чтобы не поломать твой запуск.

    // Открываем базу
    let data_path = env::var("LRB_DATA_PATH").unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());
    let ledger = Ledger::open(&data_path)?;

    // ИНИЦИАЛИЗАЦИЯ ENGINE — используй фактическую функцию/конструктор, которая уже есть у тебя:
    // предположим у тебя есть что-то вроде: let (engine, _mp) = engine_with_channels(ledger, self_rid.clone());
    // Здесь для совместимости:
    let (engine, _mp) = {
        // В твоём коде уже есть построение self_rid / ключей — оставь его.
        // Ниже упрощённый вызов: если у тебя другой — подставь свой.
        let dummy_rid = Rid("DUMMY_RID".to_string());
        engine_with_channels(ledger, dummy_rid)
    };

    // Запуск block producer (оставляем как в твоём коде)
    {
        let eng = engine.clone();
        tokio::spawn(async move {
            let _ = eng.run_block_producer().await;
        });
    }

    // Собираем AppState из твоей реализации
    let st = AppState::new_for_router(engine.clone())?;

    // --------- Роуты (все действующие + история/индексы) ----------
    let mut app = Router::new()
        // базовые
        .route("/healthz", get(api::healthz))
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/account/:rid/state", get(api::account_state))
        // отправка транзакций
        .route("/submit_tx",        post(api::submit_tx))
        .route("/submit_tx_batch",  post(api::submit_tx_batch))
        // отладка канона/подписи
        .route("/debug_canon", post(api::debug_canon))
        // faucet (DEV)
        .route("/faucet/:rid/:amount", post(api::faucet))
        // мост
        .route("/bridge/deposit", post(api::bridge_deposit))
        .route("/bridge/redeem",  post(api::bridge_redeem))
        .route("/bridge/verify",  post(api::bridge_verify))
        // админка
        .route("/admin/snapshot",      get(api::snapshot))
        .route("/admin/snapshot-file", get(api::snapshot_file))
        .route("/admin/restore",       post(api::restore))
        .route("/admin/token",         get(api::admin_token))
        .route("/node/info",           get(api::node_info))
        // НОВОЕ: история/индексы
        .route("/block/:height", get(api::get_block))
        .route("/tx/:id",        get(api::get_tx))
        .route("/account/:rid/txs", get(api::account_txs))
        // лимит тела (предохраняемся от больших batch’ей)
        .layer(DefaultBodyLimit::max(64 * 1024))
        .layer(Extension(st.clone()));

    // Фоновая метрика — обновляем chain_height/mempool_len периодически (если у тебя уже есть — оставь свою)
    {
        let stc = st.clone();
        tokio::spawn(async move {
            let mut t = interval(Duration::from_millis(500));
            loop {
                t.tick().await;
                if let Ok((h, _)) = stc.engine.ledger().head() {
                    crate::state::HEIGHT_GAUGE.set(h as i64);
                }
                if let Ok(f) = stc.engine.ledger().get_finalized() {
                    crate::state::FINAL_GAUGE.set(f as i64);
                }
                crate::state::MEMPOOL_GAUGE.set(stc.engine.mempool_len() as i64);
            }
        });
    }

    // --------- запуск сервера ----------
    let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
    println!("LOGOS LRB node listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(async {
            let _ = signal::ctrl_c().await;
            eprintln!("shutdown...");
        })
        .await?;

    Ok(())
}

```


## FILE: node/src/metrics.rs  (size=498b)
```text
use axum::http::{HeaderMap, HeaderValue};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics_handler() -> (HeaderMap, Vec<u8>) {
    let mut buffer = Vec::<u8>::new();
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let mut headers = HeaderMap::new();
    headers.insert(axum::http::header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    (headers, buffer)
}

```


## FILE: node/src/peers.rs  (size=4411b)
```text
use crate::state::now_ms;
use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{collections::HashMap, sync::{Arc, Mutex}, time::Duration};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self { last_seen_ms: now_ms(), score_milli: 0, fails: 0, dups: 0, banned_until_ms: 0 }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self { Self { inner: Arc::new(Mutex::new(HashMap::new())), policy } }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> { self.inner.lock().unwrap() }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 { s.score_milli = 5000; }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli { s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms; }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk).map(|s| now_ms() < s.banned_until_ms).unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 { s.score_milli = 0; }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now { banned += 1; }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop { t.tick().await; book.tick(); }
    });
}

```


## FILE: node/src/state.rs  (size=5557b)
```text
use std::{collections::{HashMap, HashSet}, sync::{Arc, Mutex}, time::{SystemTime, UNIX_EPOCH}};
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::Lazy;
use prometheus::{register_histogram, register_int_counter, register_int_gauge, Histogram, IntCounter, IntGauge};
use reqwest::Client;
use lrb_core::Engine;

pub fn now_ms() -> u128 { SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() }

/* ---- метрики (как у тебя) ---- */
pub static TX_SUBMITTED:    Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_submitted_total","submitted tx").unwrap());
pub static TX_APPLIED:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_applied_total",  "applied tx").unwrap());
pub static GOSSIP_BLK_SENT: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_sent_total","gossip blocks sent").unwrap());
pub static GOSSIP_BLK_RECV: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_recv_total","gossip blocks recv").unwrap());
pub static GOSSIP_VOTE_SENT:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_sent_total","gossip votes sent").unwrap());
pub static GOSSIP_VOTE_RECV:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_recv_total","gossip votes recv").unwrap());
pub static CONS_VOTES:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("consensus_votes_total","accepted consensus votes").unwrap());
pub static HEIGHT_GAUGE:    Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_height","current height").unwrap());
pub static FINAL_GAUGE:     Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_finalized","finalized height").unwrap());
pub static MEMPOOL_GAUGE:   Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("mempool_len","mempool length").unwrap());
pub static SLOT_TXS_GAUGE:  Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("slot_tx_count","tx in last committed block").unwrap());
pub static BR_DEPOSIT:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_deposit_total","bridge deposits").unwrap());
pub static BR_REDEEM:       Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_redeem_total","bridge redeems").unwrap());
pub static PHASE_BLOCK_ACCEPTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_accepted_total","blocks passed phase filter").unwrap());
pub static PHASE_BLOCK_REJECTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_rejected_total","blocks rejected by phase filter").unwrap());
pub static SLOT_LAT_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_latency_ms_hist","slot latency histogram (ms)",
        vec![10.0,25.0,50.0,100.0,250.0,500.0,750.0,1000.0,1500.0,2000.0,3000.0]).unwrap()
});
pub static SLOT_TXS_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_tx_count_hist","tx per block histogram",
        vec![10.0,50.0,100.0,500.0,1000.0,2000.0,5000.0,10000.0,20000.0]).unwrap()
});

/* ---- Anti-replay окно ---- */
#[derive(Default, Clone)]
pub struct ReplayWindow {
    map: Arc<Mutex<HashMap<String,u128>>>,
    pub ttl_ms: u128,
    pub max_items: usize,
}
impl ReplayWindow {
    pub fn new(ttl_ms: u128, max_items: usize) -> Self { Self { map: Arc::new(Mutex::new(HashMap::new())), ttl_ms, max_items } }
    pub fn check_and_note(&self, key: String, ts_ms: u128) -> bool {
        let mut m = self.map.lock().unwrap();
        if m.len() > self.max_items {
            let cutoff = now_ms().saturating_sub(self.ttl_ms);
            m.retain(|_, &mut t| t >= cutoff);
        }
        if let Some(prev) = m.get(&key) { if ts_ms <= *prev + self.ttl_ms { return false; } }
        m.insert(key, ts_ms);
        true
    }
}

/* ---- Токен-бакет ---- */
#[derive(Clone)]
pub struct TokenBucket { inner: Arc<Mutex<BucketInner>>, }
#[derive(Debug)]
struct BucketInner { capacity:u64, tokens:u64, refill_per_ms:f64, last_ms:u128 }
impl TokenBucket {
    pub fn new(capacity:u64, refill_per_sec:u64) -> Self {
        let now = now_ms();
        Self { inner: Arc::new(Mutex::new(BucketInner{
            capacity, tokens: capacity, refill_per_ms: refill_per_sec as f64 / 1000.0, last_ms: now
        })) }
    }
    pub fn try_take(&self, n:u64) -> bool {
        let now = now_ms();
        let mut b = self.inner.lock().unwrap();
        let elapsed = (now - b.last_ms) as f64;
        let refill = (elapsed * b.refill_per_ms) as u64;
        if refill > 0 { b.tokens = (b.tokens + refill).min(b.capacity); b.last_ms = now; }
        if b.tokens >= n { b.tokens -= n; true } else { false }
    }
}

/* ---- AppState ---- */
#[derive(Clone)]
pub struct AppState {
    pub engine: Arc<Engine>,
    pub http: Client,
    pub dev_mode: bool,
    pub peers: Vec<String>,

    pub self_vk: VerifyingKey,
    pub sk: Arc<SigningKey>,

    // gossip/кворум
    pub seen_blocks: Arc<Mutex<HashSet<String>>>,
    pub vote_seen: Arc<Mutex<HashSet<String>>>,
    pub vote_tally: Arc<Mutex<HashMap<(u64,String), HashSet<String>>>>,
    pub validators: Arc<HashSet<String>>,
    pub quorum_n: usize,

    // anti-replay
    pub replay_blk: ReplayWindow,
    pub replay_vote: ReplayWindow,

    // rate-limit
    pub rl_submit: TokenBucket,
    pub rl_admin:  TokenBucket,     // NEW: лимит на админ-ручки

    // peer scoring
    pub peerbook: crate::peers::PeerBook,

    // bridge
    pub rl_bridge: TokenBucket,
    pub replay_bridge: ReplayWindow,
    pub bridge_max_per_tx: u64,
    pub bridge_key: Option<String>,
}

```


## FILE: src/bin/ai_signal_listener.rs  (size=8704b)
```text

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: src/bin/orchestration_control.rs  (size=6987b)
```text
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/rcp_engine.rs  (size=4122b)
```text
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: src/bin/resonance_mesh.rs  (size=8051b)
```text
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/resonance_sync.rs  (size=11282b)
```text
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/sigma_t.rs  (size=3522b)
```text

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: src/core/biosphere_scanner.rs  (size=5196b)
```text
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: src/core/dao.rs  (size=2106b)
```text

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/logos_self.rs  (size=2771b)
```text

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/phase.rs  (size=5790b)
```text

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/resonance.rs  (size=3016b)
```text

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/tx_spam_guard.rs  (size=3175b)
```text

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/lib.rs  (size=921b)
```text

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: src/utils/filters.rs  (size=322b)
```text

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: src/utils/frequency.rs  (size=380b)
```text

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: src/utils/math.rs  (size=394b)
```text

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: src/utils/types.rs  (size=215b)
```text

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: tools/admin_cli.sh  (size=5214b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: tools/go_test/main.go  (size=3201b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: tools/go_test/two_rids.go  (size=3944b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: tools/load/load_submit_tx.go  (size=7096b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: tools/lrb_audit.sh  (size=3026b)
```text
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: tools/test_tx.sh  (size=1841b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: wallet-proxy/app.py  (size=7115b)
```text
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: wallet-proxy/requirements.txt  (size=1147b)
```text
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: wallet-proxy/scanner.py  (size=5538b)
```text
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: www/wallet/index.html  (size=7993b)
```text
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS LRB — Web Wallet</title>
  <style>
    :root{--bg:#0b0e12;--fg:#e8eef4;--muted:#9aa8b3;--card:#121821;--acc:#78e08f;--warn:#e77;--ok:#8f8;--link:#79a6ff}
    *{box-sizing:border-box} body{background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,Arial,sans-serif;margin:0}
    header{padding:18px 20px;background:#0e131a;position:sticky;top:0;border-bottom:1px solid #1f2834}
    h1{margin:0;font-size:18px} a{color:var(--link)} main{max-width:1080px;margin:18px auto;padding:0 16px}
    .grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
    .card{background:var(--card);border:1px solid #1f2834;border-radius:14px;padding:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap} .mono{font-family:ui-monospace,Consolas,monospace}
    label{display:block;margin:6px 0 2px;color:var(--muted)} input,button,select,textarea{background:#0c1219;color:var(--fg);
      border:1px solid #243141;border-radius:10px;padding:9px 10px} input,select,textarea{width:100%}
    button{cursor:pointer} button.primary{background:#112236;border-color:#213f66} button.ok{background:#103418;border-color:#1c5c2b}
    .muted{color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .kvs div{display:flex;justify-content:space-between}
    .kvs div span:first-child{color:var(--muted)} .pill{display:inline-block;border:1px solid #2a394d;padding:2px 8px;border-radius:999px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #1f2834;padding:8px 6px;text-align:left}
    .small{font-size:12px} .right{text-align:right}
    .tabs{display:flex;gap:6px;margin-bottom:8px} .tabs button{padding:6px 10px;border-radius:8px;border:1px solid #2a394d;background:#0d141c}
    .tabs button.active{background:#1a2635}
  </style>
</head>
<body>
  <header><h1>LOGOS LRB — Web Wallet</h1></header>
  <main class="grid">

    <!-- Сеть / нода -->
    <section class="card">
      <h3>Сеть / Нода</h3>
      <label>Node URL</label>
      <input id="nodeUrl" placeholder="http://45.159.248.232:8080"/>
      <div class="row">
        <button id="saveNode" class="primary">Сохранить</button>
        <button id="ping">Проверить /healthz</button>
        <span id="pingRes" class="mono"></span>
      </div>
      <div class="kvs small" style="margin-top:8px">
        <div><span>height</span><span id="headHeight" class="mono">-</span></div>
        <div><span>finalized</span><span id="headFinal" class="mono">-</span></div>
        <div><span>hash</span><span id="headHash" class="mono">-</span></div>
      </div>
    </section>

    <!-- Ключи -->
    <section class="card">
      <h3>Ключи (Ed25519, локально)</h3>
      <div class="row">
        <button id="gen" class="primary">Сгенерировать</button>
        <button id="wipe">Удалить из браузера</button>
      </div>
      <label>RID (base58)</label>
      <div id="rid" class="mono small"></div>
      <label>Публичный ключ (base58)</label>
      <div id="pk58" class="mono small"></div>
      <details style="margin-top:8px"><summary class="muted">Экспорт/импорт</summary>
        <label>Приватный ключ (hex)</label>
        <textarea id="skHex" rows="3" class="mono" placeholder="hex..."></textarea>
        <div class="row"><button id="importSk">Импорт</button><button id="exportSk">Экспорт</button><span id="impRes" class="mono"></span></div>
      </details>
    </section>

    <!-- Состояние -->
    <section class="card">
      <h3>Состояние аккаунта</h3>
      <div class="row"><button id="refreshState">Обновить</button><span id="stateRes" class="mono"></span></div>
      <div class="kvs">
        <div><span>Баланс (μLGN)</span><span id="balance" class="mono">0</span></div>
        <div><span>Nonce</span><span id="nonce" class="mono">0</span></div>
      </div>
    </section>

    <!-- Перевод -->
    <section class="card">
      <div class="tabs"><button id="tabSend" class="active">Перевод</button><button id="tabBatch">Батч</button></div>

      <div id="panelSend">
        <label>Получатель (RID)</label><input id="toRid" placeholder="RID получателя"/>
        <label>Сумма (μLGN)</label><input id="amount" type="number" value="1"/>
        <div class="row"><button id="send" class="ok">Отправить</button><span id="sendRes" class="mono small"></span></div>
      </div>

      <div id="panelBatch" style="display:none">
        <label>Список получателей (по одному RID в строке)</label>
        <textarea id="batchList" rows="6" placeholder="RID1&#10;RID2&#10;..."></textarea>
        <label>Сумма на каждого (μLGN)</label><input id="batchAmount" type="number" value="1"/>
        <label>Размер батча (tx за один запрос)</label><input id="batchSize" type="number" value="50"/>
        <div class="row"><button id="sendBatch" class="ok">Отправить батч</button><span id="batchRes" class="mono small"></span></div>
      </div>
    </section>

    <!-- История / Недавние -->
    <section class="card">
      <h3>История</h3>
      <div class="row"><button id="loadTxs">Загрузить</button><button id="nextTxs">Дальше</button><span id="histRes" class="mono small"></span></div>
      <table id="hist"><thead><tr><th>H</th><th>Tx</th><th>Dir</th><th class="right">Amount</th><th>Counterparty</th></tr></thead><tbody></tbody></table>
    </section>

    <section class="card">
      <h3>Недавние</h3>
      <div class="row"><button id="recentBlocks">Блоки</button><button id="recentTxs">Tx</button><span id="recentRes" class="mono small"></span></div>
      <table id="recent"><thead><tr><th>Тип</th><th>Данные</th></tr></thead><tbody></tbody></table>
    </section>

    <!-- Мост (для операторов/интегратора) -->
    <section class="card">
      <h3>rToken мост (оператор)</h3>
      <label>X-Bridge-Key (или Bearer JWT)</label><input id="bridgeKey" placeholder="введите ключ или JWT (опц.)"/>
      <label>RID</label><input id="bridgeRid" placeholder="RID для зачисления/списания"/>
      <div class="row">
        <div style="flex:1">
          <label>Deposit (μrLGN)</label><input id="depAmount" type="number" value="1000"/>
          <label>ext_txid</label><input id="depExt" placeholder="например, txid внешней сети"/>
          <button id="deposit" class="primary">Deposit</button>
        </div>
        <div style="flex:1">
          <label>Redeem (μrLGN)</label><input id="redAmount" type="number" value="500"/>
          <label>request_id</label><input id="redReq" placeholder="уникальный ID запроса"/>
          <button id="redeem" class="primary">Redeem</button>
        </div>
      </div>
      <div class="small mono" id="bridgeRes"></div>
    </section>

    <!-- Админ-токен -->
    <section class="card">
      <h3>Админ (JWT)</h3>
      <label>X-Admin-Key</label><input id="adminKey" placeholder="только для операторов"/>
      <div class="row"><label class="muted">TTL (сек)</label><input id="adminTtl" type="number" value="600" style="width:120px"/>
        <button id="mintAdminToken">Получить токен</button><span id="adminRes" class="mono small"></span></div>
    </section>

  </main>

  <!-- noble-ed25519 + bs58 CDN -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm"></script>
  <script type="module" src="./wallet.js"></script>
</body>
</html>

```


## FILE: www/wallet/wallet.js  (size=10848b)
```text
import * as ed from "https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm";
import bs58 from "https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm";

/* =============== helpers =============== */
const $ = (id)=>document.getElementById(id);
const enc = new TextEncoder();

const st = {
  node: localStorage.getItem("lrb_node") || "http://45.159.248.232:8080",
  skHex: localStorage.getItem("lrb_sk") || "",
  pkHex: localStorage.getItem("lrb_pk") || "",
  cursor_h: null, cursor_seq: null
};

function ridFromPkHex(pkHex){ return bs58.encode(Buffer.from(pkHex,"hex")); }
function toB64(u8){ return btoa(String.fromCharCode(...u8)); }

function canonicalBytes(from, to, amount, nonce, pkHex) {
  const pk = Buffer.from(pkHex, "hex");
  const a = enc.encode(from), b = enc.encode(to),
        c = enc.encode(String(amount)), d = enc.encode(String(nonce));
  const out = new Uint8Array(a.length+b.length+c.length+d.length+pk.length);
  out.set(a,0); out.set(b,a.length); out.set(c,a.length+b.length);
  out.set(d,a.length+b.length+c.length); out.set(pk,a.length+b.length+c.length+d.length);
  return out;
}

async function getJSON(url, opts={}) {
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}
async function postJSON(url, body, headers={}) {
  const r = await fetch(url, {method:"POST",headers:{'content-type':'application/json',...headers},body:JSON.stringify(body)});
  const t = await r.text();
  try { return { ok:r.ok, status:r.status, body: JSON.parse(t||"{}") }; }
  catch { return { ok:r.ok, status:r.status, body: t }; }
}

/* =============== network / head =============== */
$("nodeUrl").value = st.node;
$("saveNode").onclick = () => { st.node = $("nodeUrl").value.trim(); localStorage.setItem("lrb_node", st.node); alert("Node URL сохранён"); };
$("ping").onclick = async ()=>{
  try {
    const h = await getJSON(`${st.node}/healthz`); $("pingRes").textContent = h.ok?"OK":"ERR";
    const head = await getJSON(`${st.node}/head`);
    $("headHeight").textContent = head.height ?? "-";
    $("headFinal").textContent  = head.finalized ?? "-";
    $("headHash").textContent   = (head.hash||"").slice(0,16)+"…";
  } catch(e){ $("pingRes").textContent = `ERR: ${e.message}`; }
};

/* =============== keys =============== */
function renderKeys(){
  const pkHex = st.pkHex;
  $("pk58").textContent = pkHex? bs58.encode(Buffer.from(pkHex,"hex")) : "";
  $("rid").textContent  = pkHex? ridFromPkHex(pkHex) : "";
  $("skHex").value = st.skHex || "";
}
$("gen").onclick = async ()=>{
  const sk = ed.utils.randomPrivateKey(); const pk = await ed.getPublicKey(sk);
  st.skHex = Buffer.from(sk).toString("hex"); st.pkHex = Buffer.from(pk).toString("hex");
  localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
};
$("wipe").onclick = ()=>{ localStorage.removeItem("lrb_sk"); localStorage.removeItem("lrb_pk"); st.skHex=""; st.pkHex=""; renderKeys(); };
$("importSk").onclick = async ()=>{
  try{
    const val = $("skHex").value.trim(); if(!val) throw new Error("пусто");
    const sk = Buffer.from(val,"hex"); const pk = await ed.getPublicKey(sk);
    st.skHex = val; st.pkHex = Buffer.from(pk).toString("hex");
    localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
    $("impRes").textContent = "OK";
  }catch(e){ $("impRes").textContent = "ERR"; }
};
$("exportSk").onclick = ()=>{ $("skHex").value = st.skHex || ""; };

renderKeys();

/* =============== account state =============== */
$("refreshState").onclick = async ()=>{
  $("stateRes").textContent = "";
  if(!st.pkHex) return $("stateRes").textContent = "Нет ключа";
  try{
    const rid = $("rid").textContent;
    const s = await getJSON(`${st.node}/account/${rid}/state`);
    $("balance").textContent = s.balance ?? 0;
    $("nonce").textContent   = s.nonce ?? 0;
    $("stateRes").textContent = "OK";
  }catch(e){ $("stateRes").textContent = `ERR: ${e.message}`; }
};

/* =============== send / batch =============== */
function nextNonce(){ return (parseInt($("nonce").textContent||"0",10) || 0) + 1; }

$("tabSend").onclick = ()=>{ $("panelSend").style.display="block"; $("panelBatch").style.display="none"; $("tabSend").classList.add("active"); $("tabBatch").classList.remove("active"); };
$("tabBatch").onclick= ()=>{ $("panelSend").style.display="none"; $("panelBatch").style.display="block"; $("tabBatch").classList.add("active"); $("tabSend").classList.remove("active"); };

$("send").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim(), to=$("toRid").value.trim();
    const amount = parseInt($("amount").value||"0",10); if(!to||!amount) throw new Error("проверь поля");
    const nonce = nextNonce();
    const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
    const sig = await ed.sign(canon, st.skHex);
    const item = { from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) };
    const r = await postJSON(`${st.node}/submit_tx_batch`, [item]);
    $("sendRes").textContent = r.ok? `OK accepted=${r.body.accepted||0}` : `ERR ${r.status}`;
    // обновим nonce
    await $("refreshState").onclick();
  }catch(e){ $("sendRes").textContent = `ERR: ${e.message}`; }
};

$("sendBatch").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim();
    const list = $("batchList").value.split("\n").map(s=>s.trim()).filter(Boolean);
    const amount = parseInt($("batchAmount").value||"0",10);
    const batchSize = parseInt($("batchSize").value||"50",10);
    if(list.length===0 || !amount) throw new Error("укажи получателей и сумму");
    let nonce = nextNonce(), accepted=0, sent=0;
    for(let i=0;i<list.length;i+=batchSize){
      const chunk = list.slice(i,i+batchSize);
      const req = [];
      for(const to of chunk){
        const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
        const sig   = await ed.sign(canon, st.skHex);
        req.push({ from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) });
        nonce++;
      }
      const r = await postJSON(`${st.node}/submit_tx_batch`, req);
      sent += req.length; if(r.ok) accepted += (r.body.accepted||0);
      $("batchRes").textContent = `sent=${sent} accepted=${accepted}`;
    }
    await $("refreshState").onclick();
  }catch(e){ $("batchRes").textContent = `ERR: ${e.message}`; }
};

/* =============== history / recent =============== */
async function loadAccountTxs(next=false){
  try{
    const rid = $("rid").textContent.trim(), params=[];
    params.push(`limit=20`);
    if(next && st.cursor_h!=null && st.cursor_seq!=null){
      params.push(`cursor_h=${st.cursor_h}`); params.push(`cursor_seq=${st.cursor_seq}`);
    }
    const url = `${st.node}/account/${rid}/txs?`+params.join("&");
    const r = await getJSON(url);
    const tbody = $("hist").querySelector("tbody");
    if(!next) tbody.innerHTML="";
    for(const it of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="mono small">${it.height??""}</td>
                      <td class="mono small">${(it.tx_id||"").slice(0,12)}…</td>
                      <td>${it.dir==-1?"→":"←"}</td>
                      <td class="right mono">${it.amount??0}</td>
                      <td class="mono small">${(it.counterparty||"").slice(0,10)}…</td>`;
      tbody.appendChild(tr);
    }
    st.cursor_h = r.next_cursor_h ?? null;
    st.cursor_seq = r.next_cursor_seq ?? null;
    $("histRes").textContent = r.items?.length ? "OK" : "—";
  }catch(e){ $("histRes").textContent = `ERR: ${e.message}`; }
}
$("loadTxs").onclick = ()=>loadAccountTxs(false);
$("nextTxs").onclick = ()=>loadAccountTxs(true);

$("recentBlocks").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/blocks?limit=10`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const b of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Block</td><td class="mono small">h=${b.height} tx=${(b.txs||[]).length} hash=${(b.block_hash||"").slice(0,14)}…</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};
$("recentTxs").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/txs?limit=20`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const t of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Tx</td><td class="mono small">h=${t.height} tx=${(t.tx_id||"").slice(0,12)}… ${t.from?.slice(0,8)}→${t.to?.slice(0,8)} a=${t.amount}</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};

/* =============== bridge (operator) =============== */
function authHeader(val){
  const s = (val||"").trim(); if(!s) return {};
  // Если строка похожа на JWT — отправим как Bearer, иначе X-Bridge-Key
  return s.split(".").length===3 ? {Authorization:`Bearer ${s}`} : {"X-Bridge-Key": s};
}
$("deposit").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("depAmount").value||"0",10), ext = $("depExt").value.trim();
  const r = await postJSON(`${st.node}/bridge/deposit`, {rid,amount,ext_txid:ext}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `deposit OK: r_balance=${r.body.r_balance}` : `ERR ${r.status}`;
};
$("redeem").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("redAmount").value||"0",10), req = $("redReq").value.trim();
  const r = await postJSON(`${st.node}/bridge/redeem`, {rid,amount,request_id:req}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `redeem OK: ticket=${r.body.redeem_ticket.slice(0,18)}…` : `ERR ${r.status}`;
};

/* =============== admin JWT =============== */
$("mintAdminToken").onclick = async ()=>{
  const key = $("adminKey").value.trim(), ttl = parseInt($("adminTtl").value||"600",10);
  const r = await fetch(`${st.node}/admin/token?ttl=${ttl}`, {headers: {"X-Admin-Key": key}});
  const body = await r.json().catch(()=>({}));
  $("adminRes").textContent = r.ok ? `OK token=${(body.token||"").slice(0,16)}…` : `ERR ${r.status}`;
};

/* =============== init =============== */
(async()=>{ await $("ping").onclick(); if(st.pkHex) await $("refreshState").onclick(); })();

```

```

## FILE: /root/logos_lrb/docs/snapshots/LRB_FULL_LIVE_20250905_1218.txt  (size=496424b)
```
# FULL LIVE SNAPSHOT — 2025-09-05T11:18:36Z
# sources:
#  - /root/logos_lrb
#  - /opt/logos/www/wallet
#  - /etc/systemd/system/logos-node@.service
#  - /etc/systemd/system/logos-healthcheck.service
#  - /etc/systemd/system/logos-healthcheck.timer
#  - /etc/nginx/sites-available/logos-api-lb.conf
#  - /usr/local/bin/logos_healthcheck.sh
# size limit per file: 800000 bytes



## FILE: /root/logos_lrb/.gitignore  (size=263b)
```
# Rust
target/
**/*.rs.bk

# Python
__pycache__/
*.pyc
.venv/
venv/

# Node/web (если появится сборка)
dist/
build/

# Local envs / secrets / data
.env
**/*.env
/etc/logos/
/var/lib/logos/
*.db
*.sqlite
*.sled
snapshots/
docs/LRB_SNAPSHOT_*.txt

```


## FILE: /root/logos_lrb/AUDIT_REPORT.md  (size=4963b)
```
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: /root/logos_lrb/Cargo.lock  (size=62325b)
```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aead"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
dependencies = [
 "crypto-common",
 "generic-array",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anyhow"
version = "1.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0674a1ddeecb70197781e945de4b3b8ffb61fa939a5597bcf48503737663100"

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "axum"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edca88bc138befd0323b20752846e6587272d3b03b0343c8ea28a6f819e6e71f"
dependencies = [
 "async-trait",
 "axum-core",
 "axum-macros",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "itoa",
 "matchit",
 "memchr",
 "mime",
 "percent-encoding",
 "pin-project-lite",
 "rustversion",
 "serde",
 "serde_json",
 "serde_path_to_error",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tower 0.5.2",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-core"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09f2bd6146b97ae3359fa0cc6d6b376d9539582c7b4220f041a33ec24c226199"
dependencies = [
 "async-trait",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "mime",
 "pin-project-lite",
 "rustversion",
 "sync_wrapper",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-macros"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57d123550fa8d071b7255cb0cc04dc302baa6c8c4a79f55701552684d8399bce"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"

[[package]]
name = "blake3"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3888aaa89e4b2a40fca9848e400f6a658a5a3978de7be858e209cafa8be9a4a0"
dependencies = [
 "arrayref",
 "arrayvec",
 "cc",
 "cfg-if",
 "constant_time_eq",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bs58"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf88ba1141d185c399bee5288d850d63b8369520c1eafc32a0430b5b6c287bf4"
dependencies = [
 "tinyvec",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "590f9024a68a8c40351881787f1934dc11afd69090f5edb6831464694d836ea3"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chacha20"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3613f74bd2eac03dad61bd53dbe620703d4371614fe0bc3b9f04dd36fe4e818"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "chacha20poly1305"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "10cd79432192d1c0f4e1a0fef9527696cc039165d729fb41b3f4f4f354c2dc35"
dependencies = [
 "aead",
 "chacha20",
 "cipher",
 "poly1305",
 "zeroize",
]

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "num-traits",
 "windows-link",
]

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common",
 "inout",
 "zeroize",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "constant_time_eq"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "typenum",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dashmap"
version = "5.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
dependencies = [
 "cfg-if",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core 0.9.11",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "rand_core 0.6.4",
 "serde",
 "sha2",
 "subtle",
 "zeroize",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "find-msvc-tools"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e178e4fba8a2726903f6ba98a6d221e76f9c12c650d5dc0e6afdc50677b49650"

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-core",
 "futures-task",
 "pin-project-lite",
 "pin-utils",
]

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "r-efi",
 "wasi 0.14.3+wasi-0.2.4",
 "wasm-bindgen",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "h2"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3c0b69cfcb4e1b9f1bf2f53f95f766e4661169728ec61cd3fe5a0166f2d1386"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "hyper"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb3aa54a13a0dfe7fbe3a59e0c76093041720fdc77b110cc0fc260fafb4dc51e"
dependencies = [
 "atomic-waker",
 "bytes",
 "futures-channel",
 "futures-core",
 "h2",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "pin-utils",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
 "webpki-roots",
]

[[package]]
name = "hyper-util"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d9b05277c7e8da2c93a568989bb6207bef0112e8d17df7a6eda4a3cf143bc5e"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2",
 "tokio",
 "tower-service",
 "tracing",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2481980430f9f78649238835720ddccc57e52df14ffce1c6f37391d61b563e9"
dependencies = [
 "equivalent",
 "hashbrown 0.15.5",
]

[[package]]
name = "inout"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
dependencies = [
 "generic-array",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "io-uring"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "046fa2d4d00aea763528b4950358d0ead425372445dc8ff86312b3c69ff7727b"
dependencies = [
 "bitflags 2.9.4",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.175"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a82ae493e598baaea5209805c49bbf2ea7de956d50d7da0da1164f9c6d28543"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "logos_node"
version = "0.1.0"
dependencies = [
 "anyhow",
 "axum",
 "base64",
 "blake3",
 "bs58",
 "chrono",
 "dashmap",
 "ed25519-dalek",
 "hex",
 "http",
 "hyper",
 "ipnet",
 "lrb_core",
 "once_cell",
 "parking_lot 0.12.4",
 "prometheus",
 "rand_core 0.6.4",
 "reqwest",
 "serde",
 "serde_json",
 "sled",
 "thiserror 1.0.69",
 "tokio",
 "tower 0.4.13",
 "tower-http 0.5.2",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "lrb_core"
version = "0.1.0"
dependencies = [
 "anyhow",
 "base64",
 "blake3",
 "bs58",
 "chacha20poly1305",
 "ed25519-dalek",
 "hex",
 "rand_core 0.6.4",
 "rayon",
 "reqwest",
 "serde",
 "serde_json",
 "sha2",
 "sled",
 "tokio",
 "uuid",
]

[[package]]
name = "lru-slab"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"

[[package]]
name = "matchers"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
dependencies = [
 "regex-automata",
]

[[package]]
name = "matchit"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4a28e057d01f97e61255210fcff094d74ed0466038633e95017f5beb68e4399"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.6",
]

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.11",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.17",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "poly1305"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8159bd90725d2df49889a078b54f4f79e87f1f8a8444194cdca81d38f5393abf"
dependencies = [
 "cpufeatures",
 "opaque-debug",
 "universal-hash",
]

[[package]]
name = "potential_utf"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84df19adbe5b5a0782edcab45899906947ab039ccf4573713735ee7de1e6b08a"
dependencies = [
 "zerovec",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "prometheus"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d33c28a30771f7f96db69893f78b857f7450d7e0237e9c8fc6427a81bae7ed1"
dependencies = [
 "cfg-if",
 "fnv",
 "lazy_static",
 "memchr",
 "parking_lot 0.12.4",
 "protobuf",
 "thiserror 1.0.69",
]

[[package]]
name = "protobuf"
version = "2.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "106dd99e98437432fed6519dedecfade6a06a73bb7b2a1e019fdd2bee5778d94"

[[package]]
name = "quinn"
version = "0.11.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e20a958963c291dc322d98411f541009df2ced7b5a4f2bd52337638cfccf20"
dependencies = [
 "bytes",
 "cfg_aliases",
 "pin-project-lite",
 "quinn-proto",
 "quinn-udp",
 "rustc-hash",
 "rustls",
 "socket2",
 "thiserror 2.0.16",
 "tokio",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-proto"
version = "0.11.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1906b49b0c3bc04b5fe5d86a77925ae6524a19b816ae38ce1e426255f1d8a31"
dependencies = [
 "bytes",
 "getrandom 0.3.3",
 "lru-slab",
 "rand",
 "ring",
 "rustc-hash",
 "rustls",
 "rustls-pki-types",
 "slab",
 "thiserror 2.0.16",
 "tinyvec",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-udp"
version = "0.5.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "addec6a0dcad8a8d96a771f815f0eaf55f9d1805756410b39f5fa81332574cbd"
dependencies = [
 "cfg_aliases",
 "libc",
 "once_cell",
 "socket2",
 "tracing",
 "windows-sys 0.59.0",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
dependencies = [
 "bitflags 2.9.4",
]

[[package]]
name = "regex-automata"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b9458fa0bfeeac22b5ca447c63aaf45f28439a709ccd244698632f9aa6394d6"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"

[[package]]
name = "reqwest"
version = "0.12.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d429f34c8092b2d42c7c93cec323bb4adeb7c67698f70839adec842ec10c7ceb"
dependencies = [
 "base64",
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-util",
 "js-sys",
 "log",
 "percent-encoding",
 "pin-project-lite",
 "quinn",
 "rustls",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-rustls",
 "tower 0.5.2",
 "tower-http 0.6.6",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "webpki-roots",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustc-demangle"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustls"
version = "0.23.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0ebcbd2f03de0fc1122ad9bb24b127a5a6cd51d72604a3f3c50ac459762b6cc"
dependencies = [
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "web-time",
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.143"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d401abef1d108fbd9cbaebc3e46611f4b1021f714a0597a71f41ee463f5f4a5a"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_path_to_error"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59fab13f937fa393d08645bf3a84bdfe86e296747b506ada67bb15f10f218b2a"
dependencies = [
 "itoa",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a4719bff48cee6b39d12c020eeb490953ad2443b7055bd0b21fca26bd8c28b"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "sled"
version = "0.34.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f96b4737c2ce5987354855aed3797279def4ebf734436c6aa4552cf8e169935"
dependencies = [
 "crc32fast",
 "crossbeam-epoch",
 "crossbeam-utils",
 "fs2",
 "fxhash",
 "libc",
 "log",
 "parking_lot 0.11.2",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3467d614147380f2e4e374161426ff399c91084acd2363eaf549172b3d5e60c0"
dependencies = [
 "thiserror-impl 2.0.16",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c5e1be1c48b9172ee610da68fd9cd2770e7a4056cb3fc98710ee6906f0c7960"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.47.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e49afdadebb872d3145a5638b59eb0691ea23e46ca484037cfab3b76b95038"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "parking_lot 0.12.4",
 "pin-project-lite",
 "signal-hook-registry",
 "slab",
 "socket2",
 "tokio-macros",
 "windows-sys 0.59.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-rustls"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14307c986784f72ef81c89db7d9e28d6ac26d16213b109ea501696195e6e3ce5"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tower"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8fa9be0de6cf49e536ce1851f987bd21a43b771b09473c3549a6c853db37c1c"
dependencies = [
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-http"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e9cd434a998747dd2c4276bc96ee2e0c7a2eadf3cae88e52be55a05fa9053f5"
dependencies = [
 "bitflags 2.9.4",
 "bytes",
 "http",
 "http-body",
 "http-body-util",
 "pin-project-lite",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags 2.9.4",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower 0.5.2",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2054a14f5307d601f88daf0553e1cbf472acc4f2c51afab632431cdcd72124d5"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex-automata",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "universal-hash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
dependencies = [
 "crypto-common",
 "subtle",
]

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08bc136a29a3d1758e07a9cca267be308aeebf5cfd5a10f3f67ab2097683ef5b"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
 "serde",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "uuid"
version = "1.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f87b8aa10b915a06587d0dec516c282ff295b475d94abf425d62b57710070a2"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.3+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a51ae83037bdd272a9e28ce236db8c07016dd0d50c27038b3f407533c030c95"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wit-bindgen"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "052283831dbae3d879dc7f51f3d92703a316ca49f91540417d38591826127814"

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7aa2bd55086f1ab526693ecbe444205da57e25f4489879da80635a46d90e73b"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

```


## FILE: /root/logos_lrb/Cargo.toml  (size=713b)
```
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: /root/logos_lrb/README.md  (size=841b)
```
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/genesis.yaml  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
```
# LOGOS node (пример ENV)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_SLOT_MS=500
LRB_MAX_BLOCK_TX=10000
LRB_MEMPOOL_CAP=100000
LRB_MAX_AMOUNT=18446744073709551615
LRB_BRIDGE_MAX_PER_TX=10000000

# Секреты — задаются ТОЛЬКО вне репозитория:
# LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
# LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=<optional>

```


## FILE: /root/logos_lrb/configs/logos_config.yaml  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
```
# Wallet Proxy / Scanner (пример ENV)
# !!! НЕ коммить настоящие ключи/приватники !!!
ETH_PROVIDER_URL=https://mainnet.infura.io/v3/XXXX...
USDT_CONTRACT=0xdAC17F958D2ee523a2206206994597C13D831ec7

# hot-кошелёк оператора (для withdraw/fee)
HOT_WALLET_ADDRESS=0x...
HOT_WALLET_PRIVATE_KEY= # НЕ класть в git, подставлять только в прод окружении

```


## FILE: /root/logos_lrb/core/beta_rollout.yaml  (size=3586b)
```
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: /root/logos_lrb/core/offline_resonance.py  (size=5400b)
```
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: /root/logos_lrb/core/onboarding_sim.py  (size=5458b)
```
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: /root/logos_lrb/core/onboarding_ui.py  (size=5974b)
```
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: /root/logos_lrb/core/rLGN_converter.py  (size=5518b)
```
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: /root/logos_lrb/core/resonance_analyzer.py  (size=3470b)
```
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: /root/logos_lrb/core/rid_builder.py  (size=5229b)
```
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: /root/logos_lrb/core/ritual_quest.py  (size=7912b)
```
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: /root/logos_lrb/docs/WORKFLOW.md  (size=5440b)
```
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: /root/logos_lrb/docs/architecture.md  (size=10559b)
```
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```


## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
```
# Пример (НЕ БОЕВОЙ! замените на свои)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=   # задаётся опционально

```


## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```


## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-node.service  (size=369b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```


## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```


## FILE: /root/logos_lrb/lrb_core/Cargo.toml  (size=665b)
```
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1"

serde = { version = "1", features = ["derive"] }
serde_json = "1"

sled = "0.34"

ed25519-dalek = { version = "2", features = ["rand_core"] }
bs58 = "0.5"

rayon = "1.10"

# криптография
chacha20poly1305 = { version = "0.10", features = ["std"] }
rand_core = "0.6"
sha2 = "0.10"
hex = "0.4"
base64 = "0.22"
blake3 = "1"

# async / сеть (для beacon.rs)
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }

# утилиты
uuid = { version = "1", features = ["v4"] }

```


## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1617b)
```
// Безопасный AEAD: XChaCha20-Poly1305 с уникальным nonce.
// Формат шифротекста: [24-байт nonce || ciphertext+tag]

use anyhow::Result;
use chacha20poly1305::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Key, XChaCha20Poly1305, XNonce,
};

pub struct AeadBox {
    key: Key,
}

impl AeadBox {
    pub fn from_key(key_bytes: &[u8; 32]) -> Self {
        let key = Key::from_slice(key_bytes);
        Self { key: *key }
    }

    pub fn seal(&self, aad: &[u8], plaintext: &[u8]) -> Vec<u8> {
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XChaCha20Poly1305::generate_nonce(&mut OsRng); // 24 байта
        let mut out = Vec::with_capacity(24 + plaintext.len() + 16);
        out.extend_from_slice(&nonce);
        let ct = cipher
            .encrypt(
                &nonce,
                chacha20poly1305::aead::Payload {
                    msg: plaintext,
                    aad,
                },
            )
            .expect("AEAD encrypt failed");
        out.extend_from_slice(&ct);
        out
    }

    pub fn open(&self, aad: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 24 + 16 {
            anyhow::bail!("AEAD: buffer too short");
        }
        let (nonce_bytes, ct) = data.split_at(24);
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XNonce::from_slice(nonce_bytes);
        let pt = cipher
            .decrypt(nonce, chacha20poly1305::aead::Payload { msg: ct, aad })
            .map_err(|_| anyhow::anyhow!("AEAD decrypt failed"))?;
        Ok(pt)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=12177b)
```
use crate::types::*;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sled::{Db, IVec, Tree};
use std::convert::TryInto;
use std::path::Path;

// key helpers
fn be64(v: u64) -> [u8; 8] {
    v.to_be_bytes()
}
fn be32(v: u32) -> [u8; 4] {
    v.to_be_bytes()
}
fn rid_str(r: &Rid) -> &str {
    &r.0
}

#[derive(Clone)]
pub struct Ledger {
    #[allow(dead_code)]
    db: Db,

    // balances
    lg_tree: Tree,   // rid -> u64 (BE)
    rlgn_tree: Tree, // rid -> u64 (BE)
    head_tree: Tree, // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree: db.open_tree("lgn")?,
            rlgn_tree: db.open_tree("rlgn")?,
            head_tree: db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree: db.open_tree("txs")?,
            acct_tree: db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self
            .head_tree
            .get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self
            .head_tree
            .get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self
            .head_tree
            .get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(
        &self,
        height: u64,
        hash: &str,
        ts_ms: u128,
        txs: &[Tx],
    ) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx {
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to: rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce: tx.nonce,
                height,
                index: i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1 + txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1 + 8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock {
            height,
            hash: hash.to_string(),
            ts_ms,
            tx_ids: ids,
        };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1 + 8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self
            .blocks_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredBlock>(&v))
            .transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1 + txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self
            .tx_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredTx>(&v))
            .transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(
        &self,
        rid: &str,
        limit: usize,
        cursor: Option<String>,
    ) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a");
            k.extend_from_slice(rid.as_bytes());
            k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage {
            rid: rid.to_string(),
            items,
            next_cursor,
        })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? {
            return Ok(false);
        }
        self.head_tree
            .insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        if cur < amt {
            anyhow::bail!("insufficient rLGN");
        }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k = rid_str(&tx.to).as_bytes();

            let from_bal = self
                .lg_tree
                .get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);
            if from_bal < tx.amount {
                anyhow::bail!("insufficient funds");
            }
            let to_bal = self
                .lg_tree
                .get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k, &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h {
                Ok(BlockHeaderView {
                    block_hash: head_hash,
                })
            } else {
                anyhow::bail!("block not found")
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=727b)
```
/*!
 * LOGOS LRB — core crate
 * Экспорт модулей ядра L1: типы, консенсус, мемпул/баланс, резонанс, сигналы, защита.
 * Здесь только декларация модулей — реализация в соответствующих *.rs файлах.
 */

pub mod types;

pub mod anti_replay;
pub mod beacon;
pub mod heartbeat;

pub mod dynamic_balance;
pub mod spam_guard;

pub mod phase_consensus;
pub mod phase_filters;
pub mod phase_integrity;
pub mod quorum;
pub mod sigpool;

pub mod ledger;
pub mod rcp_engine;
pub mod resonance;

// Безопасный AEAD (XChaCha20-Poly1305) — общий хелпер для модулей
pub mod crypto;

```


## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=1806b)
```
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize {
        self.quorum_n
    }
    pub fn finalized(&self) -> u64 {
        self.finalized_h
    }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes
            .get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_filters.rs  (size=1780b)
```
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN")
        .ok()
        .map(|v| v == "1")
        .unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',')
        .filter_map(|s| s.trim().parse::<f64>().ok())
        .collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE")
        .ok()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() {
        return 1.0;
    }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() {
        return true;
    }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=553b)
```
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig)
        .map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=1250b)
```
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk =
        VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(
        &sig_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("bad sig"))?,
    );

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig)
        .map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=7224b)
```
use crate::sigpool::filter_valid_sigs_parallel;
use crate::{dynamic_balance::DynamicBalance, ledger::Ledger, spam_guard::SpamGuard, types::*};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use anyhow::Result;
use std::{
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{
    broadcast,
    mpsc::{unbounded_channel, UnboundedSender},
};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount = env_u64("LRB_MAX_AMOUNT", u64::MAX / 2);
        let slot_ms = env_u64("LRB_SLOT_MS", 500);
        let quorum_n = env_usize("LRB_QUORUM_N", 1);
        let sig_workers = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> {
        self.ledger.clone()
    }
    pub fn proposer(&self) -> Rid {
        self.proposer.clone()
    }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) {
        *self.commit_tx.lock().unwrap() = Some(sender);
    }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> {
        self.guard.check_amount(amount)
    }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> {
        self.mempool_tx.clone()
    }
    pub fn mempool_len(&self) -> usize {
        self.mempool.lock().unwrap().len()
    }
    pub fn finalized_height(&self) -> u64 {
        self.consensus.lock().unwrap().finalized()
    }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() {
                    continue;
                }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() {
                continue;
            }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() {
                continue;
            }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```


## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=3363b)
```
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String, // blake3 of canonical form
    pub from: Rid,  // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>, // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,  // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 {
            return Err(anyhow!("bad pubkey len"));
        }
        if self.signature.len() != 64 {
            return Err(anyhow!("bad signature len"));
        }
        if self.amount == 0 {
            return Err(anyhow!("amount must be > 0"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
```
use axum::{
    extract::State,
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, time::Duration};
use tower::{ServiceBuilder};
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
    timeout::TimeoutLayer,
    limit::{RequestBodyLimitLayer},
};
use tracing_subscriber::{EnvFilter, fmt};
use ed25519_dalek::{SigningKey, VerifyingKey, SignatureError};
use rand_core::OsRng;
use bs58;
use once_cell::sync::OnceCell;
use anyhow::Result;

mod api;
mod admin;
mod bridge;
mod gossip;
mod state;
mod peers;
mod fork;

#[derive(Clone)]
struct AppState {
    signing: SigningKey,
    verifying: VerifyingKey,
    rid_b58: String,
    admin_key: String,
    bridge_key: String,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(bytes.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(data.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}

fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}

fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!("missing env {}", n))?;
    Ok(v)
}

fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY","CHANGE_ME","", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys + env
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid = rid_from_vk(&vk);

    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid.clone(),
        admin_key,
        bridge_key,
    };
    APP_STATE.set(state.clone()).unwrap();

    // CORS
    let cors = {
        let allowed_origin = std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| String::from("https://wallet.example"));
        CorsLayer::new()
            .allow_origin(allowed_origin.parse::<axum::http::HeaderValue>().unwrap())
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([axum::http::header::CONTENT_TYPE, axum::http::header::AUTHORIZATION])
    };

    // limits/timeout
    let layers = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(RequestBodyLimitLayer::new(512 * 1024)) // 512 KiB
        .layer(cors)
        .into_inner();

    // маршруты
    let app = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet)) // dev-only
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify))
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .with_state(state)
        .layer(layers);

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
    Ok(())
}

```


## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```


## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=1719b)
```
//! Точка-точка фазовая связка: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseLink {
    aead: AeadBox,
    self_vk: VerifyingKey,
    peer_vk: VerifyingKey,
}

impl PhaseLink {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey, peer_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk, peer_vk }
    }

    pub fn encode(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_link: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_link: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/node/Cargo.toml  (size=1014b)
```
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
axum = { version = "0.7", features = ["macros", "http2"] }
tokio = { version = "1", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace", "timeout", "limit"] }
hyper = { version = "1", features = ["http2"] }
http = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features=["env-filter", "fmt"] }
ed25519-dalek = { version = "2", features = ["rand_core"] }
rand_core = "0.6"
bs58 = "0.5"
anyhow = "1"
once_cell = "1"
prometheus = "0.13"
hex = "0.4"
base64 = "0.22"
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
blake3 = "1"
sled = "0.34"
dashmap = "5"
parking_lot = "0.12"
ipnet = "2"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```


## FILE: /root/logos_lrb/node/build.rs  (size=796b)
```
use std::process::Command;

fn main() {
    // git hash (короткий)
    let git = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".into());
    println!("cargo:rustc-env=GIT_COMMIT={}", git);

    // build time (UTC)
    let ts = chrono::Utc::now().to_rfc3339();
    println!("cargo:rustc-env=BUILD_TIME_UTC={}", ts);

    // rustc version
    let rustc = Command::new("rustc")
        .arg("--version")
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .unwrap_or_else(|| "rustc unknown".into());
    println!("cargo:rustc-env=RUSTC_VER={}", rustc.trim());
}

```


## FILE: /root/logos_lrb/node/src/JSON  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/LE  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/admin.rs  (size=1627b)
```
//! Админ-ручки: snapshot/restore и node_info.
//! Доступ защищается через заголовок X-Admin-Key = LRB_ADMIN_KEY.

use crate::AppState;
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

fn check_admin(st: &AppState, headers: &axum::http::HeaderMap) -> Result<(), StatusCode> {
    let got = headers
        .get("X-Admin-Key")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    if got == st.admin_key {
        Ok(())
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub height: u64,
    pub finalized: bool,
}

pub async fn node_info(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<NodeInfo>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(NodeInfo {
        rid: st.rid_b58.clone(),
        height: 0,
        finalized: false,
    }))
}

#[derive(Serialize)]
pub struct SnapshotResp {
    pub status: &'static str,
}

pub async fn snapshot(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

#[derive(Deserialize)]
#[allow(dead_code)]
pub struct RestoreReq {
    #[serde(default)]
    pub path: String,
}

pub async fn restore(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(_req): Json<RestoreReq>,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

```


## FILE: /root/logos_lrb/node/src/api.rs  (size=13341b)
```
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use hex;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::metrics::{inc_total, Timer};
use crate::storage::{AccountState, TxIn};
use crate::AppState;

use bs58;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use parking_lot::Mutex;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

/* ========= liveness / readiness ========= */

#[derive(Serialize)]
pub struct Healthz {
    pub status: &'static str,
}

pub async fn healthz() -> Json<Healthz> {
    Json(Healthz { status: "ok" })
}
pub async fn livez() -> Json<Healthz> {
    Json(Healthz { status: "ok" })
}
pub async fn readyz(State(_st): State<AppState>) -> Result<Json<Healthz>, StatusCode> {
    let t = Timer::new("/readyz", "GET");
    inc_total("/readyz", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(Healthz { status: "ready" }))
}

/* ========= helpers ========= */

#[derive(Serialize, Deserialize, Clone)]
struct CanonTx<'a> {
    from: &'a str,
    to: &'a str,
    amount: u64,
    nonce: u64,
}

fn canon_bytes(tx: &TxIn) -> Result<Vec<u8>, StatusCode> {
    let c = CanonTx {
        from: &tx.from,
        to: &tx.to,
        amount: tx.amount,
        nonce: tx.nonce,
    };
    serde_json::to_vec(&c).map_err(|_| StatusCode::BAD_REQUEST)
}
fn vk_from_rid(rid: &str) -> Result<VerifyingKey, StatusCode> {
    let b = bs58::decode(rid)
        .into_vec()
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    if b.len() != 32 {
        return Err(StatusCode::BAD_REQUEST);
    }
    VerifyingKey::from_bytes(b.as_slice().try_into().unwrap()).map_err(|_| StatusCode::BAD_REQUEST)
}
fn sig_from_hex(h: &str) -> Result<Signature, StatusCode> {
    let raw = hex::decode(h).map_err(|_| StatusCode::BAD_REQUEST)?;
    let arr: [u8; 64] = raw
        .as_slice()
        .try_into()
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    Ok(Signature::from_bytes(&arr))
}

/* ========= head / balance ========= */

#[derive(Serialize)]
pub struct HeadResp {
    pub height: u64,
    pub finalized: bool,
}

pub async fn head(State(st): State<AppState>) -> Json<HeadResp> {
    let t = Timer::new("/head", "GET");
    let h = st.store.get_height().unwrap_or(0);
    inc_total("/head", "GET", StatusCode::OK);
    t.observe();
    Json(HeadResp {
        height: h,
        finalized: false,
    })
}

#[derive(Serialize)]
pub struct BalanceResp {
    pub rid: String,
    pub balance: u64,
    pub nonce: u64,
}

pub async fn balance(State(st): State<AppState>, Path(rid): Path<String>) -> Json<BalanceResp> {
    let t = Timer::new("/balance/:rid", "GET");
    let a = st.store.get_account(&rid).unwrap_or_default();
    inc_total("/balance/:rid", "GET", StatusCode::OK);
    t.observe();
    Json(BalanceResp {
        rid,
        balance: a.balance,
        nonce: a.nonce,
    })
}

/* ========= history / block ========= */

#[derive(Deserialize)]
pub struct HistoryQuery {
    #[serde(default)]
    pub from: u64,
    #[serde(default = "def_limit")]
    pub limit: usize,
}
fn def_limit() -> usize {
    20
}

#[derive(Serialize)]
pub struct HistoryResp {
    pub rid: String,
    pub from: u64,
    pub limit: usize,
    pub next_from: Option<u64>,
    pub items: Vec<crate::storage::HistoryItem>,
}

pub async fn history(
    State(st): State<AppState>,
    Path(rid): Path<String>,
    Query(q): Query<HistoryQuery>,
) -> Result<Json<HistoryResp>, StatusCode> {
    let t = Timer::new("/history/:rid", "GET");
    let (items, next_from) = st
        .store
        .history_page(&rid, q.from, q.limit.min(1000))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/history/:rid", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(HistoryResp {
        rid,
        from: q.from,
        limit: q.limit,
        next_from,
        items,
    }))
}

#[derive(Serialize)]
pub struct BlockResp {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

pub async fn block(
    State(st): State<AppState>,
    Path(h): Path<u64>,
) -> Result<Json<BlockResp>, StatusCode> {
    let t = Timer::new("/block/:height", "GET");
    let br = st
        .store
        .get_block(h)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let br = br.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(BlockResp {
        height: br.height,
        ts_ms: br.ts_ms,
        txs: br.txs,
    }))
}

/* ========= submit_tx / batch (strict prefix per RID) ========= */

#[derive(Deserialize)]
pub struct SubmitTxBatchReq {
    #[serde(default)]
    pub txs: Vec<TxIn>,
}
#[derive(Serialize)]
pub struct TxResult {
    pub idx: usize,
    pub status: &'static str,
    pub code: u16,
    pub reason: &'static str,
}
#[derive(Serialize)]
pub struct SubmitTxBatchResp {
    pub accepted: usize,
    pub rejected: usize,
    pub new_height: u64,
    pub results: Vec<TxResult>,
}

pub async fn submit_tx_batch(
    State(st): State<AppState>,
    Json(req): Json<SubmitTxBatchReq>,
) -> Result<Json<SubmitTxBatchResp>, StatusCode> {
    let t = Timer::new("/submit_tx_batch", "POST");
    if req.txs.is_empty() {
        inc_total("/submit_tx_batch", "POST", StatusCode::BAD_REQUEST);
        t.observe();
        return Err(StatusCode::BAD_REQUEST);
    }

    let mut by_sender: BTreeMap<String, Vec<(usize, TxIn)>> = BTreeMap::new();
    for (i, tx) in req.txs.into_iter().enumerate() {
        by_sender.entry(tx.from.clone()).or_default().push((i, tx));
    }

    let mut results = Vec::new();
    let mut acc_total = 0usize;
    let mut rej_total = 0usize;
    let mut last_h = st.store.get_height().unwrap_or(0);

    for (from, mut items) in by_sender.into_iter() {
        items.sort_by_key(|(_, tx)| tx.nonce);
        let lk = st
            .locks
            .entry(from.clone())
            .or_insert_with(|| Arc::new(Mutex::new(())))
            .clone();
        let _g = lk.lock();
        let mut next = st.store.get_account(&from).unwrap_or_default().nonce;
        let mut cache: HashMap<String, AccountState> = HashMap::new();
        let mut valid: Vec<TxIn> = Vec::new();

        for (idx, tx) in items.into_iter() {
            // подпись
            let vk = match vk_from_rid(&tx.from) {
                Ok(v) => v,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 400,
                        reason: "bad_rid",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            let sig = match sig_from_hex(&tx.sig_hex) {
                Ok(s) => s,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 401,
                        reason: "bad_sig",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            let msg = match canon_bytes(&tx) {
                Ok(m) => m,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 400,
                        reason: "bad_canon",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            if vk.verify(&msg, &sig).is_err() {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 401,
                    reason: "bad_sig",
                });
                inc_tx_err();
                continue;
            }

            // nonce строгий префикс
            if tx.nonce != next.saturating_add(1) {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 409,
                    reason: "bad_nonce",
                });
                inc_tx_err();
                continue;
            }

            // баланс
            let fs = cache
                .get(&tx.from)
                .cloned()
                .unwrap_or_else(|| st.store.get_account(&tx.from).unwrap_or_default());
            let ts = cache
                .get(&tx.to)
                .cloned()
                .unwrap_or_else(|| st.store.get_account(&tx.to).unwrap_or_default());
            if tx.from != tx.to && fs.balance < tx.amount {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 402,
                    reason: "insufficient_funds",
                });
                inc_tx_err();
                continue;
            }

            // применяем в кэше
            let mut nf = fs;
            let mut nt = ts;
            next = next.saturating_add(1);
            nf.nonce = next;
            if tx.from != tx.to {
                nf.balance = nf.balance.saturating_sub(tx.amount);
                nt.balance = nt.balance.saturating_add(tx.amount);
            }
            cache.insert(tx.from.clone(), nf);
            cache.insert(tx.to.clone(), nt);

            valid.push(tx);
            acc_total += 1;
            results.push(TxResult {
                idx,
                status: "accepted",
                code: 0,
                reason: "ok",
            });
        }

        if !valid.is_empty() {
            last_h = st
                .store
                .apply_batch(&valid)
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        }
    }

    let resp = SubmitTxBatchResp {
        accepted: acc_total,
        rejected: rej_total,
        new_height: last_h,
        results,
    };
    inc_total("/submit_tx_batch", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(resp))
}

// локальный счётчик для кратких метрик отказов в батче
#[inline]
fn inc_tx_err() { /* опционально можно дернуть метрику отказов */
}

/* ========= одиночная submit_tx ========= */

#[derive(Deserialize)]
pub struct SubmitTxReq {
    #[serde(default)]
    pub _payload: serde_json::Value,
}
#[derive(Serialize)]
pub struct SubmitTxResp {
    pub status: &'static str,
}

pub async fn submit_tx(
    State(_st): State<AppState>,
    Json(_req): Json<SubmitTxReq>,
) -> Result<Json<SubmitTxResp>, StatusCode> {
    let t = Timer::new("/submit_tx", "POST");
    inc_total("/submit_tx", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(SubmitTxResp { status: "accepted" }))
}

/* ========= debug_canon ========= */

#[derive(Deserialize)]
pub struct DebugCanonReq {
    #[serde(default)]
    pub tx: serde_json::Value,
}
#[derive(Serialize)]
pub struct DebugCanonResp {
    pub canon_hex: String,
}

pub async fn debug_canon(
    Json(req): Json<DebugCanonReq>,
) -> Result<Json<DebugCanonResp>, StatusCode> {
    let t = Timer::new("/debug_canon", "POST");

    let from = req
        .tx
        .get("from")
        .and_then(|v| v.as_str())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let to = req
        .tx
        .get("to")
        .and_then(|v| v.as_str())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let amount = req
        .tx
        .get("amount")
        .and_then(|v| v.as_u64())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let nonce = req
        .tx
        .get("nonce")
        .and_then(|v| v.as_u64())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let c = CanonTx {
        from,
        to,
        amount,
        nonce,
    };
    let bytes = serde_json::to_vec(&c).map_err(|_| StatusCode::BAD_REQUEST)?;
    let canon_hex = hex::encode(bytes);

    inc_total("/debug_canon", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(DebugCanonResp { canon_hex }))
}

/* ========= faucet (DEV-фича-флаг) ========= */

#[derive(Deserialize)]
pub struct FaucetReq {
    #[serde(default)]
    pub rid: String,
    #[serde(default)]
    pub amount: u64,
}
#[derive(Serialize)]
pub struct FaucetResp {
    pub granted: u64,
    pub rid: String,
}

pub async fn faucet(
    State(st): State<AppState>,
    Json(req): Json<FaucetReq>,
) -> Result<Json<FaucetResp>, StatusCode> {
    // работает ТОЛЬКО если LRB_ENABLE_FAUCET=1
    if std::env::var("LRB_ENABLE_FAUCET").ok().as_deref() != Some("1") {
        return Err(StatusCode::FORBIDDEN);
    }
    let t = Timer::new("/faucet", "POST");
    if req.rid.is_empty() || req.amount == 0 {
        inc_total("/faucet", "POST", StatusCode::BAD_REQUEST);
        t.observe();
        return Err(StatusCode::BAD_REQUEST);
    }
    let _st = st
        .store
        .faucet(&req.rid, req.amount)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/faucet", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(FaucetResp {
        granted: req.amount,
        rid: req.rid,
    }))
}

```


## FILE: /root/logos_lrb/node/src/auth.rs  (size=5131b)
```
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: /root/logos_lrb/node/src/bin/aead_selftest.rs  (size=1723b)
```
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use lrb_core::crypto::AeadBox;
use rand_core::{OsRng, RngCore};

fn main() {
    // 1) Ed25519: ключи + подпись/проверка
    let sk = SigningKey::generate(&mut OsRng);
    let vk = VerifyingKey::from(&sk);
    let msg = b"resonance-test-message";
    let sig = sk.sign(msg);
    assert!(vk.verify_strict(msg, &sig).is_ok(), "ed25519 verify failed");

    // 2) AEAD: XChaCha20-Poly1305, уникальный nonce внутри AeadBox
    let mut key32 = [0u8; 32];
    OsRng.fill_bytes(&mut key32);
    let aead = AeadBox::from_key(&key32);

    let aad = b"topic:external-phase|self-vk";
    let pt = "hello, Σ(t)!".as_bytes();

    let ct = aead.seal(aad, pt);
    let dec = aead.open(aad, &ct).expect("aead open failed");
    assert_eq!(dec.as_slice(), pt, "aead roundtrip mismatch");

    // 3) Негатив: порча шифротекста → ошибка
    let mut ct_bad = ct.clone();
    if let Some(last) = ct_bad.last_mut() {
        *last ^= 0xFF; // безопасно мутируем последний байт без двух заимствований
    }
    assert!(aead.open(aad, &ct_bad).is_err(), "aead must fail on tamper");

    // 4) Негатив: смена AAD → ошибка
    let aad_bad = b"topic:changed";
    assert!(
        aead.open(aad_bad, &ct).is_err(),
        "aead must fail on wrong AAD"
    );

    // 5) Подпись поверх шифротекста (seal-then-sign)
    let sig_ct = sk.sign(&ct);
    assert!(
        vk.verify_strict(&ct, &sig_ct).is_ok(),
        "sign(sealed) verify failed"
    );

    println!("OK: ed25519 + AeadBox(XChaCha20-Poly1305) self-test passed");
}

```


## FILE: /root/logos_lrb/node/src/bridge.rs  (size=1919b)
```
#![allow(dead_code)]
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

use crate::AppState;

#[derive(Deserialize)]
pub struct DepositReq {
    pub rid: String,
    pub amount: u64,
    #[serde(default)]
    pub txid: String,
}

#[derive(Serialize)]
pub struct DepositResp {
    pub status: &'static str,
    pub rid: String,
    pub credited: u64,
}

pub async fn deposit(
    State(_st): State<AppState>,
    Json(req): Json<DepositReq>,
) -> Result<Json<DepositResp>, StatusCode> {
    // TODO(след. пачка): валидация квитка/квоты и зачисление rToken
    Ok(Json(DepositResp {
        status: "accepted",
        rid: req.rid,
        credited: req.amount,
    }))
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub rid: String,
    pub amount: u64,
    #[serde(default)]
    pub target_chain: String,
    #[serde(default)]
    pub target_address: String,
}

#[derive(Serialize)]
pub struct RedeemResp {
    pub status: &'static str,
    pub rid: String,
    pub debited: u64,
}

pub async fn redeem(
    State(_st): State<AppState>,
    Json(req): Json<RedeemReq>,
) -> Result<Json<RedeemResp>, StatusCode> {
    // TODO(след. пачка): резерв/списание rToken и квиток на вывод
    Ok(Json(RedeemResp {
        status: "accepted",
        rid: req.rid,
        debited: req.amount,
    }))
}

#[derive(Deserialize)]
pub struct VerifyReq {
    #[serde(default)]
    pub ticket: String,
}

#[derive(Serialize)]
pub struct VerifyResp {
    pub status: &'static str,
    #[serde(default)]
    pub ok: bool,
}

pub async fn verify(
    State(_st): State<AppState>,
    Json(_req): Json<VerifyReq>,
) -> Result<Json<VerifyResp>, StatusCode> {
    // TODO(след. пачка): проверка подписи/кворума
    Ok(Json(VerifyResp {
        status: "ok",
        ok: true,
    }))
}

```


## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```


## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```


## FILE: /root/logos_lrb/node/src/guard.rs  (size=2977b)
```
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Instant;

use axum::{
    body::Body,
    extract::ConnectInfo,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use dashmap::DashMap;
use ipnet::IpNet;
use parking_lot::Mutex;

/// Парсим список CIDR из строки "a,b,c"
pub fn parse_ip_allowlist(s: &str) -> Vec<IpNet> {
    s.split(',')
        .filter_map(|x| x.trim().parse::<IpNet>().ok())
        .collect()
}

/// IP-ACL для админ-ручек
pub async fn admin_ip_gate(
    req: Request<Body>,
    next: Next,
    allow: Arc<Vec<IpNet>>,
) -> Result<Response, StatusCode> {
    let peer = req
        .extensions()
        .get::<ConnectInfo<SocketAddr>>()
        .map(|c| c.0);
    let ip = match peer {
        Some(sa) => sa.ip(),
        None => return Err(StatusCode::FORBIDDEN),
    };
    if !allow.iter().any(|net| net.contains(&ip)) {
        return Err(StatusCode::FORBIDDEN);
    }
    Ok(next.run(req).await)
}

/// Храним для IP свой защищённый мьютексом бакет
struct Bucket {
    tokens: f64,
    last: Instant,
}

pub struct RateLimiter {
    qps: f64,
    burst: f64,
    map: DashMap<std::net::IpAddr, Arc<Mutex<Bucket>>>,
    bypass: Arc<Vec<IpNet>>,
}

impl RateLimiter {
    pub fn new(qps: u64, burst: u64, bypass: Arc<Vec<IpNet>>) -> Self {
        Self {
            qps: qps as f64,
            burst: burst as f64,
            map: DashMap::new(),
            bypass,
        }
    }

    fn is_bypass(&self, ip: &std::net::IpAddr) -> bool {
        self.bypass.iter().any(|n| n.contains(ip))
    }

    fn check_and_consume(&self, ip: std::net::IpAddr) -> bool {
        if self.is_bypass(&ip) {
            return true;
        }

        let now = Instant::now();
        let bucket_arc = self
            .map
            .entry(ip)
            .or_insert_with(|| {
                Arc::new(Mutex::new(Bucket {
                    tokens: self.burst,
                    last: now,
                }))
            })
            .clone();

        let mut b = bucket_arc.lock();
        let add = self.qps * b.last.elapsed().as_secs_f64();
        b.tokens = (b.tokens + add).min(self.burst);
        b.last = now;

        if b.tokens >= 1.0 {
            b.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

/// Axum middleware: per-IP rate-limit (возвращает 429 при превышении)
pub async fn rate_limit_ip_gate(
    req: Request<Body>,
    next: Next,
    limiter: Arc<RateLimiter>,
) -> Result<Response, StatusCode> {
    let peer = req
        .extensions()
        .get::<ConnectInfo<SocketAddr>>()
        .map(|c| c.0);
    let ip = match peer {
        Some(sa) => sa.ip(),
        None => return Err(StatusCode::TOO_MANY_REQUESTS),
    };
    if !limiter.check_and_consume(ip) {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    Ok(next.run(req).await)
}

```


## FILE: /root/logos_lrb/node/src/main.rs  (size=7196b)
```
use anyhow::Result;
use axum::{
    middleware::from_fn,
    routing::{get, post},
    Router,
};
use bs58;
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::OnceCell;
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tower_http::{
    cors::CorsLayer, limit::RequestBodyLimitLayer, timeout::TimeoutLayer, trace::TraceLayer,
};
use tracing_subscriber::{fmt, EnvFilter};

use lrb_core::ledger::Ledger;
use lrb_core::rcp_engine::engine_with_channels;
use lrb_core::types::Rid;

mod admin;
mod api;
mod bridge;
mod fork;
mod guard;
mod metrics;
mod openapi;
mod peers;
mod state;
mod storage;
mod version;

use dashmap::DashMap;
use parking_lot::Mutex;

#[derive(Clone)]
pub struct AppState {
    pub signing: SigningKey,
    pub verifying: VerifyingKey,
    pub rid_b58: String,
    pub admin_key: String,
    pub bridge_key: String,
    pub ledger: Ledger,
    pub store: Arc<storage::Storage>,
    pub locks: Arc<DashMap<String, Arc<Mutex<()>>>>,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(
            bytes
                .as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(
            data.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}
fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}
fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!(format!("missing env {}", n)))?;
    Ok(v)
}
fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY", "CHANGE_ME", "", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid_b58 = rid_from_vk(&vk);
    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let data_dir = std::env::var("LRB_DATA_DIR").unwrap_or_else(|_| "/var/lib/logos".into());
    std::fs::create_dir_all(&data_dir).ok();
    let ledger = Ledger::open(&data_dir)?;
    let store_path = format!("{}/node_state", data_dir);
    let store = Arc::new(storage::Storage::open(store_path)?);

    let app_state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid_b58.clone(),
        admin_key,
        bridge_key,
        ledger: ledger.clone(),
        store,
        locks: Arc::new(DashMap::new()),
    };
    APP_STATE.set(app_state.clone()).ok();

    let rid = Rid(rid_b58.clone());
    let _engine = engine_with_channels(ledger, rid);

    let allowed_origin =
        std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| "http://localhost".into());
    let cors = {
        let hv = allowed_origin
            .parse::<axum::http::HeaderValue>()
            .expect("bad LRB_WALLET_ORIGIN");
        CorsLayer::new()
            .allow_origin(hv)
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([
                axum::http::header::CONTENT_TYPE,
                axum::http::header::AUTHORIZATION,
            ])
    };

    // Rate-limit
    let qps: u64 = std::env::var("LRB_RATE_QPS")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(20);
    let burst: u64 = std::env::var("LRB_RATE_BURST")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(40);
    let rl_enabled = qps > 0 && burst > 0;
    let bypass_cidr =
        std::env::var("LRB_RATE_BYPASS_CIDR").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let bypass = Arc::new(guard::parse_ip_allowlist(&bypass_cidr));
    let rl = Arc::new(guard::RateLimiter::new(qps, burst, bypass.clone()));

    // Admin IP ACL
    let admin_allow =
        std::env::var("LRB_ADMIN_IP_ALLOW").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let admin_nets = Arc::new(guard::parse_ip_allowlist(&admin_allow));

    let public = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/livez", get(api::livez))
        .route("/readyz", get(api::readyz))
        .route("/version", get(version::version))
        .route("/openapi.json", get(openapi::spec))
        .route("/metrics", get(metrics::metrics_handler))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/history/:rid", get(api::history))
        .route("/block/:height", get(api::block))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet));

    let admin_routes = Router::new()
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .layer(from_fn({
            let nets = admin_nets.clone();
            move |req, next| guard::admin_ip_gate(req, next, nets.clone())
        }));

    let bridge_routes = Router::new()
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify));

    let mut app = public
        .merge(admin_routes)
        .merge(bridge_routes)
        .with_state(app_state)
        .layer(cors)
        .layer(RequestBodyLimitLayer::new(512 * 1024))
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(TraceLayer::new_for_http());

    if rl_enabled {
        app = app.layer(from_fn({
            let rl = rl.clone();
            move |req, next| guard::rate_limit_ip_gate(req, next, rl.clone())
        }));
    }

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(addr).await?;
    tracing::info!(
        "logos_node listening on {} (RID={}), rate_limit={} (qps={}, burst={}), bypass={}",
        addr,
        rid_b58,
        if rl_enabled { "on" } else { "off" },
        qps,
        burst,
        bypass_cidr
    );
    axum::serve(
        listener,
        app.into_make_service_with_connect_info::<SocketAddr>(),
    )
    .await?;
    Ok(())
}

```


## FILE: /root/logos_lrb/node/src/main.rs:30:18  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/main.rs:67:29  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/metrics.rs  (size=2923b)
```
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use prometheus::{
    histogram_opts, opts, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_gauge_with_registry, Encoder,
    HistogramVec, IntCounterVec, IntGauge, Registry, TextEncoder,
};
use std::time::Instant;

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static HTTP_REQ_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("http_requests_total", "Total HTTP requests"),
        &["endpoint", "method", "status"],
        &REGISTRY
    )
    .unwrap()
});
pub static HTTP_REQ_DUR: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec_with_registry!(
        histogram_opts!("http_request_duration_seconds", "HTTP duration").buckets(vec![
            0.001, 0.002, 0.005, 0.010, 0.020, 0.050, 0.100, 0.200, 0.500, 1.0, 2.0, 5.0
        ]),
        &["endpoint", "method"],
        &REGISTRY
    )
    .unwrap()
});
pub static INFLIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge_with_registry!(opts!("http_inflight_requests", "In-flight"), &REGISTRY)
        .unwrap()
});

// New app metrics
pub static HIST_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_history_requests_total", "History requests"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});
pub static BLOCKS_SERVED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_blocks_served_total", "Blocks served"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});

pub struct Timer {
    start: Instant,
    endpoint: &'static str,
    method: &'static str,
}
impl Timer {
    pub fn new(endpoint: &'static str, method: &'static str) -> Self {
        INFLIGHT.inc();
        Self {
            start: Instant::now(),
            endpoint,
            method,
        }
    }
    pub fn observe(self) {
        let dt = self.start.elapsed().as_secs_f64();
        HTTP_REQ_DUR
            .with_label_values(&[self.endpoint, self.method])
            .observe(dt);
        INFLIGHT.dec();
    }
}
pub fn inc_total(endpoint: &'static str, method: &'static str, status: StatusCode) {
    HTTP_REQ_TOTAL
        .with_label_values(&[endpoint, method, status.as_str()])
        .inc();
}
pub async fn metrics_handler() -> Response {
    let mf = REGISTRY.gather();
    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();
    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        [("Content-Type", enc.format_type().to_string())],
        buf,
    )
        .into_response()
}

```


## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```


## FILE: /root/logos_lrb/node/src/openapi.rs  (size=222b)
```
use axum::{http::StatusCode, response::IntoResponse};

pub async fn spec() -> impl IntoResponse {
    (
        StatusCode::OK,
        [("Content-Type", "application/json")],
        include_str!("openapi.json"),
    )
}

```


## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```


## FILE: /root/logos_lrb/node/src/peers.rs:75:25  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/state.rs  (size=211b)
```
//! Reserved for future network helpers (kept minimal to avoid dead_code warnings).
//! Прод-уровень: пустой модуль без неиспользуемых структур и функций.

```


## FILE: /root/logos_lrb/node/src/storage.rs  (size=7739b)
```
//! Узловое persistent-хранилище (sled, один Tree "kv"):
//!   accounts/<RID>                  -> JSON {balance, nonce}
//!   chain/height                    -> LE u64
//!   blocks/<height:016x>            -> JSON BlockRecord {height, ts_ms, txs}
//!   history/<RID>/<nonce:016x>      -> JSON HistoryItem {nonce, from, to, amount, height, ts_ms}

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub nonce: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub height: u64,
    pub ts_ms: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

pub struct Storage {
    db: sled::Db,
    kv: sled::Tree,
}

impl Storage {
    pub fn open<P: AsRef<std::path::Path>>(path: P) -> Result<Self> {
        std::fs::create_dir_all(&path).ok();
        let db = sled::open(path)?;
        let kv = db.open_tree("kv")?;
        let _ = kv.compare_and_swap(
            b"chain/height",
            None as Option<&[u8]>,
            Some(0u64.to_le_bytes().to_vec()),
        )?;
        Ok(Self { db, kv })
    }

    #[inline]
    fn k_account(rid: &str) -> String {
        format!("accounts/{}", rid)
    }
    #[inline]
    fn k_block(height: u64) -> String {
        format!("blocks/{:016x}", height)
    }
    #[inline]
    fn k_hist(rid: &str, nonce: u64) -> String {
        format!("history/{}/{:016x}", rid, nonce)
    }

    #[inline]
    fn now_ms() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64
    }

    // ------- Accounts

    pub fn get_account(&self, rid: &str) -> Result<AccountState> {
        if let Some(v) = self.kv.get(Self::k_account(rid).as_bytes())? {
            let st: AccountState = serde_json::from_slice(&v)?;
            Ok(st)
        } else {
            Ok(AccountState::default())
        }
    }

    pub fn faucet(&self, rid: &str, amount: u64) -> Result<AccountState> {
        let mut st = self.get_account(rid)?;
        st.balance = st.balance.saturating_add(amount);
        self.kv
            .insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(&st)?)?;
        self.db.flush()?;
        Ok(st)
    }

    // ------- Apply batch: атомарно применяем префикс и индексируем историю+блок

    pub fn apply_batch(&self, txs: &[TxIn]) -> Result<u64> {
        let mut batch = sled::Batch::default();
        let mut acc_cache: std::collections::HashMap<String, AccountState> =
            std::collections::HashMap::new();

        for tx in txs {
            if tx.from == tx.to {
                let mut from = acc_cache
                    .remove(&tx.from)
                    .unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                from.nonce = from.nonce.saturating_add(1);
                acc_cache.insert(tx.from.clone(), from);
            } else {
                let mut from = acc_cache
                    .remove(&tx.from)
                    .unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                let mut to = acc_cache
                    .remove(&tx.to)
                    .unwrap_or(self.get_account(&tx.to).unwrap_or_default());

                if from.balance >= tx.amount {
                    from.balance = from.balance.saturating_sub(tx.amount);
                    to.balance = to.balance.saturating_add(tx.amount);
                }
                from.nonce = from.nonce.saturating_add(1);

                acc_cache.insert(tx.from.clone(), from);
                acc_cache.insert(tx.to.clone(), to);
            }
        }

        for (rid, st) in acc_cache.iter() {
            batch.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(st)?);
        }

        let cur_h = self.get_height()?;
        let new_h = cur_h + 1;
        let ts_ms = Self::now_ms();

        let block = BlockRecord {
            height: new_h,
            ts_ms,
            txs: txs.to_vec(),
        };
        batch.insert("chain/height".as_bytes(), new_h.to_le_bytes().to_vec());
        batch.insert(Self::k_block(new_h).as_bytes(), serde_json::to_vec(&block)?);

        for tx in txs {
            let item = HistoryItem {
                nonce: tx.nonce,
                from: tx.from.clone(),
                to: tx.to.clone(),
                amount: tx.amount,
                height: new_h,
                ts_ms,
            };
            batch.insert(
                Self::k_hist(&tx.from, tx.nonce).as_bytes(),
                serde_json::to_vec(&item)?,
            );
            batch.insert(
                Self::k_hist(&tx.to, tx.nonce).as_bytes(),
                serde_json::to_vec(&item)?,
            );
        }

        self.kv.apply_batch(batch)?;
        self.db.flush()?;
        Ok(new_h)
    }

    pub fn get_height(&self) -> Result<u64> {
        if let Some(v) = self.kv.get(b"chain/height")? {
            let mut arr = [0u8; 8];
            arr.copy_from_slice(&v[..8.min(v.len())]);
            Ok(u64::from_le_bytes(arr))
        } else {
            Ok(0)
        }
    }

    pub fn get_block(&self, height: u64) -> Result<Option<BlockRecord>> {
        Ok(self
            .kv
            .get(Self::k_block(height).as_bytes())?
            .map(|v| serde_json::from_slice::<BlockRecord>(&v))
            .transpose()?)
    }

    /// Страница истории по RID: nonce >= from_nonce, не более limit; возвращает (items, next_from)
    pub fn history_page(
        &self,
        rid: &str,
        from_nonce: u64,
        limit: usize,
    ) -> Result<(Vec<HistoryItem>, Option<u64>)> {
        let prefix = format!("history/{}/", rid);
        let start = format!("{}{:016x}", prefix, from_nonce);
        let mut out = Vec::with_capacity(limit.min(1024));
        let mut last_nonce: Option<u64> = None;
        let mut iter = self.kv.range(start.as_bytes()..);

        while let Some(kv) = iter.next() {
            let (k, v) = kv?;
            if !k.starts_with(prefix.as_bytes()) {
                break;
            }
            let item: HistoryItem = serde_json::from_slice(&v)?;
            out.push(item.clone());
            last_nonce = Some(item.nonce);
            if out.len() >= limit {
                break;
            }
        }

        let next_from = if let Some(n) = last_nonce {
            let next_key = format!("{}{:016x}", prefix, n.saturating_add(1));
            if let Some(kv) = self.kv.range(next_key.as_bytes()..).next() {
                let (k, _) = kv?;
                if k.starts_with(prefix.as_bytes()) {
                    Some(n.saturating_add(1))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        Ok((out, next_from))
    }

    /// Старый интерфейс для совместимости
    pub fn history_from(
        &self,
        rid: &str,
        from_nonce: u64,
        limit: usize,
    ) -> Result<Vec<HistoryItem>> {
        Ok(self.history_page(rid, from_nonce, limit)?.0)
    }
}

// Входная транзакция
#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    #[serde(default)]
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,
}

```


## FILE: /root/logos_lrb/node/src/version.rs  (size=520b)
```
use axum::Json;
use serde::Serialize;

#[derive(Serialize)]
pub struct VersionInfo {
    pub name: &'static str,
    pub version: &'static str,
    pub git_commit: &'static str,
    pub build_time_utc: &'static str,
    pub rustc: &'static str,
}

pub async fn version() -> Json<VersionInfo> {
    Json(VersionInfo {
        name: "logos_node",
        version: env!("CARGO_PKG_VERSION"),
        git_commit: env!("GIT_COMMIT"),
        build_time_utc: env!("BUILD_TIME_UTC"),
        rustc: env!("RUSTC_VER"),
    })
}

```


## FILE: /root/logos_lrb/py_err.log  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
```
#!/usr/bin/env bash
set -euo pipefail
DOMAIN="${DOMAIN:-example.com}"
INSTANCE="${INSTANCE:-a}"

sudo apt-get update -y
sudo apt-get install -y git curl jq build-essential pkg-config libssl-dev nginx

/usr/bin/id logos >/dev/null 2>&1 || sudo useradd -r -m -d /var/lib/logos -s /usr/sbin/nologin logos
sudo mkdir -p /opt/logos /etc/logos /var/lib/logos /opt/logos/www/wallet

cd "$(dirname "$0")/.."
cargo build --release -p logos_node
sudo cp ./target/release/logos_node /opt/logos/logos_node
sudo chown logos:logos /opt/logos/logos_node
sudo chmod 755 /opt/logos/logos_node

sudo cp ./infra/systemd/logos-node@.service /etc/systemd/system/logos-node@.service
sudo systemctl daemon-reload

sudo cp ./infra/nginx/logos-api-lb.conf.example /etc/nginx/sites-available/logos-api-lb.conf
sudo sed -i "s/YOUR_DOMAIN/${DOMAIN}/" /etc/nginx/sites-available/logos-api-lb.conf
sudo ln -sf /etc/nginx/sites-available/logos-api-lb.conf /etc/nginx/sites-enabled/logos-api-lb.conf
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

sudo cp -r ./www/wallet/* /opt/logos/www/wallet/
sudo chown -R logos:logos /opt/logos/www

if [ ! -f "/etc/logos/node-${INSTANCE}.env" ]; then
  sudo cp ./configs/env/node.env.example "/etc/logos/node-${INSTANCE}.env"
  echo ">>> EDIT /etc/logos/node-${INSTANCE}.env (LRB_NODE_SK_HEX/LRB_ADMIN_KEY/LRB_WALLET_ORIGIN)"
fi

sudo systemctl enable --now "logos-node@${INSTANCE}"
systemctl --no-pager status "logos-node@${INSTANCE}"

echo "API: http://127.0.0.1:8080   Wallet: http://${DOMAIN}/wallet/"

```


## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
```
#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="/root/logos_lrb"
GIT_REMOTE="${GIT_REMOTE:-origin}"
GIT_BRANCH="${GIT_BRANCH:-main}"
INCLUDE_SNAPSHOT="${INCLUDE_SNAPSHOT:-0}"

echo "[i] collecting from live system → $REPO_ROOT"
cd "$REPO_ROOT"

# .gitignore (если нет)
[ -f .gitignore ] || cat > .gitignore <<'EOF'
target/
**/target/
node_modules/
dist/
.DS_Store
*.swp
*.swo
/etc/logos/*.env
*.pem
*.key
*.crt
*.p12
/var/lib/logos/
/var/run/logos_health.json
/usr/local/bin/lrb_bench*
/usr/local/bin/logos_healthcheck.sh
/etc/letsencrypt/
*.log
/var/log/nginx/*.log
www/wallet/*.map
tools/**/go/bin/
EOF

# каталоги в репо
mkdir -p configs/env infra/systemd infra/nginx scripts tools/bench/go www/wallet docs

# wallet → www/wallet
if [ -d /opt/logos/www/wallet ]; then
  rsync -a --delete /opt/logos/www/wallet/ www/wallet/
  echo "[i] wallet synced"
fi

# systemd → infra/systemd
[ -f /etc/systemd/system/logos-node@.service ]       && cp -f /etc/systemd/system/logos-node@.service        infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.service ] && cp -f /etc/systemd/system/logos-healthcheck.service   infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.timer ]   && cp -f /etc/systemd/system/logos-healthcheck.timer     infra/systemd/

# nginx → infra/nginx (example)
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && cp -f /etc/nginx/sites-available/logos-api-lb.conf infra/nginx/logos-api-lb.conf.example

# healthcheck → scripts (если установлен в /usr/local/bin)
if [ -f /usr/local/bin/logos_healthcheck.sh ]; then
  cp -f /usr/local/bin/logos_healthcheck.sh scripts/logos_healthcheck.sh
  chmod +x scripts/logos_healthcheck.sh
fi

# env → *.example (обезличиваем секреты)
mkdir -p configs/env
shopt -s nullglob
for f in /etc/logos/node-*.env; do
  bn="$(basename "$f")"
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    "$f" > "configs/env/${bn}.example"
  echo "[i] env example: configs/env/${bn}.example"
done
# общий пример, если ничего не найдено
if [ -z "$(ls -1 configs/env/*.example 2>/dev/null || true)" ]; then
cat > configs/env/node.env.example <<'EEX'
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_DATA_DIR=/var/lib/logos
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_WALLET_ORIGIN=http://localhost
LRB_RATE_QPS=20
LRB_RATE_BURST=40
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
LRB_ENABLE_FAUCET=0
LRB_ADMIN_IP_ALLOW=127.0.0.1/32,::1/128
EEX
fi

# snapshots (опционально)
if [ "${INCLUDE_SNAPSHOT}" = "1" ]; then
  mkdir -p snapshots
  cp -f /root/logos_snapshot/*.txt snapshots/ 2>/dev/null || true
fi

# git add/commit/push
git add -A
if ! git diff --cached --quiet; then
  git commit -m "sync(live): full system snapshot (code+infra+wallet+scripts), env → *.example"
else
  echo "[i] nothing to commit"
fi

# пуш
git push "${GIT_REMOTE}" "${GIT_BRANCH}"
echo "[✓] pushed to ${GIT_REMOTE}/${GIT_BRANCH}"

```


## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```


## FILE: /root/logos_lrb/src/bin/ai_signal_listener.rs  (size=8704b)
```

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: /root/logos_lrb/src/bin/orchestration_control.rs  (size=6987b)
```
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/rcp_engine.rs  (size=4122b)
```
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: /root/logos_lrb/src/bin/resonance_mesh.rs  (size=8051b)
```
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/resonance_sync.rs  (size=11282b)
```
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/sigma_t.rs  (size=3522b)
```

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: /root/logos_lrb/src/core/biosphere_scanner.rs  (size=5196b)
```
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: /root/logos_lrb/src/core/dao.rs  (size=2106b)
```

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/logos_self.rs  (size=2771b)
```

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/phase.rs  (size=5790b)
```

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/resonance.rs  (size=3016b)
```

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/tx_spam_guard.rs  (size=3175b)
```

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/lib.rs  (size=921b)
```

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: /root/logos_lrb/src/utils/filters.rs  (size=322b)
```

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: /root/logos_lrb/src/utils/frequency.rs  (size=380b)
```

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: /root/logos_lrb/src/utils/math.rs  (size=394b)
```

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: /root/logos_lrb/src/utils/types.rs  (size=215b)
```

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: /root/logos_lrb/tools/batch.json  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```


## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```


## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```


## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```


## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```


## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```


## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```


## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```


## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```


## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```


## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```


## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```


## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```


## FILE: /root/logos_lrb/wallet-proxy/app.py  (size=7115b)
```
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: /root/logos_lrb/wallet-proxy/requirements.txt  (size=1147b)
```
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: /root/logos_lrb/wallet-proxy/scanner.py  (size=5538b)
```
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: /root/logos_lrb/www/wallet/index.html  (size=3122b)
```
<!doctype html>
<html lang="ru" data-theme="auto">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="x-ua-compatible" content="ie=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>LOGOS Wallet (secure MVP)</title>
    <link rel="stylesheet" href="./wallet.css"/>
  </head>
  <body>
    <header class="topbar">
      <div class="brand">LOGOS Wallet</div>
      <div class="spacer"></div>
      <div class="endpoint"><span id="apiBase">—</span></div>
      <button id="themeToggle" class="btn secondary" title="Тёмная/светлая тема">🌓</button>
    </header>

    <main class="container">
      <!-- Ключ -->
      <section class="card">
        <h2>Ключ и адрес</h2>
        <div class="row">
          <button id="gen"  class="btn">Сгенерировать ключ</button>
          <button id="load" class="btn">Загрузить ключ</button>
          <button id="copyRid" class="btn secondary" title="Скопировать RID">📋 RID</button>
        </div>
        <div class="mono mt8">RID: <span id="rid">—</span></div>
      </section>

      <!-- Учётная запись -->
      <section class="card">
        <h2>Учётная запись</h2>
        <div class="row wrap">
          <input id="acctRid" class="input grow" placeholder="RID (base58)"/>
          <button id="getState" class="btn">Получить состояние</button>
          <button id="devFaucet" class="btn warn" title="DEV: начислить тестовые LGN">Faucet (DEV)</button>
        </div>
        <div class="grid2 mt8">
          <div>Баланс: <strong id="balance">0</strong></div>
          <div>Нонс: <strong id="nonce">0</strong></div>
        </div>
      </section>

      <!-- Перевод -->
      <section class="card">
        <h2>Передача</h2>
        <div class="row wrap">
          <input id="toRid" class="input grow" placeholder="В RID (base58)"/>
          <input id="amount" class="input w120" type="number" min="1" placeholder="Сумма"/>
          <button id="send" class="btn">Отправить</button>
        </div>
        <pre id="txOut" class="log mt8" aria-live="polite"></pre>
      </section>

      <!-- История -->
      <section class="card">
        <h2>История</h2>
        <div class="row wrap">
          <input id="histRid" class="input grow" placeholder="RID (если пусто — мой)"/>
          <input id="histFrom" class="input w120" type="number" min="0" placeholder="from nonce"/>
          <input id="histLimit" class="input w100" type="number" min="1" value="20" placeholder="limit"/>
          <button id="loadHist" class="btn">Загрузить</button>
          <button id="moreHist" class="btn secondary">Показать ещё</button>
        </div>
        <div id="histList" class="log mt8" aria-live="polite"></div>
      </section>
    </main>

    <footer class="statusbar" id="statusBar" aria-live="polite">Готово</footer>

    <script src="./wallet.js" type="module"></script>
  </body>
</html>

```


## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```


## FILE: /root/logos_lrb/www/wallet/wallet.js  (size=8649b)
```
// LOGOS Wallet — secure MVP с тёмной темой, статусами и историей с пагинацией
const API = location.origin.replace(/\/$/, "") + "/api";
const $ = (id)=>document.getElementById(id);
let HIST_CURSOR = null;

// ====== Тема (переключатель) ======
(function initTheme(){
  const saved = localStorage.getItem("logos.theme"); // 'light' | 'dark' | 'auto'
  if(saved){ document.documentElement.setAttribute("data-theme", saved); }
  $("themeToggle").onclick = ()=>{
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("logos.theme", next);
  };
})();

// ====== UI helpers ======
const statusBar = $("statusBar");
function status(msg){ statusBar.textContent = msg; }
function busy(btn, v){
  if(!btn) return;
  btn.disabled = v;
}

// endpoint label
(function updateApiBase(){
  $("apiBase").textContent = API;
})();

// ====== b58 ======
const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function b58encode(bytes){ let n=0n; for(const b of bytes) n=(n<<8n)+BigInt(b);
  let s=""; while(n>0n){const r=n%58n; s=ALPH[Number(r)]+s; n/=58n;} let z=0; for(const b of bytes){if(b===0)z++;else break;} return "1".repeat(z)+(s||"1"); }

// ====== IndexedDB ======
const DB="logos_wallet", STORE="keys";
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{const db=r.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);}; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);});}
async function idbPut(k,v){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);});}
async function idbGet(k){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readonly"); const rq=tx.objectStore(STORE).get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error);});}

// ====== Keys ======
async function showRID(vk){ const raw=new Uint8Array(await crypto.subtle.exportKey("raw",vk)); const rid=b58encode(raw); $("rid").textContent=rid; return rid; }
async function generateKey(){ const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]); await idbPut("sk",kp.privateKey); await idbPut("vk",kp.publicKey); await showRID(kp.publicKey); return kp; }
async function loadKey(){ const sk=await idbGet("sk"); const vk=await idbGet("vk"); if(!sk||!vk) throw new Error("Нет ключа: нажмите «Сгенерировать ключ»"); await showRID(vk); return {sk,vk}; }

// ====== API helpers ======
async function apiGET(p){ const r=await fetch(API+p); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`GET ${r.status}`); e.payload=payload; throw e;} return payload; }
async function apiPOST(p,b){ const r=await fetch(API+p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)}); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`POST ${r.status}`); e.payload=payload; throw e;} return payload; }
async function txCanon(tx){ const r=await apiPOST("/debug_canon",{tx}); return r.canon_hex; }
async function signHex(sk,hex){ const bytes=new Uint8Array(hex.match(/../g).map(h=>parseInt(h,16))); const sig=await crypto.subtle.sign({name:"Ed25519"},sk,bytes); return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join(""); }

// ====== State ======
async function refreshState(rid){ const st=await apiGET("/balance/"+encodeURIComponent(rid)); $("balance").textContent=st.balance; $("nonce").textContent=st.nonce; return st; }

// ====== History (with cursor) ======
function renderHistory(items, append=false){
  const box = $("histList");
  if(!append) box.textContent = "";
  if(!items || !items.length){
    if(!append && box.textContent==="") box.textContent="(пусто)";
    return;
  }
  const lines = items.map(it => `#${String(it.nonce).padStart(3," ")}  ${it.from.slice(0,6)}… → ${it.to.slice(0,6)}…   ${it.amount}  (h=${it.height}, ts=${it.ts_ms})`);
  box.textContent = append ? (box.textContent + (box.textContent?"\n":"") + lines.join("\n")) : lines.join("\n");
}

async function loadHistory(append=false){
  try{
    const rid = $("histRid").value.trim() || $("rid").textContent.trim();
    let from = append ? (HIST_CURSOR ?? 0) : ($("histFrom").value.trim() || "0");
    let limit = $("histLimit") ? $("histLimit").value.trim() : "20";
    status(append ? "Догружаю историю…" : "Загружаю историю…");
    busy($("loadHist"), true); busy($("moreHist"), true);
    const r = await apiGET(`/history/${encodeURIComponent(rid)}?from=${from}&limit=${limit}`);
    HIST_CURSOR = r.next_from ?? null;
    renderHistory(r.items || [], append);
    status(HIST_CURSOR ? `Готово. next_from=${HIST_CURSOR}` : "Готово (конец)");
  }catch(e){
    const payload = e.payload ? JSON.stringify(e.payload).slice(0,200) : "";
    $("histList").textContent = "";
    status(`Ошибка истории: ${e.message} ${payload}`);
  } finally {
    busy($("loadHist"), false); busy($("moreHist"), false);
  }
}

// ====== UI wiring ======
$("gen").onclick = async()=>{ try{ busy($("gen"),true); await generateKey(); status("Ключ сгенерирован"); }catch(e){ alert(e.message);} finally{busy($("gen"),false);} };
$("load").onclick = async()=>{ try{ busy($("load"),true); await loadKey(); status("Ключ загружен"); }catch(e){ alert(e.message);} finally{busy($("load"),false);} };
$("copyRid").onclick = async()=>{ try{ const rid=$("rid").textContent.trim(); await navigator.clipboard.writeText(rid); status("RID скопирован"); }catch(e){ alert("Clipboard error"); } };

$("getState").onclick = async()=>{ try{
  busy($("getState"),true);
  const rid = $("acctRid").value.trim() || $("rid").textContent.trim();
  await refreshState(rid); status("Состояние обновлено");
} catch(e){ alert("State error: "+e.message);} finally{busy($("getState"),false);} };

$("devFaucet").onclick = async()=>{ try{
  busy($("devFaucet"),true);
  const {vk}=await loadKey(); const rid=await showRID(vk);
  await apiPOST("/faucet",{rid,amount:1_000_000});
  await refreshState(rid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Faucet OK");
} catch(e){ alert("Faucet error: "+e.message);} finally{busy($("devFaucet"),false);} };

$("send").onclick = async()=>{ try{
  busy($("send"),true);
  const {sk, vk} = await loadKey(); const fromRid=await showRID(vk);
  const to=$("toRid").value.trim(); const amount=parseInt($("amount").value,10);
  if(!to||!amount) throw new Error("RID получателя и сумма обязательны");
  const st=await refreshState(fromRid);
  const tx={from:fromRid,to,amount,nonce:(st.nonce||0)+1};
  const canonHex=await txCanon(tx);
  const sig_hex=await signHex(sk,canonHex);
  const resp=await apiPOST("/submit_tx_batch",{txs:[{...tx,sig_hex}]});
  $("txOut").textContent=JSON.stringify(resp,null,2);
  await refreshState(fromRid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Транзакция отправлена");
} catch(e){
  const m=String(e.message||e);
  if(m.includes("401")) alert("Ошибка подписи (bad_sig). Проверьте ключ/канон.");
  else if(m.includes("409")) alert("Неправильный nonce (bad_nonce). Обновите состояние.");
  else if(m.includes("402")) alert("Недостаточно средств (insufficient_funds).");
  else alert("Send error: "+m);
} finally{ busy($("send"),false); } };

$("loadHist").onclick = ()=>{ HIST_CURSOR=null; $("histFrom").value=$("histFrom").value.trim()||"0"; loadHistory(false); };
$("moreHist").onclick = ()=>{ if(HIST_CURSOR===null){ status("Конец истории"); return; } loadHistory(true); };

// auto-load
loadKey().then(async ({vk})=>{
  const rid=await showRID(vk);
  $("acctRid").value = rid;
  $("histRid").value = rid;
  $("histFrom").value = "0";
  await refreshState(rid);
  await loadHistory(false);
  status("Готово");
}).catch(()=>{ status("Сгенерируйте ключ для начала"); });

```


## FILE: /opt/logos/www/wallet/index.html  (size=3122b)
```
<!doctype html>
<html lang="ru" data-theme="auto">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="x-ua-compatible" content="ie=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>LOGOS Wallet (secure MVP)</title>
    <link rel="stylesheet" href="./wallet.css"/>
  </head>
  <body>
    <header class="topbar">
      <div class="brand">LOGOS Wallet</div>
      <div class="spacer"></div>
      <div class="endpoint"><span id="apiBase">—</span></div>
      <button id="themeToggle" class="btn secondary" title="Тёмная/светлая тема">🌓</button>
    </header>

    <main class="container">
      <!-- Ключ -->
      <section class="card">
        <h2>Ключ и адрес</h2>
        <div class="row">
          <button id="gen"  class="btn">Сгенерировать ключ</button>
          <button id="load" class="btn">Загрузить ключ</button>
          <button id="copyRid" class="btn secondary" title="Скопировать RID">📋 RID</button>
        </div>
        <div class="mono mt8">RID: <span id="rid">—</span></div>
      </section>

      <!-- Учётная запись -->
      <section class="card">
        <h2>Учётная запись</h2>
        <div class="row wrap">
          <input id="acctRid" class="input grow" placeholder="RID (base58)"/>
          <button id="getState" class="btn">Получить состояние</button>
          <button id="devFaucet" class="btn warn" title="DEV: начислить тестовые LGN">Faucet (DEV)</button>
        </div>
        <div class="grid2 mt8">
          <div>Баланс: <strong id="balance">0</strong></div>
          <div>Нонс: <strong id="nonce">0</strong></div>
        </div>
      </section>

      <!-- Перевод -->
      <section class="card">
        <h2>Передача</h2>
        <div class="row wrap">
          <input id="toRid" class="input grow" placeholder="В RID (base58)"/>
          <input id="amount" class="input w120" type="number" min="1" placeholder="Сумма"/>
          <button id="send" class="btn">Отправить</button>
        </div>
        <pre id="txOut" class="log mt8" aria-live="polite"></pre>
      </section>

      <!-- История -->
      <section class="card">
        <h2>История</h2>
        <div class="row wrap">
          <input id="histRid" class="input grow" placeholder="RID (если пусто — мой)"/>
          <input id="histFrom" class="input w120" type="number" min="0" placeholder="from nonce"/>
          <input id="histLimit" class="input w100" type="number" min="1" value="20" placeholder="limit"/>
          <button id="loadHist" class="btn">Загрузить</button>
          <button id="moreHist" class="btn secondary">Показать ещё</button>
        </div>
        <div id="histList" class="log mt8" aria-live="polite"></div>
      </section>
    </main>

    <footer class="statusbar" id="statusBar" aria-live="polite">Готово</footer>

    <script src="./wallet.js" type="module"></script>
  </body>
</html>

```


## FILE: /opt/logos/www/wallet/wallet.js  (size=8649b)
```
// LOGOS Wallet — secure MVP с тёмной темой, статусами и историей с пагинацией
const API = location.origin.replace(/\/$/, "") + "/api";
const $ = (id)=>document.getElementById(id);
let HIST_CURSOR = null;

// ====== Тема (переключатель) ======
(function initTheme(){
  const saved = localStorage.getItem("logos.theme"); // 'light' | 'dark' | 'auto'
  if(saved){ document.documentElement.setAttribute("data-theme", saved); }
  $("themeToggle").onclick = ()=>{
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("logos.theme", next);
  };
})();

// ====== UI helpers ======
const statusBar = $("statusBar");
function status(msg){ statusBar.textContent = msg; }
function busy(btn, v){
  if(!btn) return;
  btn.disabled = v;
}

// endpoint label
(function updateApiBase(){
  $("apiBase").textContent = API;
})();

// ====== b58 ======
const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function b58encode(bytes){ let n=0n; for(const b of bytes) n=(n<<8n)+BigInt(b);
  let s=""; while(n>0n){const r=n%58n; s=ALPH[Number(r)]+s; n/=58n;} let z=0; for(const b of bytes){if(b===0)z++;else break;} return "1".repeat(z)+(s||"1"); }

// ====== IndexedDB ======
const DB="logos_wallet", STORE="keys";
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{const db=r.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);}; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);});}
async function idbPut(k,v){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);});}
async function idbGet(k){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readonly"); const rq=tx.objectStore(STORE).get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error);});}

// ====== Keys ======
async function showRID(vk){ const raw=new Uint8Array(await crypto.subtle.exportKey("raw",vk)); const rid=b58encode(raw); $("rid").textContent=rid; return rid; }
async function generateKey(){ const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]); await idbPut("sk",kp.privateKey); await idbPut("vk",kp.publicKey); await showRID(kp.publicKey); return kp; }
async function loadKey(){ const sk=await idbGet("sk"); const vk=await idbGet("vk"); if(!sk||!vk) throw new Error("Нет ключа: нажмите «Сгенерировать ключ»"); await showRID(vk); return {sk,vk}; }

// ====== API helpers ======
async function apiGET(p){ const r=await fetch(API+p); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`GET ${r.status}`); e.payload=payload; throw e;} return payload; }
async function apiPOST(p,b){ const r=await fetch(API+p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)}); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`POST ${r.status}`); e.payload=payload; throw e;} return payload; }
async function txCanon(tx){ const r=await apiPOST("/debug_canon",{tx}); return r.canon_hex; }
async function signHex(sk,hex){ const bytes=new Uint8Array(hex.match(/../g).map(h=>parseInt(h,16))); const sig=await crypto.subtle.sign({name:"Ed25519"},sk,bytes); return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join(""); }

// ====== State ======
async function refreshState(rid){ const st=await apiGET("/balance/"+encodeURIComponent(rid)); $("balance").textContent=st.balance; $("nonce").textContent=st.nonce; return st; }

// ====== History (with cursor) ======
function renderHistory(items, append=false){
  const box = $("histList");
  if(!append) box.textContent = "";
  if(!items || !items.length){
    if(!append && box.textContent==="") box.textContent="(пусто)";
    return;
  }
  const lines = items.map(it => `#${String(it.nonce).padStart(3," ")}  ${it.from.slice(0,6)}… → ${it.to.slice(0,6)}…   ${it.amount}  (h=${it.height}, ts=${it.ts_ms})`);
  box.textContent = append ? (box.textContent + (box.textContent?"\n":"") + lines.join("\n")) : lines.join("\n");
}

async function loadHistory(append=false){
  try{
    const rid = $("histRid").value.trim() || $("rid").textContent.trim();
    let from = append ? (HIST_CURSOR ?? 0) : ($("histFrom").value.trim() || "0");
    let limit = $("histLimit") ? $("histLimit").value.trim() : "20";
    status(append ? "Догружаю историю…" : "Загружаю историю…");
    busy($("loadHist"), true); busy($("moreHist"), true);
    const r = await apiGET(`/history/${encodeURIComponent(rid)}?from=${from}&limit=${limit}`);
    HIST_CURSOR = r.next_from ?? null;
    renderHistory(r.items || [], append);
    status(HIST_CURSOR ? `Готово. next_from=${HIST_CURSOR}` : "Готово (конец)");
  }catch(e){
    const payload = e.payload ? JSON.stringify(e.payload).slice(0,200) : "";
    $("histList").textContent = "";
    status(`Ошибка истории: ${e.message} ${payload}`);
  } finally {
    busy($("loadHist"), false); busy($("moreHist"), false);
  }
}

// ====== UI wiring ======
$("gen").onclick = async()=>{ try{ busy($("gen"),true); await generateKey(); status("Ключ сгенерирован"); }catch(e){ alert(e.message);} finally{busy($("gen"),false);} };
$("load").onclick = async()=>{ try{ busy($("load"),true); await loadKey(); status("Ключ загружен"); }catch(e){ alert(e.message);} finally{busy($("load"),false);} };
$("copyRid").onclick = async()=>{ try{ const rid=$("rid").textContent.trim(); await navigator.clipboard.writeText(rid); status("RID скопирован"); }catch(e){ alert("Clipboard error"); } };

$("getState").onclick = async()=>{ try{
  busy($("getState"),true);
  const rid = $("acctRid").value.trim() || $("rid").textContent.trim();
  await refreshState(rid); status("Состояние обновлено");
} catch(e){ alert("State error: "+e.message);} finally{busy($("getState"),false);} };

$("devFaucet").onclick = async()=>{ try{
  busy($("devFaucet"),true);
  const {vk}=await loadKey(); const rid=await showRID(vk);
  await apiPOST("/faucet",{rid,amount:1_000_000});
  await refreshState(rid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Faucet OK");
} catch(e){ alert("Faucet error: "+e.message);} finally{busy($("devFaucet"),false);} };

$("send").onclick = async()=>{ try{
  busy($("send"),true);
  const {sk, vk} = await loadKey(); const fromRid=await showRID(vk);
  const to=$("toRid").value.trim(); const amount=parseInt($("amount").value,10);
  if(!to||!amount) throw new Error("RID получателя и сумма обязательны");
  const st=await refreshState(fromRid);
  const tx={from:fromRid,to,amount,nonce:(st.nonce||0)+1};
  const canonHex=await txCanon(tx);
  const sig_hex=await signHex(sk,canonHex);
  const resp=await apiPOST("/submit_tx_batch",{txs:[{...tx,sig_hex}]});
  $("txOut").textContent=JSON.stringify(resp,null,2);
  await refreshState(fromRid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Транзакция отправлена");
} catch(e){
  const m=String(e.message||e);
  if(m.includes("401")) alert("Ошибка подписи (bad_sig). Проверьте ключ/канон.");
  else if(m.includes("409")) alert("Неправильный nonce (bad_nonce). Обновите состояние.");
  else if(m.includes("402")) alert("Недостаточно средств (insufficient_funds).");
  else alert("Send error: "+m);
} finally{ busy($("send"),false); } };

$("loadHist").onclick = ()=>{ HIST_CURSOR=null; $("histFrom").value=$("histFrom").value.trim()||"0"; loadHistory(false); };
$("moreHist").onclick = ()=>{ if(HIST_CURSOR===null){ status("Конец истории"); return; } loadHistory(true); };

// auto-load
loadKey().then(async ({vk})=>{
  const rid=await showRID(vk);
  $("acctRid").value = rid;
  $("histRid").value = rid;
  $("histFrom").value = "0";
  await refreshState(rid);
  await loadHistory(false);
  status("Готово");
}).catch(()=>{ status("Сгенерируйте ключ для начала"); });

```


## FILE: /opt/logos/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```


## FILE: /etc/systemd/system/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```


## FILE: /etc/systemd/system/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```


## FILE: /etc/systemd/system/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```


## FILE: /etc/nginx/sites-available/logos-api-lb.conf  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```


## FILE: /usr/local/bin/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```


## FILE: /etc/logos/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /etc/logos/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /etc/logos/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

```

## FILE: /root/logos_lrb/docs/WORKFLOW.md  (size=5440b)
```
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```

## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=3062b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки ---
    add_header X-Frame-Options        SAMEORIGIN       always;
    add_header X-Content-Type-Options nosniff          always;
    add_header Referrer-Policy        strict-origin-when-cross-origin always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # CSP: только self, без inline/CDN. Разрешаем data: для иконок/картинок в UI.
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
```
# Пример (НЕ БОЕВОЙ! замените на свои)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=   # задаётся опционально

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service  (size=369b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```

## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```

## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```

## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1617b)
```
// Безопасный AEAD: XChaCha20-Poly1305 с уникальным nonce.
// Формат шифротекста: [24-байт nonce || ciphertext+tag]

use anyhow::Result;
use chacha20poly1305::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Key, XChaCha20Poly1305, XNonce,
};

pub struct AeadBox {
    key: Key,
}

impl AeadBox {
    pub fn from_key(key_bytes: &[u8; 32]) -> Self {
        let key = Key::from_slice(key_bytes);
        Self { key: *key }
    }

    pub fn seal(&self, aad: &[u8], plaintext: &[u8]) -> Vec<u8> {
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XChaCha20Poly1305::generate_nonce(&mut OsRng); // 24 байта
        let mut out = Vec::with_capacity(24 + plaintext.len() + 16);
        out.extend_from_slice(&nonce);
        let ct = cipher
            .encrypt(
                &nonce,
                chacha20poly1305::aead::Payload {
                    msg: plaintext,
                    aad,
                },
            )
            .expect("AEAD encrypt failed");
        out.extend_from_slice(&ct);
        out
    }

    pub fn open(&self, aad: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 24 + 16 {
            anyhow::bail!("AEAD: buffer too short");
        }
        let (nonce_bytes, ct) = data.split_at(24);
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XNonce::from_slice(nonce_bytes);
        let pt = cipher
            .decrypt(nonce, chacha20poly1305::aead::Payload { msg: ct, aad })
            .map_err(|_| anyhow::anyhow!("AEAD decrypt failed"))?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=12177b)
```
use crate::types::*;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sled::{Db, IVec, Tree};
use std::convert::TryInto;
use std::path::Path;

// key helpers
fn be64(v: u64) -> [u8; 8] {
    v.to_be_bytes()
}
fn be32(v: u32) -> [u8; 4] {
    v.to_be_bytes()
}
fn rid_str(r: &Rid) -> &str {
    &r.0
}

#[derive(Clone)]
pub struct Ledger {
    #[allow(dead_code)]
    db: Db,

    // balances
    lg_tree: Tree,   // rid -> u64 (BE)
    rlgn_tree: Tree, // rid -> u64 (BE)
    head_tree: Tree, // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree: db.open_tree("lgn")?,
            rlgn_tree: db.open_tree("rlgn")?,
            head_tree: db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree: db.open_tree("txs")?,
            acct_tree: db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self
            .head_tree
            .get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self
            .head_tree
            .get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self
            .head_tree
            .get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(
        &self,
        height: u64,
        hash: &str,
        ts_ms: u128,
        txs: &[Tx],
    ) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx {
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to: rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce: tx.nonce,
                height,
                index: i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1 + txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1 + 8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock {
            height,
            hash: hash.to_string(),
            ts_ms,
            tx_ids: ids,
        };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1 + 8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self
            .blocks_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredBlock>(&v))
            .transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1 + txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self
            .tx_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredTx>(&v))
            .transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(
        &self,
        rid: &str,
        limit: usize,
        cursor: Option<String>,
    ) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a");
            k.extend_from_slice(rid.as_bytes());
            k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage {
            rid: rid.to_string(),
            items,
            next_cursor,
        })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? {
            return Ok(false);
        }
        self.head_tree
            .insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        if cur < amt {
            anyhow::bail!("insufficient rLGN");
        }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k = rid_str(&tx.to).as_bytes();

            let from_bal = self
                .lg_tree
                .get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);
            if from_bal < tx.amount {
                anyhow::bail!("insufficient funds");
            }
            let to_bal = self
                .lg_tree
                .get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k, &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h {
                Ok(BlockHeaderView {
                    block_hash: head_hash,
                })
            } else {
                anyhow::bail!("block not found")
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=727b)
```
/*!
 * LOGOS LRB — core crate
 * Экспорт модулей ядра L1: типы, консенсус, мемпул/баланс, резонанс, сигналы, защита.
 * Здесь только декларация модулей — реализация в соответствующих *.rs файлах.
 */

pub mod types;

pub mod anti_replay;
pub mod beacon;
pub mod heartbeat;

pub mod dynamic_balance;
pub mod spam_guard;

pub mod phase_consensus;
pub mod phase_filters;
pub mod phase_integrity;
pub mod quorum;
pub mod sigpool;

pub mod ledger;
pub mod rcp_engine;
pub mod resonance;

// Безопасный AEAD (XChaCha20-Poly1305) — общий хелпер для модулей
pub mod crypto;

```

## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=1806b)
```
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize {
        self.quorum_n
    }
    pub fn finalized(&self) -> u64 {
        self.finalized_h
    }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes
            .get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_filters.rs  (size=1780b)
```
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN")
        .ok()
        .map(|v| v == "1")
        .unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',')
        .filter_map(|s| s.trim().parse::<f64>().ok())
        .collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE")
        .ok()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() {
        return 1.0;
    }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() {
        return true;
    }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=553b)
```
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig)
        .map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=1250b)
```
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk =
        VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(
        &sig_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("bad sig"))?,
    );

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig)
        .map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=7224b)
```
use crate::sigpool::filter_valid_sigs_parallel;
use crate::{dynamic_balance::DynamicBalance, ledger::Ledger, spam_guard::SpamGuard, types::*};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use anyhow::Result;
use std::{
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{
    broadcast,
    mpsc::{unbounded_channel, UnboundedSender},
};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount = env_u64("LRB_MAX_AMOUNT", u64::MAX / 2);
        let slot_ms = env_u64("LRB_SLOT_MS", 500);
        let quorum_n = env_usize("LRB_QUORUM_N", 1);
        let sig_workers = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> {
        self.ledger.clone()
    }
    pub fn proposer(&self) -> Rid {
        self.proposer.clone()
    }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) {
        *self.commit_tx.lock().unwrap() = Some(sender);
    }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> {
        self.guard.check_amount(amount)
    }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> {
        self.mempool_tx.clone()
    }
    pub fn mempool_len(&self) -> usize {
        self.mempool.lock().unwrap().len()
    }
    pub fn finalized_height(&self) -> u64 {
        self.consensus.lock().unwrap().finalized()
    }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() {
                    continue;
                }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() {
                continue;
            }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() {
                continue;
            }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```

## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```

## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```

## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=3363b)
```
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String, // blake3 of canonical form
    pub from: Rid,  // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>, // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,  // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 {
            return Err(anyhow!("bad pubkey len"));
        }
        if self.signature.len() != 64 {
            return Err(anyhow!("bad signature len"));
        }
        if self.amount == 0 {
            return Err(anyhow!("amount must be > 0"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```

## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
```
use axum::{
    extract::State,
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, time::Duration};
use tower::{ServiceBuilder};
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
    timeout::TimeoutLayer,
    limit::{RequestBodyLimitLayer},
};
use tracing_subscriber::{EnvFilter, fmt};
use ed25519_dalek::{SigningKey, VerifyingKey, SignatureError};
use rand_core::OsRng;
use bs58;
use once_cell::sync::OnceCell;
use anyhow::Result;

mod api;
mod admin;
mod bridge;
mod gossip;
mod state;
mod peers;
mod fork;

#[derive(Clone)]
struct AppState {
    signing: SigningKey,
    verifying: VerifyingKey,
    rid_b58: String,
    admin_key: String,
    bridge_key: String,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(bytes.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(data.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}

fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}

fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!("missing env {}", n))?;
    Ok(v)
}

fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY","CHANGE_ME","", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys + env
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid = rid_from_vk(&vk);

    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid.clone(),
        admin_key,
        bridge_key,
    };
    APP_STATE.set(state.clone()).unwrap();

    // CORS
    let cors = {
        let allowed_origin = std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| String::from("https://wallet.example"));
        CorsLayer::new()
            .allow_origin(allowed_origin.parse::<axum::http::HeaderValue>().unwrap())
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([axum::http::header::CONTENT_TYPE, axum::http::header::AUTHORIZATION])
    };

    // limits/timeout
    let layers = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(RequestBodyLimitLayer::new(512 * 1024)) // 512 KiB
        .layer(cors)
        .into_inner();

    // маршруты
    let app = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet)) // dev-only
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify))
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .with_state(state)
        .layer(layers);

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```

## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=1719b)
```
//! Точка-точка фазовая связка: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseLink {
    aead: AeadBox,
    self_vk: VerifyingKey,
    peer_vk: VerifyingKey,
}

impl PhaseLink {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey, peer_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk, peer_vk }
    }

    pub fn encode(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_link: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_link: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```

## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```

## FILE: /root/logos_lrb/modules/__pycache__/env_impact_tracker.cpython-312.pyc  (size=8808b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/resonance_tutor.cpython-312.pyc  (size=9982b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/symbolic_parser.cpython-312.pyc  (size=6942b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```

## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```

## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```

## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```

## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```

## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/node/src/admin.rs  (size=1627b)
```
//! Админ-ручки: snapshot/restore и node_info.
//! Доступ защищается через заголовок X-Admin-Key = LRB_ADMIN_KEY.

use crate::AppState;
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

fn check_admin(st: &AppState, headers: &axum::http::HeaderMap) -> Result<(), StatusCode> {
    let got = headers
        .get("X-Admin-Key")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    if got == st.admin_key {
        Ok(())
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub height: u64,
    pub finalized: bool,
}

pub async fn node_info(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<NodeInfo>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(NodeInfo {
        rid: st.rid_b58.clone(),
        height: 0,
        finalized: false,
    }))
}

#[derive(Serialize)]
pub struct SnapshotResp {
    pub status: &'static str,
}

pub async fn snapshot(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

#[derive(Deserialize)]
#[allow(dead_code)]
pub struct RestoreReq {
    #[serde(default)]
    pub path: String,
}

pub async fn restore(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(_req): Json<RestoreReq>,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

```

## FILE: /root/logos_lrb/node/src/api.rs  (size=10642b)
```
use axum::{extract::{Path, Query, State}, http::StatusCode, Json};
use hex;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::metrics::{inc_total, Timer};
use crate::storage::TxIn;
use crate::AppState;

use bs58;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use parking_lot::Mutex;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

/* ========= liveness / readiness ========= */
#[derive(Serialize)] pub struct Healthz{ pub status: &'static str }
pub async fn healthz()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn livez()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn readyz(State(_st):State<AppState>)->Result<Json<Healthz>,StatusCode>{
    let t=Timer::new("/readyz","GET"); inc_total("/readyz","GET",StatusCode::OK); t.observe(); Ok(Json(Healthz{status:"ready"}))
}

/* ========= helpers ========= */
#[derive(Serialize,Deserialize,Clone)]
struct CanonTx<'a>{ from:&'a str,to:&'a str,amount:u64,nonce:u64 }
fn canon_bytes(tx:&TxIn)->Result<Vec<u8>,StatusCode>{
    let c=CanonTx{from:&tx.from,to:&tx.to,amount:tx.amount,nonce:tx.nonce};
    serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)
}
fn vk_from_rid(rid:&str)->Result<VerifyingKey,StatusCode>{
    let b=bs58::decode(rid).into_vec().map_err(|_|StatusCode::BAD_REQUEST)?; if b.len()!=32 {return Err(StatusCode::BAD_REQUEST);}
    VerifyingKey::from_bytes(b.as_slice().try_into().unwrap()).map_err(|_|StatusCode::BAD_REQUEST)
}
fn sig_from_hex(h:&str)->Result<Signature,StatusCode>{
    let raw=hex::decode(h).map_err(|_|StatusCode::BAD_REQUEST)?; let arr:[u8;64]=raw.as_slice().try_into().map_err(|_|StatusCode::BAD_REQUEST)?;
    Ok(Signature::from_bytes(&arr))
}

/* ========= head / balance ========= */
#[derive(Serialize)] pub struct HeadResp{ pub height:u64, pub finalized:bool }
pub async fn head(State(st):State<AppState>)->Json<HeadResp>{
    let t=Timer::new("/head","GET"); let h=st.store.get_height().unwrap_or(0); inc_total("/head","GET",StatusCode::OK); t.observe();
    Json(HeadResp{height:h,finalized:false})
}
#[derive(Serialize)] pub struct BalanceResp{ pub rid:String, pub balance:u64, pub nonce:u64 }
pub async fn balance(State(st):State<AppState>,Path(rid):Path<String>)->Json<BalanceResp>{
    let t=Timer::new("/balance/:rid","GET"); let a=st.store.get_account(&rid).unwrap_or_default(); inc_total("/balance/:rid","GET",StatusCode::OK); t.observe();
    Json(BalanceResp{rid, balance:a.balance, nonce:a.nonce})
}

/* ========= history / block ========= */
#[derive(Deserialize)] pub struct HistoryQuery{ #[serde(default)] pub from:u64, #[serde(default="def_limit")] pub limit:usize }
fn def_limit()->usize{20}
#[derive(Serialize)] pub struct HistoryResp{ pub rid:String, pub from:u64, pub limit:usize, pub next_from:Option<u64>, pub items:Vec<crate::storage::HistoryItem> }
pub async fn history(State(st):State<AppState>, Path(rid):Path<String>, Query(q):Query<HistoryQuery>)->Result<Json<HistoryResp>,StatusCode>{
    let t=Timer::new("/history/:rid","GET");
    let (items,next_from)=st.store.history_page(&rid,q.from,q.limit.min(1000)).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/history/:rid","GET",StatusCode::OK); t.observe();
    Ok(Json(HistoryResp{rid,from:q.from,limit:q.limit,next_from,items}))
}
#[derive(Serialize)] pub struct BlockResp{ pub height:u64,pub ts_ms:u64,pub txs:Vec<TxIn> }
pub async fn block(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<BlockResp>,StatusCode>{
    let t=Timer::new("/block/:height","GET"); let br=st.store.get_block(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; let br=br.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height","GET",StatusCode::OK); t.observe(); Ok(Json(BlockResp{height:br.height, ts_ms:br.ts_ms, txs:br.txs}))
}

/* ========= block mix (PhaseMix v1) ========= */
#[derive(Serialize)] pub struct MixResp{ pub height:u64, pub ts_ms:u64, pub deltas:Vec<(String,i128)> }
pub async fn block_mix(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<MixResp>,StatusCode>{
    let t=Timer::new("/block/:height/mix","GET");
    let m = st.store.get_mix(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    let m = m.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height/mix","GET",StatusCode::OK); t.observe();
    Ok(Json(MixResp{height:m.height, ts_ms:m.ts_ms, deltas:m.deltas}))
}

/* ========= submit_tx / batch ========= */
#[derive(Deserialize)] pub struct SubmitTxBatchReq{ #[serde(default)] pub txs:Vec<TxIn> }
#[derive(Serialize)]   pub struct TxResult{ pub idx:usize, pub status:&'static str, pub code:u16, pub reason:&'static str }
#[derive(Serialize)]   pub struct SubmitTxBatchResp{ pub accepted:usize, pub rejected:usize, pub new_height:u64, pub results:Vec<TxResult> }

pub async fn submit_tx_batch(State(st):State<AppState>, Json(req):Json<SubmitTxBatchReq>)
 -> Result<Json<SubmitTxBatchResp>,StatusCode>{
    let t=Timer::new("/submit_tx_batch","POST");
    if req.txs.is_empty(){ inc_total("/submit_tx_batch","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST); }
    let mut by_sender:BTreeMap<String,Vec<(usize,TxIn)>>=BTreeMap::new();
    for (i,tx) in req.txs.into_iter().enumerate(){ by_sender.entry(tx.from.clone()).or_default().push((i,tx)); }
    let mut results=Vec::new(); let mut acc_total=0usize; let mut rej_total=0usize; let mut last_h=st.store.get_height().unwrap_or(0);
    let mut cache:HashMap<String, crate::storage::AccountState>=HashMap::new();
    for (from,mut items) in by_sender.into_iter() {
        items.sort_by_key(|(_,tx)| tx.nonce);
        let lk = st.locks.entry(from.clone()).or_insert_with(||Arc::new(Mutex::new(()))).clone();
        let _g = lk.lock();
        let mut next = st.store.get_account(&from).unwrap_or_default().nonce;
        let mut valid:Vec<TxIn>=Vec::new();
        for (idx,tx) in items.into_iter(){
            let vk = match vk_from_rid(&tx.from){ Ok(v)=>v, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_rid"}); continue; } };
            let sig= match sig_from_hex(&tx.sig_hex){ Ok(s)=>s, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; } };
            let msg= match canon_bytes(&tx){ Ok(m)=>m, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_canon"}); continue; } };
            if vk.verify(&msg,&sig).is_err(){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; }
            if tx.nonce != next.saturating_add(1){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:409,reason:"bad_nonce"}); continue; }
            let fs = cache.get(&tx.from).cloned().unwrap_or_else(|| st.store.get_account(&tx.from).unwrap_or_default());
            let ts = cache.get(&tx.to).cloned().unwrap_or_else(|| st.store.get_account(&tx.to).unwrap_or_default());
            if tx.from != tx.to && fs.balance < tx.amount { rej_total+=1; results.push(TxResult{idx,status:"rejected",code:402,reason:"insufficient_funds"}); continue; }
            // simulate in cache
            let mut nf=fs; let mut nt=ts; next = next.saturating_add(1); nf.nonce = next;
            if tx.from != tx.to { nf.balance = nf.balance.saturating_sub(tx.amount); nt.balance = nt.balance.saturating_add(tx.amount); }
            cache.insert(tx.from.clone(), nf); cache.insert(tx.to.clone(), nt);
            valid.push(tx); acc_total+=1; results.push(TxResult{idx,status:"accepted",code:0,reason:"ok"});
        }
        if !valid.is_empty(){ last_h = st.store.apply_batch(&valid).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; }
    }
    let resp=SubmitTxBatchResp{accepted:acc_total,rejected:rej_total,new_height:last_h,results};
    inc_total("/submit_tx_batch","POST",StatusCode::OK); t.observe(); Ok(Json(resp))
}
#[inline] fn inc_tx_err(){}

/* ========= одиночная submit_tx ========= */
#[derive(Deserialize)] pub struct SubmitTxReq{ #[serde(default)] pub _payload:serde_json::Value }
#[derive(Serialize)]   pub struct SubmitTxResp{ pub status:&'static str }
pub async fn submit_tx(State(_st):State<AppState>, Json(_req):Json<SubmitTxReq>) -> Result<Json<SubmitTxResp>,StatusCode>{
    let t=Timer::new("/submit_tx","POST"); inc_total("/submit_tx","POST",StatusCode::OK); t.observe(); Ok(Json(SubmitTxResp{status:"accepted"}))
}

/* ========= debug_canon ========= */
#[derive(Deserialize)] pub struct DebugCanonReq{ #[serde(default)] pub tx:serde_json::Value }
#[derive(Serialize)]   pub struct DebugCanonResp{ pub canon_hex:String }
pub async fn debug_canon(Json(req):Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>,StatusCode>{
    let t=Timer::new("/debug_canon","POST");
    let from=req.tx.get("from").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let to  =req.tx.get("to").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let amount=req.tx.get("amount").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let nonce =req.tx.get("nonce").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let c=CanonTx{from,to,amount,nonce}; let bytes=serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)?;
    let canon_hex=hex::encode(bytes);
    inc_total("/debug_canon","POST",StatusCode::OK); t.observe(); Ok(Json(DebugCanonResp{canon_hex}))
}

/* ========= faucet (DEV) ========= */
#[derive(Deserialize)] pub struct FaucetReq{ #[serde(default)] pub rid:String, #[serde(default)] pub amount:u64 }
#[derive(Serialize)]   pub struct FaucetResp{ pub granted:u64, pub rid:String }
pub async fn faucet(State(st):State<AppState>, Json(req):Json<FaucetReq>) -> Result<Json<FaucetResp>,StatusCode>{
    if std::env::var("LRB_ENABLE_FAUCET").ok().as_deref()!=Some("1"){ return Err(StatusCode::FORBIDDEN); }
    let t=Timer::new("/faucet","POST");
    if req.rid.is_empty() || req.amount==0 { inc_total("/faucet","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST);}
    let _st = st.store.faucet(&req.rid, req.amount).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/faucet","POST",StatusCode::OK); t.observe(); Ok(Json(FaucetResp{granted:req.amount, rid:req.rid}))
}

/* ========= economy ========= */
#[derive(Serialize)] pub struct EconomyResp{ pub cap:u64, pub minted:u64, pub burned:u64, pub supply:u64 }
pub async fn economy(State(st):State<AppState>) -> Result<Json<EconomyResp>,StatusCode>{
    let snap = st.store.economy_snapshot().map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(EconomyResp{cap:snap.cap, minted:snap.minted, burned:snap.burned, supply:snap.supply}))
}

```

## FILE: /root/logos_lrb/node/src/auth.rs  (size=5131b)
```
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```

## FILE: /root/logos_lrb/node/src/bin/aead_selftest.rs  (size=1723b)
```
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use lrb_core::crypto::AeadBox;
use rand_core::{OsRng, RngCore};

fn main() {
    // 1) Ed25519: ключи + подпись/проверка
    let sk = SigningKey::generate(&mut OsRng);
    let vk = VerifyingKey::from(&sk);
    let msg = b"resonance-test-message";
    let sig = sk.sign(msg);
    assert!(vk.verify_strict(msg, &sig).is_ok(), "ed25519 verify failed");

    // 2) AEAD: XChaCha20-Poly1305, уникальный nonce внутри AeadBox
    let mut key32 = [0u8; 32];
    OsRng.fill_bytes(&mut key32);
    let aead = AeadBox::from_key(&key32);

    let aad = b"topic:external-phase|self-vk";
    let pt = "hello, Σ(t)!".as_bytes();

    let ct = aead.seal(aad, pt);
    let dec = aead.open(aad, &ct).expect("aead open failed");
    assert_eq!(dec.as_slice(), pt, "aead roundtrip mismatch");

    // 3) Негатив: порча шифротекста → ошибка
    let mut ct_bad = ct.clone();
    if let Some(last) = ct_bad.last_mut() {
        *last ^= 0xFF; // безопасно мутируем последний байт без двух заимствований
    }
    assert!(aead.open(aad, &ct_bad).is_err(), "aead must fail on tamper");

    // 4) Негатив: смена AAD → ошибка
    let aad_bad = b"topic:changed";
    assert!(
        aead.open(aad_bad, &ct).is_err(),
        "aead must fail on wrong AAD"
    );

    // 5) Подпись поверх шифротекста (seal-then-sign)
    let sig_ct = sk.sign(&ct);
    assert!(
        vk.verify_strict(&ct, &sig_ct).is_ok(),
        "sign(sealed) verify failed"
    );

    println!("OK: ed25519 + AeadBox(XChaCha20-Poly1305) self-test passed");
}

```

## FILE: /root/logos_lrb/node/src/bridge.rs  (size=4870b)
```
//! Bridge: rToken deposit/redeem/verify — prod-ready (single-node, idempotent).
//! Требует корректного X-Bridge-Key (см. LRB_BRIDGE_KEY).
//! Идемпотентность по внешнему ключу квитанции/билета через ledger.bridge_seen_mark().

use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

use crate::{AppState, auth::require_bridge};
use lrb_core::types::Rid;

#[derive(Deserialize)]
pub struct DepositReq {
    /// RID получателя в LOGOS (base58 от pubkey)
    pub rid: String,
    /// Сумма в rLGN
    pub amount: u64,
    /// Внешний уникальный id транзакции/квитанции (например, txid из ETH)
    pub ext_txid: String,
}

#[derive(Serialize)]
pub struct DepositResp {
    pub status: &'static str,
    pub rid: String,
    pub credited: u64,
    pub ext_txid: String,
}

pub async fn deposit(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<DepositReq>,
) -> Result<Json<DepositResp>, StatusCode> {
    require_bridge(&headers)?;

    if req.amount == 0 || req.rid.trim().is_empty() || req.ext_txid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Идемпотентность внешней транзакции
    let rk = format!("deposit:{}", req.ext_txid.trim());
    if !st.ledger.bridge_seen_mark(&rk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(DepositResp {
            status: "ok_repeat",
            rid: req.rid,
            credited: req.amount,
            ext_txid: req.ext_txid,
        }));
    }

    // Минтим rLGN
    let rid = Rid(req.rid.clone());
    st.ledger.mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(DepositResp {
        status: "ok",
        rid: req.rid,
        credited: req.amount,
        ext_txid: req.ext_txid,
    }))
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub rid: String,
    pub amount: u64,
    /// Целевая цепь (например, "ETH")
    #[serde(default)]
    pub target_chain: String,
    /// Адрес в целевой цепи
    #[serde(default)]
    pub target_address: String,
}

#[derive(Serialize)]
pub struct RedeemResp {
    pub status: &'static str,
    pub rid: String,
    pub debited: u64,
    /// Билет на вывод во внешней сети (используется оффчейн-исполнителем)
    pub redeem_ticket: String,
    pub target_chain: String,
    pub target_address: String,
}

pub async fn redeem(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<RedeemReq>,
) -> Result<Json<RedeemResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.amount == 0 || req.rid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Детерминированный билет — для идемпотентности и трекинга
    let redeem_ticket = format!(
        "redeem:{}:{}:{}:{}",
        req.rid.trim(),
        req.amount,
        req.target_chain.trim(),
        req.target_address.trim()
    );

    // Если билет уже «виден» — повтор
    if !st.ledger.bridge_seen_mark(&redeem_ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(RedeemResp {
            status: "ok_repeat",
            rid: req.rid,
            debited: req.amount,
            redeem_ticket,
            target_chain: req.target_chain,
            target_address: req.target_address,
        }));
    }

    // Сжигаем rLGN под вывод (если баланса не хватит — вернётся 400)
    let rid = Rid(req.rid.clone());
    st.ledger.burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;

    Ok(Json(RedeemResp {
        status: "ok",
        rid: req.rid,
        debited: req.amount,
        redeem_ticket,
        target_chain: req.target_chain,
        target_address: req.target_address,
    }))
}

#[derive(Deserialize)]
pub struct VerifyReq {
    pub ticket: String,
}

#[derive(Serialize)]
pub struct VerifyResp {
    pub status: &'static str,
    pub ok: bool,
    pub ticket: String,
}

pub async fn verify(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<VerifyReq>,
) -> Result<Json<VerifyResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.ticket.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Первая попытка помечает — ok:false; повтор — ok:true
    let existed = !st.ledger.bridge_seen_mark(&req.ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(VerifyResp { status: "ok", ok: existed, ticket: req.ticket }))
}

```

## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```

## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```

## FILE: /root/logos_lrb/node/src/guard.rs  (size=4933b)
```
//! Guard & Rate-Limit (prod) для Axum 0.7:
//! - Admin IP ACL (CIDR allowlist) через from_fn_with_state.
//! - Per-IP rate-limit (token bucket) с bypass по путям и по CIDR.
//! - PATH_BYPASS: /healthz, /livez, /readyz, /metrics, /openapi.json.

use axum::response::IntoResponse;  // ← ДОБАВИТЬ ЭТУ СТРОКУ
use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use dashmap::DashMap;
use ipnet::IpNet;
use parking_lot::Mutex;
use std::{
    net::{IpAddr, SocketAddr},
    str::FromStr,
    sync::Arc,
};
use tokio::time::Instant;

/// Пути, которые никогда не ограничиваются лимитером.
const PATH_BYPASS: &[&str] = &[
    "/healthz",
    "/livez",
    "/readyz",
    "/metrics",
    "/openapi.json",
];

/// ===== Admin IP ACL (используем from_fn_with_state) =====
pub async fn admin_ip_gate(
    State(allow): State<Arc<Vec<IpNet>>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    let Some(ip) = client_ip(&req) else {
        return StatusCode::FORBIDDEN.into_response();
    };
    if ip_in_allowlist(ip, &allow) {
        next.run(req).await
    } else {
        StatusCode::FORBIDDEN.into_response()
    }
}

/// ===== Rate Limiter (token bucket per IP) =====
pub struct RateLimiter {
    qps: f64,
    burst: f64,
    /// подсети, которым разрешён обход лимитера
    pub bypass: Arc<Vec<IpNet>>,
    buckets: DashMap<IpAddr, Mutex<TokenBucket>>,
}

struct TokenBucket {
    tokens: f64,
    last: Instant,
}

impl RateLimiter {
    pub fn new(qps: u64, burst: u64, bypass: Arc<Vec<IpNet>>) -> Self {
        let qps = qps as f64;
        let burst = if burst > 0 { burst as f64 } else { qps.max(1.0) * 2.0 };
        Self {
            qps,
            burst,
            bypass,
            buckets: DashMap::new(),
        }
    }

    /// true если IP клиента входит в bypass CIDR
    fn is_bypass(&self, req: &Request<Body>) -> bool {
        if let Some(ip) = client_ip(req) {
            return ip_in_allowlist(ip, &self.bypass);
        }
        false
    }

    /// Проверка и списание токена. false → 429.
    fn check(&self, req: &Request<Body>) -> bool {
        if self.qps <= 0.0 {
            return true;
        }
        let Some(ip) = client_ip(req) else { return false; };

        let entry = self
            .buckets
            .entry(ip)
            .or_insert_with(|| Mutex::new(TokenBucket { tokens: self.burst, last: Instant::now() }));
        let mut tb = entry.lock();

        // refill
        let now = Instant::now();
        let elapsed = now.saturating_duration_since(tb.last).as_secs_f64();
        if elapsed > 0.0 {
            tb.tokens = (tb.tokens + self.qps * elapsed).min(self.burst);
            tb.last = now;
        }

        if tb.tokens >= 1.0 {
            tb.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

/// Axum 0.7 middleware: rate-limit с bypass по путям и CIDR (from_fn_with_state).
pub async fn rate_limit_ip_gate(
    State(limiter): State<Arc<RateLimiter>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    // 1) Allowlist путей
    let path = req.uri().path();
    if PATH_BYPASS.iter().any(|p| *p == path) {
        return next.run(req).await;
    }

    // 2) CIDR bypass (напр., 127.0.0.1/32,::1/128)
    if limiter.is_bypass(&req) {
        return next.run(req).await;
    }

    // 3) Rate-limit
    if limiter.check(&req) {
        next.run(req).await
    } else {
        StatusCode::TOO_MANY_REQUESTS.into_response()
    }
}

/// ===== Утилиты IP/ACL =====

/// Разбор CSV-списка подсетей в Vec<IpNet>.
/// Пример: "127.0.0.1/32,::1/128,10.0.0.0/8"
pub fn parse_ip_allowlist(csv: &str) -> Vec<IpNet> {
    csv.split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .filter_map(|s| IpNet::from_str(s).ok())
        .collect()
}

/// Проверка, входит ли ip в allowlist.
pub fn ip_in_allowlist(ip: IpAddr, allow: &[IpNet]) -> bool {
    allow.iter().any(|net| net.contains(&ip))
}

/// IP клиента из X-Forwarded-For или ConnectInfo<SocketAddr>.
fn client_ip(req: &Request<Body>) -> Option<IpAddr> {
    // a) X-Forwarded-For: берём первый адрес
    if let Some(h) = req.headers().get("x-forwarded-for") {
        if let Ok(s) = h.to_str() {
            if let Some(first) = s.split(',').next() {
                if let Ok(ip) = first.trim().parse::<IpAddr>() {
                    return Some(ip);
                }
            }
        }
    }
    // b) ConnectInfo<SocketAddr> (Axum 0.7)
    if let Some(ci) = req.extensions().get::<axum::extract::ConnectInfo<SocketAddr>>() {
        return Some(ci.0.ip());
    }
    None
}

```

## FILE: /root/logos_lrb/node/src/JSON  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/LE  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/main.rs  (size=6999b)
```
use anyhow::Result;
use axum::{
    middleware::{from_fn_with_state},
    routing::{get, post},
    Router,
};
use bs58;
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::OnceCell;
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tower_http::{
    cors::CorsLayer, limit::RequestBodyLimitLayer, timeout::TimeoutLayer, trace::TraceLayer,
};
use tracing_subscriber::{fmt, EnvFilter};

use lrb_core::ledger::Ledger;
use lrb_core::rcp_engine::engine_with_channels;
use lrb_core::types::Rid;

mod admin;
mod api;
mod auth;
mod bridge;
mod fork;
mod guard;
mod metrics;
mod openapi;
mod peers;
mod state;
mod storage;
mod version;

use dashmap::DashMap;
use parking_lot::Mutex;

#[derive(Clone)]
pub struct AppState {
    pub signing: SigningKey,
    pub verifying: VerifyingKey,
    pub rid_b58: String,
    pub admin_key: String,
    pub bridge_key: String,
    pub ledger: Ledger,
    pub store: Arc<storage::Storage>,
    pub locks: Arc<DashMap<String, Arc<Mutex<()>>>>,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(
            bytes.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(
            data.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}
fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}
fn read_env_required(n: &str) -> Result<String> {
    Ok(std::env::var(n).map_err(|_| anyhow::anyhow!(format!("missing env {}", n)))?)
}
fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY", "CHANGE_ME", "", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys/ids
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid_b58 = rid_from_vk(&vk);
    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    // state
    let data_dir = std::env::var("LRB_DATA_DIR").unwrap_or_else(|_| "/var/lib/logos".into());
    std::fs::create_dir_all(&data_dir).ok();
    let ledger = Ledger::open(&data_dir)?;
    let store = Arc::new(storage::Storage::open(format!("{}/node_state", data_dir))?);

    let app_state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid_b58.clone(),
        admin_key,
        bridge_key,
        ledger: ledger.clone(),
        store,
        locks: Arc::new(DashMap::new()),
    };
    APP_STATE.set(app_state.clone()).ok();

    // engine
    let rid = Rid(rid_b58.clone());
    let _engine = engine_with_channels(ledger, rid);

    // CORS
    let allowed_origin =
        std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| "http://localhost".into());
    let cors = {
        let hv = allowed_origin
            .parse::<axum::http::HeaderValue>()
            .expect("bad LRB_WALLET_ORIGIN");
        CorsLayer::new()
            .allow_origin(hv)
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([
                axum::http::header::CONTENT_TYPE,
                axum::http::header::AUTHORIZATION,
            ])
    };

    // Rate-limit (env)
    let qps: u64 = std::env::var("LRB_RATE_QPS").ok().and_then(|s| s.parse().ok()).unwrap_or(20);
    let burst: u64 = std::env::var("LRB_RATE_BURST").ok().and_then(|s| s.parse().ok()).unwrap_or(40);
    let rl_enabled = qps > 0 && burst > 0;
    let bypass_cidr = std::env::var("LRB_RATE_BYPASS_CIDR")
        .unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let bypass = Arc::new(guard::parse_ip_allowlist(&bypass_cidr));
    let rl = Arc::new(guard::RateLimiter::new(qps, burst, bypass.clone()));

    // Admin IP ACL
    let admin_allow =
        std::env::var("LRB_ADMIN_IP_ALLOW").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let admin_nets = Arc::new(guard::parse_ip_allowlist(&admin_allow));

    // Public routes
    let public = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/livez", get(api::livez))
        .route("/readyz", get(api::readyz))
        .route("/version", get(version::version))
        .route("/openapi.json", get(openapi::spec))
        .route("/metrics", get(metrics::metrics_handler))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/history/:rid", get(api::history))
        .route("/block/:height", get(api::block))
        .route("/block/:height/mix", get(api::block_mix))
        .route("/economy", get(api::economy))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet));

    // Admin routes
    let admin_routes = Router::new()
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .layer(from_fn_with_state(admin_nets.clone(), guard::admin_ip_gate));

    // Bridge routes
    let bridge_routes = Router::new()
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify));

    // Build app
    let mut app = public
        .merge(admin_routes)
        .merge(bridge_routes)
        .with_state(app_state)
        .layer(cors)
        .layer(RequestBodyLimitLayer::new(512 * 1024))
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(TraceLayer::new_for_http());

    if rl_enabled {
        app = app.layer(from_fn_with_state(rl.clone(), guard::rate_limit_ip_gate));
    }

    // Start Axum 0.7
    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(addr).await?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid_b58);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/metrics.rs  (size=2923b)
```
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use prometheus::{
    histogram_opts, opts, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_gauge_with_registry, Encoder,
    HistogramVec, IntCounterVec, IntGauge, Registry, TextEncoder,
};
use std::time::Instant;

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static HTTP_REQ_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("http_requests_total", "Total HTTP requests"),
        &["endpoint", "method", "status"],
        &REGISTRY
    )
    .unwrap()
});
pub static HTTP_REQ_DUR: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec_with_registry!(
        histogram_opts!("http_request_duration_seconds", "HTTP duration").buckets(vec![
            0.001, 0.002, 0.005, 0.010, 0.020, 0.050, 0.100, 0.200, 0.500, 1.0, 2.0, 5.0
        ]),
        &["endpoint", "method"],
        &REGISTRY
    )
    .unwrap()
});
pub static INFLIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge_with_registry!(opts!("http_inflight_requests", "In-flight"), &REGISTRY)
        .unwrap()
});

// New app metrics
pub static HIST_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_history_requests_total", "History requests"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});
pub static BLOCKS_SERVED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_blocks_served_total", "Blocks served"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});

pub struct Timer {
    start: Instant,
    endpoint: &'static str,
    method: &'static str,
}
impl Timer {
    pub fn new(endpoint: &'static str, method: &'static str) -> Self {
        INFLIGHT.inc();
        Self {
            start: Instant::now(),
            endpoint,
            method,
        }
    }
    pub fn observe(self) {
        let dt = self.start.elapsed().as_secs_f64();
        HTTP_REQ_DUR
            .with_label_values(&[self.endpoint, self.method])
            .observe(dt);
        INFLIGHT.dec();
    }
}
pub fn inc_total(endpoint: &'static str, method: &'static str, status: StatusCode) {
    HTTP_REQ_TOTAL
        .with_label_values(&[endpoint, method, status.as_str()])
        .inc();
}
pub async fn metrics_handler() -> Response {
    let mf = REGISTRY.gather();
    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();
    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        [("Content-Type", enc.format_type().to_string())],
        buf,
    )
        .into_response()
}

```

## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi.rs  (size=341b)
```
use axum::{response::IntoResponse, http::StatusCode};

pub async fn spec() -> impl IntoResponse {
    // Компилируем JSON внутрь бинаря — стабильность и скорость
    const SPEC: &str = include_str!("../openapi/openapi.json");
    (StatusCode::OK, [("Content-Type", "application/json")], SPEC)
}

```

## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```

## FILE: /root/logos_lrb/node/src/state.rs  (size=211b)
```
//! Reserved for future network helpers (kept minimal to avoid dead_code warnings).
//! Прод-уровень: пустой модуль без неиспользуемых структур и функций.

```

## FILE: /root/logos_lrb/node/src/storage.rs  (size=12406b)
```
//! Узловое persistent-хранилище (sled, один Tree "kv"):
//!   accounts/<RID>                  -> JSON {balance, nonce}
//!   chain/height                    -> LE u64
//!   blocks/<height:016x>            -> JSON BlockRecord {height, ts_ms, txs}
//!   history/<RID>/<nonce:016x>      -> JSON HistoryItem {nonce, from, to, amount, height, ts_ms}
//!   economy/minted                  -> LE u64
//!   economy/burned                  -> LE u64
//!   mix/<height:016x>               -> JSON MixRecord {height, ts_ms, deltas: [(rid, i128)]}
//!
//! Комиссии v2: LRB_FEE_PER_TX (u64, по умолчанию 0) списываются с отправителя, суммируются и сжигаются.
//! PhaseMix v1: если LRB_PHASEMIX_ENABLE=1 — формируем агрегат Δ по RID и сохраняем в mix/<height>.
//!              По умолчанию fee в Δ не учитывается (LRB_PHASEMIX_INCLUDE_FEE=0).

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub nonce: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub height: u64,
    pub ts_ms: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct MixRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub deltas: Vec<(String, i128)>, // RID -> delta (i128 для симметрии)
}

pub struct Storage {
    db: sled::Db,
    kv: sled::Tree,
}

impl Storage {
    pub fn open<P: AsRef<std::path::Path>>(path: P) -> Result<Self> {
        std::fs::create_dir_all(&path).ok();
        let db = sled::open(path)?;
        let kv = db.open_tree("kv")?;
        let _ = kv.compare_and_swap(b"chain/height", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/minted", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/burned", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        Ok(Self { db, kv })
    }

    #[inline] fn k_account(rid: &str) -> String { format!("accounts/{}", rid) }
    #[inline] fn k_block(height: u64) -> String { format!("blocks/{:016x}", height) }
    #[inline] fn k_hist(rid: &str, nonce: u64) -> String { format!("history/{}/{:016x}", rid, nonce) }
    #[inline] fn k_mix(height: u64) -> String { format!("mix/{:016x}", height) }

    #[inline] fn now_ms() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis() as u64
    }

    // ======== Economy helpers ========
    fn read_u64(&self, key: &[u8]) -> Result<u64> {
        if let Some(v) = self.kv.get(key)? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }
    fn write_u64(&self, key: &[u8], val: u64) -> Result<()> { self.kv.insert(key, val.to_le_bytes().to_vec())?; Ok(()) }

    fn cap_env() -> u64 { std::env::var("LRB_SUPPLY_CAP").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(81_000_000) }
    fn fee_env() -> u64 { std::env::var("LRB_FEE_PER_TX").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(0) }
    fn phasemix_enabled() -> bool { std::env::var("LRB_PHASEMIX_ENABLE").ok().as_deref() == Some("1") }
    fn phasemix_include_fee() -> bool { std::env::var("LRB_PHASEMIX_INCLUDE_FEE").ok().as_deref() == Some("1") }

    pub fn economy_snapshot(&self) -> Result<EconomySnapshot> {
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let cap = Self::cap_env();
        let supply = minted.saturating_sub(burned);
        Ok(EconomySnapshot { cap, minted, burned, supply })
    }

    pub fn try_mint_under_cap(&self, amt: u64) -> Result<u64> {
        let cap = Self::cap_env();
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let supply = minted.saturating_sub(burned);
        let new_supply = supply.checked_add(amt).ok_or_else(|| anyhow!("supply overflow"))?;
        if new_supply > cap { return Err(anyhow!("supply cap exceeded: new_supply={} cap={}", new_supply, cap)); }
        let new_minted = minted.checked_add(amt).ok_or_else(|| anyhow!("minted overflow"))?;
        self.write_u64(b"economy/minted", new_minted)?;
        self.db.flush()?; Ok(new_minted)
    }

    pub fn inc_burned(&self, amt: u64) -> Result<u64> {
        if amt == 0 { return Ok(self.read_u64(b"economy/burned")?); }
        let burned = self.read_u64(b"economy/burned")?;
        let new_burn = burned.checked_add(amt).ok_or_else(|| anyhow!("burn overflow"))?;
        self.write_u64(b"economy/burned", new_burn)?;
        self.db.flush()?; Ok(new_burn)
    }

    // ======== Accounts / Faucet / Blocks / History / Mix ========
    pub fn get_account(&self, rid: &str) -> Result<AccountState> {
        if let Some(v) = self.kv.get(Self::k_account(rid).as_bytes())? {
            let st: AccountState = serde_json::from_slice(&v)?; Ok(st)
        } else { Ok(AccountState::default()) }
    }

    pub fn faucet(&self, rid: &str, amount: u64) -> Result<AccountState> {
        if amount == 0 { return Err(anyhow!("amount must be > 0")); }
        let _ = self.try_mint_under_cap(amount)?;
        let mut st = self.get_account(rid)?; st.balance = st.balance.saturating_add(amount);
        self.kv.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(&st)?)?;
        self.db.flush()?; Ok(st)
    }

    /// Применяем batch: учитываем комиссию, записываем блок/историю, формируем Mix (Δ по RID).
    pub fn apply_batch(&self, txs: &[TxIn]) -> Result<u64> {
        let fee = Self::fee_env();
        let include_fee_in_delta = Self::phasemix_include_fee();
        let mut total_fee: u64 = 0;

        let mut batch = sled::Batch::default();
        let mut acc_cache: HashMap<String, AccountState> = HashMap::new();
        let mut deltas: HashMap<String, i128> = HashMap::new(); // RID -> Δ

        for tx in txs {
            if tx.from == tx.to {
                // само-трансфер: только nonce (+ fee если задана)
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                // комиссию списываем
                if fee > 0 {
                    if from.balance < fee { continue; }
                    from.balance = from.balance.saturating_sub(fee);
                    total_fee = total_fee.saturating_add(fee);
                    if include_fee_in_delta { *deltas.entry(tx.from.clone()).or_default() -= fee as i128; }
                }
                from.nonce = from.nonce.saturating_add(1);
                acc_cache.insert(tx.from.clone(), from);
            } else {
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                let mut to   = acc_cache.remove(&tx.to).unwrap_or(self.get_account(&tx.to).unwrap_or_default());
                let need = tx.amount.saturating_add(fee);
                if from.balance >= need {
                    from.balance = from.balance.saturating_sub(need);
                    to.balance   = to.balance.saturating_add(tx.amount);
                    from.nonce   = from.nonce.saturating_add(1);
                    // Δ (без fee по умолчанию)
                    *deltas.entry(tx.from.clone()).or_default() -= tx.amount as i128;
                    *deltas.entry(tx.to.clone()).or_default()   += tx.amount as i128;
                    if fee > 0 {
                        total_fee = total_fee.saturating_add(fee);
                        if include_fee_in_delta {
                            *deltas.entry(tx.from.clone()).or_default() -= fee as i128;
                        }
                    }
                } else {
                    // недостаточно средств — пропускаем tx
                    continue;
                }
                acc_cache.insert(tx.from.clone(), from);
                acc_cache.insert(tx.to.clone(),   to);
            }
        }

        for (rid, st) in acc_cache.iter() {
            batch.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(st)?);
        }

        let cur_h = self.get_height()?;
        let new_h = cur_h + 1;
        let ts_ms = Self::now_ms();

        let block = BlockRecord { height: new_h, ts_ms, txs: txs.to_vec() };
        batch.insert(b"chain/height", new_h.to_le_bytes().to_vec());
        batch.insert(Self::k_block(new_h).as_bytes(), serde_json::to_vec(&block)?);

        for tx in txs {
            let item = HistoryItem { nonce: tx.nonce, from: tx.from.clone(), to: tx.to.clone(), amount: tx.amount, height: new_h, ts_ms };
            batch.insert(Self::k_hist(&tx.from, tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
            batch.insert(Self::k_hist(&tx.to,   tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
        }

        // Сохраняем MixRecord, если включён PhaseMix
        if Self::phasemix_enabled() {
            let mut vec: Vec<(String,i128)> = deltas.into_iter().collect();
            // отбрасываем нулевые Δ и сортируем для стабильности
            vec.retain(|(_,d)| *d != 0);
            vec.sort_by(|a,b| a.0.cmp(&b.0));
            let mix = MixRecord { height: new_h, ts_ms, deltas: vec };
            batch.insert(Self::k_mix(new_h).as_bytes(), serde_json::to_vec(&mix)?);
        }

        self.kv.apply_batch(batch)?;
        self.db.flush()?;

        if total_fee > 0 { let _ = self.inc_burned(total_fee)?; }

        Ok(new_h)
    }

    pub fn get_height(&self) -> Result<u64> {
        if let Some(v) = self.kv.get(b"chain/height")? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }

    pub fn get_block(&self, height: u64) -> Result<Option<BlockRecord>> {
        Ok(self.kv.get(Self::k_block(height).as_bytes())?.map(|v| serde_json::from_slice::<BlockRecord>(&v)).transpose()?)
    }

    pub fn get_mix(&self, height: u64) -> Result<Option<MixRecord>> {
        Ok(self.kv.get(Self::k_mix(height).as_bytes())?.map(|v| serde_json::from_slice::<MixRecord>(&v)).transpose()?)
    }

    pub fn history_page(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<(Vec<HistoryItem>, Option<u64>)> {
        let prefix = format!("history/{}/", rid);
        let start  = format!("{}{:016x}", prefix, from_nonce);
        let mut out = Vec::with_capacity(limit.min(1024));
        let mut last_nonce: Option<u64> = None;
        let mut iter = self.kv.range(start.as_bytes()..);
        while let Some(kv) = iter.next() {
            let (k, v) = kv?; if !k.starts_with(prefix.as_bytes()) { break; }
            let item: HistoryItem = serde_json::from_slice(&v)?; out.push(item.clone());
            last_nonce = Some(item.nonce); if out.len() >= limit { break; }
        }
        let next_from = if let Some(n) = last_nonce {
            let next_key = format!("{}{:016x}", prefix, n.saturating_add(1));
            if let Some(kv) = self.kv.range(next_key.as_bytes()..).next() {
                let (k, _) = kv?; if k.starts_with(prefix.as_bytes()) { Some(n.saturating_add(1)) } else { None }
            } else { None }
        } else { None };
        Ok((out, next_from))
    }

    pub fn history_from(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<Vec<HistoryItem>> {
        Ok(self.history_page(rid, from_nonce, limit)?.0)
    }
}

#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    #[serde(default)]
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,
}

#[derive(Serialize)]
pub struct EconomySnapshot {
    pub cap: u64,
    pub minted: u64,
    pub burned: u64,
    pub supply: u64,
}

```

## FILE: /root/logos_lrb/node/src/version.rs  (size=520b)
```
use axum::Json;
use serde::Serialize;

#[derive(Serialize)]
pub struct VersionInfo {
    pub name: &'static str,
    pub version: &'static str,
    pub git_commit: &'static str,
    pub build_time_utc: &'static str,
    pub rustc: &'static str,
}

pub async fn version() -> Json<VersionInfo> {
    Json(VersionInfo {
        name: "logos_node",
        version: env!("CARGO_PKG_VERSION"),
        git_commit: env!("GIT_COMMIT"),
        build_time_utc: env!("BUILD_TIME_UTC"),
        rustc: env!("RUSTC_VER"),
    })
}

```

## FILE: /root/logos_lrb/README.md  (size=841b)
```
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```

## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
```
#!/usr/bin/env bash
set -euo pipefail
DOMAIN="${DOMAIN:-example.com}"
INSTANCE="${INSTANCE:-a}"

sudo apt-get update -y
sudo apt-get install -y git curl jq build-essential pkg-config libssl-dev nginx

/usr/bin/id logos >/dev/null 2>&1 || sudo useradd -r -m -d /var/lib/logos -s /usr/sbin/nologin logos
sudo mkdir -p /opt/logos /etc/logos /var/lib/logos /opt/logos/www/wallet

cd "$(dirname "$0")/.."
cargo build --release -p logos_node
sudo cp ./target/release/logos_node /opt/logos/logos_node
sudo chown logos:logos /opt/logos/logos_node
sudo chmod 755 /opt/logos/logos_node

sudo cp ./infra/systemd/logos-node@.service /etc/systemd/system/logos-node@.service
sudo systemctl daemon-reload

sudo cp ./infra/nginx/logos-api-lb.conf.example /etc/nginx/sites-available/logos-api-lb.conf
sudo sed -i "s/YOUR_DOMAIN/${DOMAIN}/" /etc/nginx/sites-available/logos-api-lb.conf
sudo ln -sf /etc/nginx/sites-available/logos-api-lb.conf /etc/nginx/sites-enabled/logos-api-lb.conf
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

sudo cp -r ./www/wallet/* /opt/logos/www/wallet/
sudo chown -R logos:logos /opt/logos/www

if [ ! -f "/etc/logos/node-${INSTANCE}.env" ]; then
  sudo cp ./configs/env/node.env.example "/etc/logos/node-${INSTANCE}.env"
  echo ">>> EDIT /etc/logos/node-${INSTANCE}.env (LRB_NODE_SK_HEX/LRB_ADMIN_KEY/LRB_WALLET_ORIGIN)"
fi

sudo systemctl enable --now "logos-node@${INSTANCE}"
systemctl --no-pager status "logos-node@${INSTANCE}"

echo "API: http://127.0.0.1:8080   Wallet: http://${DOMAIN}/wallet/"

```

## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
```
#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="/root/logos_lrb"
GIT_REMOTE="${GIT_REMOTE:-origin}"
GIT_BRANCH="${GIT_BRANCH:-main}"
INCLUDE_SNAPSHOT="${INCLUDE_SNAPSHOT:-0}"

echo "[i] collecting from live system → $REPO_ROOT"
cd "$REPO_ROOT"

# .gitignore (если нет)
[ -f .gitignore ] || cat > .gitignore <<'EOF'
target/
**/target/
node_modules/
dist/
.DS_Store
*.swp
*.swo
/etc/logos/*.env
*.pem
*.key
*.crt
*.p12
/var/lib/logos/
/var/run/logos_health.json
/usr/local/bin/lrb_bench*
/usr/local/bin/logos_healthcheck.sh
/etc/letsencrypt/
*.log
/var/log/nginx/*.log
www/wallet/*.map
tools/**/go/bin/
EOF

# каталоги в репо
mkdir -p configs/env infra/systemd infra/nginx scripts tools/bench/go www/wallet docs

# wallet → www/wallet
if [ -d /opt/logos/www/wallet ]; then
  rsync -a --delete /opt/logos/www/wallet/ www/wallet/
  echo "[i] wallet synced"
fi

# systemd → infra/systemd
[ -f /etc/systemd/system/logos-node@.service ]       && cp -f /etc/systemd/system/logos-node@.service        infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.service ] && cp -f /etc/systemd/system/logos-healthcheck.service   infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.timer ]   && cp -f /etc/systemd/system/logos-healthcheck.timer     infra/systemd/

# nginx → infra/nginx (example)
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && cp -f /etc/nginx/sites-available/logos-api-lb.conf infra/nginx/logos-api-lb.conf.example

# healthcheck → scripts (если установлен в /usr/local/bin)
if [ -f /usr/local/bin/logos_healthcheck.sh ]; then
  cp -f /usr/local/bin/logos_healthcheck.sh scripts/logos_healthcheck.sh
  chmod +x scripts/logos_healthcheck.sh
fi

# env → *.example (обезличиваем секреты)
mkdir -p configs/env
shopt -s nullglob
for f in /etc/logos/node-*.env; do
  bn="$(basename "$f")"
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    "$f" > "configs/env/${bn}.example"
  echo "[i] env example: configs/env/${bn}.example"
done
# общий пример, если ничего не найдено
if [ -z "$(ls -1 configs/env/*.example 2>/dev/null || true)" ]; then
cat > configs/env/node.env.example <<'EEX'
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_DATA_DIR=/var/lib/logos
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_WALLET_ORIGIN=http://localhost
LRB_RATE_QPS=20
LRB_RATE_BURST=40
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
LRB_ENABLE_FAUCET=0
LRB_ADMIN_IP_ALLOW=127.0.0.1/32,::1/128
EEX
fi

# snapshots (опционально)
if [ "${INCLUDE_SNAPSHOT}" = "1" ]; then
  mkdir -p snapshots
  cp -f /root/logos_snapshot/*.txt snapshots/ 2>/dev/null || true
fi

# git add/commit/push
git add -A
if ! git diff --cached --quiet; then
  git commit -m "sync(live): full system snapshot (code+infra+wallet+scripts), env → *.example"
else
  echo "[i] nothing to commit"
fi

# пуш
git push "${GIT_REMOTE}" "${GIT_BRANCH}"
echo "[✓] pushed to ${GIT_REMOTE}/${GIT_BRANCH}"

```

## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```

## FILE: /root/logos_lrb/src/bin/ai_signal_listener.rs  (size=8704b)
```

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```

## FILE: /root/logos_lrb/src/bin/orchestration_control.rs  (size=6987b)
```
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/rcp_engine.rs  (size=4122b)
```
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```

## FILE: /root/logos_lrb/src/bin/resonance_mesh.rs  (size=8051b)
```
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/resonance_sync.rs  (size=11282b)
```
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/sigma_t.rs  (size=3522b)
```

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```

## FILE: /root/logos_lrb/src/bin/Λ0.rs  (SKIPPED, empty)

## FILE: /root/logos_lrb/src/core/biosphere_scanner.rs  (size=5196b)
```
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```

## FILE: /root/logos_lrb/src/core/dao.rs  (size=2106b)
```

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/logos_self.rs  (size=2771b)
```

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/phase.rs  (size=5790b)
```

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/resonance.rs  (size=3016b)
```

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/tx_spam_guard.rs  (size=3175b)
```

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/lib.rs  (size=921b)
```

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```

## FILE: /root/logos_lrb/src/utils/filters.rs  (size=322b)
```

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```

## FILE: /root/logos_lrb/src/utils/frequency.rs  (size=380b)
```

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```

## FILE: /root/logos_lrb/src/utils/math.rs  (size=394b)
```

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```

## FILE: /root/logos_lrb/src/utils/types.rs  (size=215b)
```

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```

## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```

## FILE: /root/logos_lrb/tools/batch.json  (SKIPPED, empty)

## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```

## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```

## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```

## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```

## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```

## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```

## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```

## FILE: /root/logos_lrb/tools/make_codebook.sh  (size=4987b)
```
#!/usr/bin/env sh
# LOGOS LRB — FULL LIVE book: repo + infra в один TXT (с маскировкой секретов)
set -eu

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT_DIR="docs"
STAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
OUT_FILE_TMP="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt.tmp"
OUT_FILE="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt"
SIZE_LIMIT="${SIZE_LIMIT:-2000000}"   # 2 MB per file
REPO_ROOT="/root/logos_lrb"

# --- ВКЛЮЧАЕМ ИЗ РЕПО ---
REPO_GLOBS='
Cargo.toml
README.md
src
lrb_core/src
node/src
modules
core
wallet-proxy
docs
www/wallet
www/explorer
infra/nginx
infra/systemd
scripts
tools
configs
'

# --- ВКЛЮЧАЕМ ИНФРУ С СЕРВЕРА ---
INFRA_FILES='
/etc/nginx/nginx.conf
/etc/nginx/conf.d/*.conf
/etc/nginx/sites-enabled/*
/etc/systemd/system/logos-node.service
/etc/systemd/system/*.service
/etc/systemd/system/*.timer
/etc/systemd/system/logos-node.service.d/*.conf
/etc/prometheus/prometheus.yml
/etc/prometheus/rules/*.yml
/etc/alertmanager/alertmanager.yml
/etc/alertmanager/secrets.env
/etc/grafana/grafana.ini
/etc/grafana/provisioning/datasources/*.yaml
/etc/grafana/provisioning/dashboards/*.yaml
/var/lib/grafana/dashboards/*.json
/opt/logos/www/wallet/*
/opt/logos/www/explorer/*
'

# --- ИСКЛЮЧЕНИЯ ДЛЯ РЕПО ---
EXCLUDES_REPO='
.git
target
node_modules
venv
__pycache__
*.pyc
data.sled
var
*.log
*.pem
*.der
*.crt
*.key
*.zip
*.tar
*.tar.gz
*.7z
LOGOS_LRB_FULL_BOOK.md
'

# язык для подсветки
lang_for() {
  case "${1##*.}" in
    rs) echo "rust" ;; toml) echo "toml" ;; json) echo "json" ;;
    yml|yaml) echo "yaml" ;; sh|bash) echo "bash" ;; py) echo "python" ;;
    js) echo "javascript" ;; ts) echo "typescript" ;; tsx|jsx) echo "tsx" ;;
    html|htm) echo "html" ;; css) echo "css" ;; md) echo "markdown" ;;
    conf|ini|service|timer|env) echo "" ;; *) echo "" ;;
  esac
}

# доверяем расширению, иначе grep -Iq
looks_text() {
  case "$1" in
    *.rs|*.toml|*.json|*.yml|*.yaml|*.sh|*.bash|*.py|*.js|*.ts|*.tsx|*.jsx|*.html|*.htm|*.css|*.md|*.conf|*.ini|*.service|*.timer|*.env) return 0;;
    *) LC_ALL=C grep -Iq . "$1";;
  esac
}

# фильтр исключений репо
should_exclude_repo() {
  f="$1"
  # с двоеточиями — мусор от редакторов
  echo "$f" | grep -q ":" && return 0
  echo "$EXCLUDES_REPO" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    case "$f" in */$pat/*|*/$pat|$pat) exit 0;; esac
  done; return 1
}

# маска секретов
mask_secrets() {
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED***/g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_BRIDGE_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_JWT_SECRET=)[A-Za-z0-9._-]+/\1***MASKED***/g'
}

write_header() {
  {
    echo "# FULL LIVE SNAPSHOT — $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "# sources: $REPO_ROOT + infra (/etc, /opt)"
    echo "# size limit per file: ${SIZE_LIMIT} bytes"
    echo
  } >>"$OUT_FILE_TMP"
}

dump_file() {
  f="$1"
  [ -f "$f" ] || return 0
  echo "$f" | grep -q ":" && return 0     # отсекаем мусорные имена

  sz="$(wc -c <"$f" | tr -d ' ' || echo 0)"
  [ "$sz" -eq 0 ] && { printf "\n## FILE: %s  (SKIPPED, empty)\n" "$f" >>"$OUT_FILE_TMP"; return 0; }
  [ "$sz" -gt "$SIZE_LIMIT" ] && { printf "\n## FILE: %s  (SKIPPED, size=%sb > limit)\n" "$f" "$sz" >>"$OUT_FILE_TMP"; return 0; }

  printf "\n## FILE: %s  (size=%sb)\n" "$f" "$sz" >>"$OUT_FILE_TMP"
  if looks_text "$f"; then
    printf '```\n' >>"$OUT_FILE_TMP"
    case "$f" in
      */alertmanager/secrets.env|*/logos-node.service.d/*|*/nginx/*.conf|*/conf.d/*.conf|*/sites-enabled/*|*/prometheus*.yml|*/grafana/*.ini|*/provisioning/*|*/dashboards/*.json)
        mask_secrets < "$f" >>"$OUT_FILE_TMP" ;;
      *) cat "$f" >>"$OUT_FILE_TMP" ;;
    esac
    printf '\n```\n' >>"$OUT_FILE_TMP"
  else
    printf "\n(SKIPPED, binary/non-text)\n" >>"$OUT_FILE_TMP"
  fi
}

collect_repo() {
  echo "$REPO_GLOBS" | while IFS= read -r rel; do
    [ -z "$rel" ] && continue
    [ "${rel#\#}" != "$rel" ] && continue
    p="$REPO_ROOT/$rel"
    if [ -d "$p" ]; then find "$p" -type f; elif [ -f "$p" ]; then echo "$p"; fi
  done
}

collect_infra() {
  echo "$INFRA_FILES" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    for f in $pat; do [ -f "$f" ] && echo "$f"; done
  done
}

main() {
  mkdir -p "$OUT_DIR"
  : >"$OUT_FILE_TMP"
  write_header

  collect_repo  | sort -u | while IFS= read -r p; do
    if should_exclude_repo "$p"; then continue; fi
    dump_file "$p"
  done

  collect_infra | sort -u | while IFS= read -r p; do
    dump_file "$p"
  done

  mv -f "$OUT_FILE_TMP" "$OUT_FILE"
  echo "✅ created: $OUT_FILE"
  cp -f "$OUT_FILE" "${ROOT}/LOGOS_LRB_FULL_BOOK.md" 2>/dev/null || true
}

main "$@"

```

## FILE: /root/logos_lrb/tools/make_full_book.sh  (size=5023b)
```
#!/usr/bin/env bash
# LOGOS LRB — Полная книга: исходники из репозитория + ключевые прод-конфиги
set -euo pipefail

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT="${ROOT}/LOGOS_LRB_FULL_BOOK.md"
TS="$(date -u +'%Y-%m-%d %H:%M:%S UTC')"
GIT_SHA="$(git -C "$ROOT" rev-parse --short=7 HEAD 2>/dev/null || echo 'no-git')"

# ---------- Параметры ----------
# исключаем мусор/бинарь/секреты
EXCLUDES_REPO=(
  ".git" "target" "node_modules" "venv" "__pycache__" "data.sled" "var"
  "LOGOS_LRB_FULL_BOOK.md" "*.log" "*.pem" "*.der" "*.crt" "*.key" "*.zip" "*.tar" "*.tar.gz" "*.7z"
)
# включаем infra из whitelist-путей
INFRA_FILES=(
  "/etc/nginx/conf.d/*.conf"
  "/etc/systemd/system/logos-node.service"
  "/etc/systemd/system/logos-node.service.d/*.conf"
  "/etc/prometheus/prometheus.yml"
  "/etc/prometheus/rules/*.yml"
  "/etc/alertmanager/alertmanager.yml"
  "/etc/alertmanager/secrets.env"
  "/etc/grafana/provisioning/datasources/*.yaml"
  "/etc/grafana/provisioning/dashboards/*.yaml"
  "/var/lib/grafana/dashboards/*.json"
)
MAX_SIZE=$((2*1024*1024))  # 2 МБ на файл

lang_for() {
  case "${1##*.}" in
    rs) echo "rust" ;; toml) echo "toml" ;; json) echo "json" ;;
    yml|yaml) echo "yaml" ;; sh|bash) echo "bash" ;; py) echo "python" ;;
    js) echo "javascript" ;; ts) echo "typescript" ;; tsx|jsx) echo "tsx" ;;
    html|htm) echo "html" ;; css) echo "css" ;; md) echo "markdown" ;;
    conf|ini|service|timer) echo "" ;;  *) echo "" ;;
  esac
}

exclude_match() {
  local f="$1"
  for p in "${EXCLUDES_REPO[@]}"; do
    case "$p" in
      *"*") [[ "$f" == $p ]] && return 0 ;;
      *)    [[ "$f" == */$p/* || "$f" == */$p || "$f" == $p ]] && return 0 ;;
    esac
  done
  return 1
}

# маскировка секретов для infra (телеграм токены, и т.п.)
mask_infra() {
  # stdin -> stdout
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED*** /g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED*** /g'
}

# ---------- Заголовок ----------
{
  echo "# LOGOS LRB — Полная книга (исходники + прод-конфиги)"
  echo
  echo "_Generated: ${TS} • Commit: ${GIT_SHA}_"
  echo
  echo "> В книге: весь код из репозитория + основные конфиги из /etc. Исключены бинарные/ключевые файлы; секреты замаскированы."
  echo
  echo "## Оглавление"
} > "$OUT"

TMP_LIST="$(mktemp)"
( cd "$ROOT" && find . -type f -print0 ) >"$TMP_LIST"

# ---------- Оглавление: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && continue
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  echo "- [repo:$f](#$anchor)" >> "$OUT"
done < "$TMP_LIST"

# ---------- Оглавление: infra ----------
for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && continue
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    echo "- [infra:$f](#$anchor)" >> "$OUT"
  done
done

{
  echo
  echo "---"
  echo
  echo "## Раздел I. Исходники репозитория"
  echo
} >> "$OUT"

# ---------- Контент: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
  rel="${f#./}"
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  lang="$(lang_for "$rel")"
  {
    echo "### $rel"
    echo "<a id=\"$anchor\"></a>"
    echo
    echo '```'"$lang"
    cat "$ROOT/$f"
    echo
    echo '```'
    echo
  } >> "$OUT"
done < "$TMP_LIST"

rm -f "$TMP_LIST"

# ---------- Контент: infra ----------
{
  echo
  echo "## Раздел II. Инфраструктурные конфиги (прод)"
  echo
} >> "$OUT"

for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    lang="$(lang_for "$f")"
    {
      echo "### $f"
      echo "<a id=\"$anchor\"></a>"
      echo
      echo '```'"$lang"
      # маскируем секреты в alertmanager/secrets.env и похожем
      case "$f" in
        */alertmanager/secrets.env) mask_infra < "$f" ;;
        *) cat "$f" ;;
      esac
      echo
      echo '```'
      echo
    } >> "$OUT"
  done
done

echo "✅ Сформировано: $OUT"

```

## FILE: /root/logos_lrb/tools/make_full_snapshot_live.sh  (size=4401b)
```
#!/usr/bin/env bash
set -euo pipefail

OUTDIR="${OUTDIR:-/root/logos_snapshot}"
STAMP=$(date +%Y%m%d_%H%M)
OUT="$OUTDIR/LRB_FULL_LIVE_${STAMP}.txt"
MAX=${MAX:-800000}  # макс размер включаемого файла (байт)

mkdir -p "$OUTDIR"

say(){ echo "$@" >&2; }
add_head(){
  echo -e "\n\n## FILE: $1  (size=${2}b)\n\`\`\`" >> "$OUT"
}
add_tail(){
  echo -e "\n\`\`\`" >> "$OUT"
}

# Источники (живые пути)
SRC_LIST=(
  "/root/logos_lrb"                   # весь код репо
  "/opt/logos/www/wallet"             # кошелёк
  "/etc/systemd/system/logos-node@.service"
  "/etc/systemd/system/logos-healthcheck.service"
  "/etc/systemd/system/logos-healthcheck.timer"
  "/etc/nginx/sites-available/logos-api-lb.conf"
  "/usr/local/bin/logos_healthcheck.sh"
)

# Заголовок
{
  echo "# FULL LIVE SNAPSHOT — $(date -u +%FT%TZ)"
  echo "# sources:"
  for s in "${SRC_LIST[@]}"; do echo "#  - $s"; done
  echo "# size limit per file: ${MAX} bytes"
  echo
} > "$OUT"

# Вспомогательные функции
is_text(){
  # бинарники/картинки отсекаем простым тестом: попытка вывести «без нулевых байтов»
  # или используем file(1) если есть
  if command -v file >/dev/null 2>&1; then
    file -b --mime "$1" | grep -qiE 'text|json|xml|yaml|toml|javascript|html|css' && return 0 || return 1
  else
    grep -Iq . "$1" && return 0 || return 1
  fi
}

emit_file(){
  local f="$1"
  [ -f "$f" ] || return 0
  # исключения
  case "$f" in
    *.pem|*.key|*.crt|*.p12|*.so|*.bin|*.png|*.jpg|*.jpeg|*.gif|*.svg|*.woff|*.woff2|*.ttf) return 0;;
  esac
  local sz
  sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
  if [ "$sz" -gt "$MAX" ]; then
    echo -e "\n\n## FILE: $f  (SKIPPED, size=${sz}b > ${MAX})" >> "$OUT"
    return 0
  fi
  if ! is_text "$f"; then
    echo -e "\n\n## FILE: $f  (SKIPPED, binary/non-text size=${sz}b)" >> "$OUT"
    return 0
  fi
  add_head "$f" "$sz"
  sed -e 's/\r$//' "$f" >> "$OUT"
  add_tail
}

# 1) Репозиторий: только текстовые файлы, игнорим target/node_modules/dist
if [ -d /root/logos_lrb ]; then
  say "[*] collecting /root/logos_lrb"
  cd /root/logos_lrb
  # берём отслеживаемые git'ом; если git недоступен — найдём все текстовые расширения
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    git ls-files | while read -r f; do
      case "$f" in target/*|**/target/*|node_modules/*|dist/*) continue;; esac
      emit_file "/root/logos_lrb/$f"
    done
  else
    find . -type f ! -path "./target/*" ! -path "./node_modules/*" ! -path "./dist/*" \
      -regextype posix-extended -regex '.*\.(rs|toml|md|sh|bash|zsh|service|timer|conf|nginx|yaml|yml|json|ts|tsx|js|mjs|jsx|html|htm|css|go|py|proto|ini|cfg|txt)$' \
      -print0 | xargs -0 -I{} bash -c 'emit_file "{}"'
  fi
  cd - >/dev/null
fi

# 2) Статика кошелька
if [ -d /opt/logos/www/wallet ]; then
  say "[*] collecting /opt/logos/www/wallet"
  find /opt/logos/www/wallet -type f -print0 | while IFS= read -r -d '' f; do emit_file "$f"; done
fi

# 3) systemd units
for u in /etc/systemd/system/logos-node@.service /etc/systemd/system/logos-healthcheck.service /etc/systemd/system/logos-healthcheck.timer; do
  [ -f "$u" ] && emit_file "$u"
done

# 4) nginx site
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && emit_file /etc/nginx/sites-available/logos-api-lb.conf

# 5) healthcheck script
[ -f /usr/local/bin/logos_healthcheck.sh ] && emit_file /usr/local/bin/logos_healthcheck.sh

# 6) Живые .env → в слепок как обезличенные *.example
sanitize_env(){
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(HOT_WALLET_PRIVATE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_TOKEN)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_CHAT_ID)=.*/\1=CHANGE_ME/' \
    "$1"
}
if ls /etc/logos/node-*.env >/dev/null 2>&1; then
  for f in /etc/logos/node-*.env; do
    tmp="$(mktemp)"; sanitize_env "$f" > "$tmp"
    sz=$(stat -c%s "$tmp" 2>/dev/null || echo 0)
    add_head "${f}.example" "$sz"
    cat "$tmp" >> "$OUT"
    add_tail
    rm -f "$tmp"
  done
fi

echo "[ok] wrote $OUT"

```

## FILE: /root/logos_lrb/tools/repo_audit.sh  (size=3155b)
```
#!/usr/bin/env bash
set -euo pipefail

fail=0
pass(){ printf "  [OK]  %s\n" "$1"; }
err(){  printf "  [FAIL] %s\n" "$1"; fail=1; }

echo "== GIT STATUS =="
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "not a git repo"; exit 1; }
git status --porcelain

echo "== CORE CODE =="
[ -d lrb_core/src ] && pass "lrb_core/src" || err "lrb_core/src missing"
[ -f lrb_core/src/ledger.rs ] && pass "lrb_core ledger.rs" || err "ledger.rs missing"
[ -f lrb_core/src/rcp_engine.rs ] && pass "lrb_core rcp_engine.rs" || err "rcp_engine.rs missing"
[ -f lrb_core/src/phase_filters.rs ] && pass "lrb_core phase_filters.rs" || err "phase_filters.rs missing"
[ -f lrb_core/src/crypto.rs ] && pass "lrb_core crypto.rs (AEAD)" || err "crypto.rs missing"

echo "== NODE =="
for f in node/src/main.rs node/src/api.rs node/src/metrics.rs node/src/guard.rs node/src/storage.rs node/src/version.rs; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done
[ -f node/src/openapi.json ] && pass "node/src/openapi.json" || err "openapi.json missing"
[ -f node/build.rs ] && pass "node/build.rs" || err "node/build.rs missing"
[ -f node/Cargo.toml ] && pass "node/Cargo.toml" || err "node/Cargo.toml missing"

echo "== MODULES DIR =="
[ -d modules ] && pass "modules/ present" || err "modules/ missing"

echo "== WALLET =="
for f in www/wallet/index.html www/wallet/wallet.css www/wallet/wallet.js; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== INFRA =="
for f in infra/systemd/logos-node@.service infra/systemd/logos-healthcheck.service infra/systemd/logos-healthcheck.timer \
         infra/nginx/logos-api-lb.conf.example; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== SCRIPTS =="
[ -f scripts/bootstrap_node.sh ] && pass "scripts/bootstrap_node.sh" || err "bootstrap_node.sh missing"
[ -f scripts/logos_healthcheck.sh ] && pass "scripts/logos_healthcheck.sh" || err "logos_healthcheck.sh missing"

echo "== TOOLS =="
[ -f tools/bench/go/bench.go ] && pass "bench v4: tools/bench/go/bench.go" || err "bench.go missing"
[ -f tools/sdk/ts/index.mjs ] && pass "TS SDK: tools/sdk/ts/index.mjs" || err "TS SDK missing"
[ -f tools/sdk/ts/sdk_test.mjs ] && pass "TS SDK test" || err "TS SDK test missing"
[ -f tools/sdk/go/logosapi.go ] && pass "Go SDK: tools/sdk/go/logosapi.go" || err "Go SDK missing"

echo "== CONFIGS / EXAMPLES =="
ls -1 configs/env/*.example >/dev/null 2>&1 && pass "env examples present" || err "env examples missing"
# убедимся что реальные .env не попали
if git ls-files | grep -E '^configs/env/.*\.env$' >/dev/null; then
  err "real .env found in repo"
else
  pass "no real .env tracked"
fi

echo "== SNAPSHOTS (optional) =="
[ -d snapshots ] && echo "  [info] snapshots/ exists (ok)"; true

echo "== SIZE / SUMMARY =="
echo "  tracked files: $(git ls-files | wc -l)"
echo "  repo disk size: $(du -sh . | cut -f1)"

echo "== SECRET LEAK SCAN (quick) =="
git grep -nE '(PRIVATE|SECRET|BEGIN (RSA|EC) PRIVATE KEY)' || true
git grep -nE 'LRB_NODE_SK_HEX=[0-9a-fA-F]{64}$' || true

echo
if [ $fail -eq 0 ]; then
  echo "[RESULT] REPO OK"
else
  echo "[RESULT] FAILS PRESENT"; exit 1
fi

```

## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```

## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```

## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```

## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```

## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```

## FILE: /root/logos_lrb/wallet-proxy/app.py  (size=7115b)
```
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```

## FILE: /root/logos_lrb/wallet-proxy/requirements.txt  (size=1147b)
```
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```

## FILE: /root/logos_lrb/wallet-proxy/scanner.py  (size=5538b)
```
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```

## FILE: /root/logos_lrb/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /root/logos_lrb/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /root/logos_lrb/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /root/logos_lrb/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /root/logos_lrb/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /root/logos_lrb/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /etc/alertmanager/alertmanager.yml  (size=603b)
```
route:
  receiver: 'telegram'
  group_wait: 10s
  group_interval: 1m
  repeat_interval: 2h

receivers:
- name: 'telegram'
  telegram_configs:
  - bot_token: '8317523208:AAH29EJG6H0BurJ4J74Bdb2XLjcDYcK9vIc'  # ← токен в КАВЫЧКАХ
    chat_id: 6355622860                                       # ← ЦЕЛОЕ ЧИСЛО (без кавычек)
    parse_mode: HTML
    message: |
      <b>{{ .Status | toUpper }}</b> — {{ .CommonLabels.alertname }}
      {{ range .Alerts -}}
      • <b>{{ .Labels.severity }}</b> @ {{ .StartsAt }}\n
        {{ .Annotations.summary }}
      {{ end }}

```

## FILE: /etc/alertmanager/secrets.env  (size=94b)
```
TELEGRAM_BOT_TOKEN=***MASKED***
TELEGRAM_CHAT_ID=***MASKED***

```

## FILE: /etc/grafana/grafana.ini  (size=191b)
```
[server]
http_addr = 0.0.0.0
http_port = 3000
# Grafana на корне, HTTPS домен:
root_url = https://45-159-248-232.sslip.io/
# без префикса
# serve_from_sub_path = false

```

## FILE: /etc/grafana/provisioning/dashboards/lrb.yaml  (size=151b)
```
apiVersion: 1
providers:
- name: LRB
  type: file
  updateIntervalSeconds: 10
  allowUiUpdates: false
  options:
    path: /var/lib/grafana/dashboards

```

## FILE: /etc/grafana/provisioning/datasources/prom.yaml  (size=146b)
```
apiVersion: 1
datasources:
- name: Prometheus
  type: prometheus
  access: proxy
  url: http://127.0.0.1:9094
  isDefault: true
  editable: false

```

## FILE: /etc/nginx/conf.d/00_redirect_80.conf  (size=118b)
```
server {
  listen 80 default_server;
  server_name 45-159-248-232.sslip.io;
  return 301 https://$host$request_uri;
}

```

## FILE: /etc/nginx/conf.d/10_lrb_https.conf  (size=2484b)
```
# === LOGOS LRB: HTTPS сайт ===
server {
  listen 443 ssl http2;
  server_name 45-159-248-232.sslip.io;

  # TLS
  ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;
  ssl_session_cache   shared:SSL:10m;
  ssl_protocols       TLSv1.2 TLSv1.3;
  ssl_ciphers         HIGH:!aNULL:!MD5;

  # Безопасные заголовки
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
  add_header X-Frame-Options        SAMEORIGIN       always;
  add_header X-Content-Type-Options nosniff          always;
  add_header Referrer-Policy        strict-origin-when-cross-origin always;

  # Базовая CSP
  add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

  # Grafana на корне
  location / {
    proxy_pass         http://127.0.0.1:3000/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }

  # Explorer (inline, без кэша)
  location /explorer/ {
    root /opt/logos/www;
    index index.html;

    expires off;
    etag off;
    add_header Cache-Control "no-store, no-cache, must-revalidate, max-age=0" always;
    add_header Pragma "no-cache" always;
    add_header Expires "0" always;

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

    try_files $uri $uri/ /explorer/index.html;
  }

  # Wallet
  location /wallet/ {
    root /opt/logos/www;
    index index.html;
    try_files $uri $uri/ /wallet/index.html;
  }

  # API (Axum 8080)
  location /api/ {
    proxy_pass         http://127.0.0.1:8080/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }
}

```

## FILE: /etc/nginx/nginx.conf  (size=1446b)
```
user www-data;
worker_processes auto;
pid /run/nginx.pid;
error_log /var/log/nginx/error.log;
include /etc/nginx/modules-enabled/*.conf;

events {
	worker_connections 768;
	# multi_accept on;
}

http {

	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}


#mail {
#	# See sample authentication script at:
#	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
#
#	# auth_http localhost/auth.php;
#	# pop3_capabilities "TOP" "USER";
#	# imap_capabilities "IMAP4rev1" "UIDPLUS";
#
#	server {
#		listen     localhost:110;
#		protocol   pop3;
#		proxy      on;
#	}
#
#	server {
#		listen     localhost:143;
#		protocol   imap;
#		proxy      on;
#	}
#}

```

## FILE: /etc/prometheus/prometheus.yml  (size=507b)
```
rule_files:
  - /etc/prometheus/rules/*.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
  - static_configs:
    - targets: ["127.0.0.1:9093"]

scrape_configs:
  # Метрики ноды LOGOS (Axum) — /metrics
  - job_name: logos_node
    static_configs:
      - targets: ['127.0.0.1:8080']
    metrics_path: /metrics

  # Node Exporter (включая lrb_exporter через textfile)
  - job_name: node
    static_configs:
      - targets: ['127.0.0.1:9100']

```

## FILE: /etc/prometheus/rules/lrb_alerts.yml  (size=1691b)
```
groups:
- name: lrb-core
  rules:
  # 1) Нода упала
  - alert: LogosNodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is down"
      description: "Target {{ $labels.instance }} is not scraping."

  # 2) Высокий процент 5xx за 5 минут
  - alert: HighErrorRatio
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m])) 
      / clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1) > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio (>2%)"
      description: "Instance {{ $labels.instance }} 5xx > 2%."

  # 3) Высокая латентность p95 > 1.5s
  - alert: HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "Instance {{ $labels.instance }} p95 high."

  # 4) Застряла высота (нет роста 10 минут)
  - alert: HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is not increasing"
      description: "No new blocks for 10m."

  # 5) Supply превышает cap (инвариант нарушен)
  - alert: SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap."

```

## FILE: /etc/prometheus/rules/lrb_core.yml  (size=3347b)
```
groups:

# ===================== LRB — Health =====================
- name: lrb-health
  rules:
  - alert: LRB_NodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is DOWN"
      description: "Target {{ $labels.instance }} is not scraping."

  - alert: LRB_HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is NOT increasing"
      description: "No new blocks on {{ $labels.instance }} for 10 minutes."

  - alert: LRB_HighHTTP5xx
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m]))
      /
      clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1)
      > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio >2%"
      description: "Instance {{ $labels.instance }} 5xx ratio is high."

# ===================== LRB — Performance =====================
- name: lrb-perf
  rules:
  - alert: LRB_HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "{{ $labels.instance }} p95={{ $value | printf \"%.2f\" }}s"

  - alert: LRB_LowRPS
    expr: |
      sum(rate(http_requests_total{job="logos_node"}[5m])) < 0.05
      and increase(lrb_head_height[10m]) >= 1
    for: 10m
    labels: { severity: warning }
    annotations:
      summary: "Logos API RPS is near zero"
      description: "Requests are almost zero while chain progresses."

# ===================== LRB — Economy =====================
- name: lrb-economy
  rules:
  - alert: LRB_SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap on {{ $labels.instance }}"

  - alert: LRB_EconomyMetricsMissing
    expr: absent(lrb_supply_total) or absent(lrb_cap_total)
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "Economy metrics are missing"
      description: "lrb_* economy metrics absent on {{ $labels.instance }}"

# ===================== Infra — Node Exporter =====================
- name: infra-node
  rules:
  - alert: HostLowMemory
    expr: node_memory_MemAvailable_bytes < 200 * 1024 * 1024
    for: 3m
    labels: { severity: warning }
    annotations:
      summary: "Low memory on host"
      description: "Available memory {{ $value | printf \"%.0f\" }} bytes"

  - alert: HostLowDisk
    expr: min(node_filesystem_avail_bytes{mountpoint="/",fstype!~"tmpfs|overlay"}) < 2 * 1024 * 1024 * 1024
    for: 5m
    labels: { severity: critical }
    annotations:
      summary: "Low disk space on /"
      description: "Free bytes {{ $value | printf \"%.0f\" }} on {{ $labels.instance }}"

  - alert: HostHighCPU
    expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 85
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High CPU usage"
      description: "CPU usage {{ $value | printf \"%.1f\" }}% on {{ $labels.instance }}"

```

## FILE: /etc/systemd/system/alertmanager.service  (size=400b)
```
[Unit]
Description=Alertmanager
After=network-online.target

[Service]
EnvironmentFile=/etc/alertmanager/secrets.env
ExecStart=/usr/local/bin/alertmanager \
  --config.file=/etc/alertmanager/alertmanager.yml \
  --storage.path=/var/lib/alertmanager \
  --web.listen-address=127.0.0.1:9093 \
  --cluster.listen-address=127.0.0.1:19094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.ModemManager1.service  (size=515b)
```
[Unit]
Description=Modem Manager
After=polkit.service
Requires=polkit.service
ConditionVirtualization=!container

[Service]
Type=dbus
BusName=org.freedesktop.ModemManager1
ExecStart=/usr/sbin/ModemManager
StandardError=null
Restart=on-abort
CapabilityBoundingSet=CAP_SYS_ADMIN CAP_NET_ADMIN
ProtectSystem=true
ProtectHome=true
PrivateTmp=true
RestrictAddressFamilies=AF_NETLINK AF_UNIX AF_QIPCRTR
NoNewPrivileges=true
User=root

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.ModemManager1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.resolve1.service  (size=1898b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Name Resolution
Documentation=man:systemd-resolved.service(8)
Documentation=man:org.freedesktop.resolve1(5)
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients

DefaultDependencies=no
After=systemd-sysctl.service systemd-sysusers.service
Before=sysinit.target network.target nss-lookup.target shutdown.target initrd-switch-root.target
Conflicts=shutdown.target initrd-switch-root.target
Wants=nss-lookup.target

[Service]
AmbientCapabilities=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
BusName=org.freedesktop.resolve1
CapabilityBoundingSet=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
ExecStart=!!/usr/lib/systemd/systemd-resolved
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectClock=yes
ProtectControlGroups=yes
ProtectHome=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/resolve
RuntimeDirectoryPreserve=yes
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service
Type=notify
User=systemd-resolve
ImportCredential=network.dns
ImportCredential=network.search_domains
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.resolve1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.thermald.service  (size=309b)
```
[Unit]
Description=Thermal Daemon Service
ConditionVirtualization=no

[Service]
Type=dbus
SuccessExitStatus=2
BusName=org.freedesktop.thermald
ExecStart=/usr/sbin/thermald --systemd --dbus-enable --adaptive
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.thermald.service


```

## FILE: /etc/systemd/system/dbus-org.freedesktop.timesync1.service  (size=1768b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Time Synchronization
Documentation=man:systemd-timesyncd.service(8)
ConditionCapability=CAP_SYS_TIME
ConditionVirtualization=!container
DefaultDependencies=no
After=systemd-sysusers.service
Before=time-set.target sysinit.target shutdown.target
Conflicts=shutdown.target
Wants=time-set.target

[Service]
AmbientCapabilities=CAP_SYS_TIME
BusName=org.freedesktop.timesync1
CapabilityBoundingSet=CAP_SYS_TIME
# Turn off DNSSEC validation for hostname look-ups, since those need the
# correct time to work, but we likely won't acquire that without NTP. Let's
# break this chicken-and-egg cycle here.
Environment=SYSTEMD_NSS_RESOLVE_VALIDATE=0
ExecStart=!!/usr/lib/systemd/systemd-timesyncd
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectProc=invisible
ProtectControlGroups=yes
ProtectHome=yes
ProtectHostname=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/timesync
StateDirectory=systemd/timesync
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service @clock
Type=notify
User=systemd-timesync
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.timesync1.service

```

## FILE: /etc/systemd/system/grafana.service  (size=333b)
```
[Unit]
Description=Grafana
After=network-online.target

[Service]
User=grafana
Group=grafana
ExecStart=/usr/share/grafana/bin/grafana-server \
  --homepath=/usr/share/grafana \
  --config=/etc/grafana/grafana.ini
WorkingDirectory=/usr/share/grafana
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/iscsi.service  (size=1003b)
```
[Unit]
Description=Login to default iSCSI targets
Documentation=man:iscsiadm(8) man:iscsid(8)
Wants=network-online.target remote-fs-pre.target
After=network-online.target iscsid.service
Before=remote-fs-pre.target
DefaultDependencies=no
Conflicts=shutdown.target
Before=shutdown.target
# Must have some pre-defined targets to login to
ConditionDirectoryNotEmpty=|/etc/iscsi/nodes
# or have a session to use via iscsid
ConditionDirectoryNotEmpty=|/sys/class/iscsi_session

[Service]
Type=oneshot
RemainAfterExit=true
# iscsiadm --login will return 21 if no nodes are configured,
# and 15 if a session is alread logged in (which we do not
# consider an error)
SuccessExitStatus=15 21
# Note: iscsid will be socket activated by iscsiadm
ExecStart=/usr/sbin/iscsiadm -m node --loginall=automatic
ExecStart=/usr/lib/open-iscsi/activate-storage.sh
ExecStop=/usr/lib/open-iscsi/umountiscsi.sh
ExecStop=/bin/sync
ExecStop=/usr/lib/open-iscsi/logout-all.sh

[Install]
WantedBy=sysinit.target
Alias=iscsi.service

```

## FILE: /etc/systemd/system/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /etc/systemd/system/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/logos-node.service  (size=293b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/bin/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node.service.d/cors.conf  (size=72b)
```
[Service]
Environment=LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io

```

## FILE: /etc/systemd/system/logos-node.service.d/data.conf  (size=61b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled

```

## FILE: /etc/systemd/system/logos-node.service.d/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /etc/systemd/system/logos-node.service.d/faucet.conf  (size=42b)
```
[Service]
Environment=LRB_ENABLE_FAUCET=1

```

## FILE: /etc/systemd/system/logos-node.service.d/keys.conf  (size=46b)
```
[Service]
EnvironmentFile=/etc/logos/keys.env

```

## FILE: /etc/systemd/system/logos-node.service.d/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /etc/systemd/system/logos-node.service.d/phasemix.conf  (size=44b)
```
[Service]
Environment=LRB_PHASEMIX_ENABLE=1

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit_bypass.conf  (size=53b)
```
[Service]
Environment=LRB_RATE_BYPASS_CIDR=0.0.0.0/0

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit.conf  (size=122b)
```
[Service]
Environment=LRB_RATE_QPS=30
Environment=LRB_RATE_BURST=60
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /etc/systemd/system/logos-node.service.d/runas.conf  (size=166b)
```
[Service]
User=logos
Group=logos
# Разрешаем запись туда, где нужно (данные/секреты)
ReadWritePaths=/var/lib/logos /etc/logos

```

## FILE: /etc/systemd/system/logos-node.service.d/security.conf  (size=106b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true

```

## FILE: /etc/systemd/system/logos-node.service.d/tuning.conf  (size=422b)
```
[Service]
Environment=LRB_NODE_LISTEN=0.0.0.0:8080
Environment=LRB_DATA_DIR=/var/lib/logos
Environment=LRB_WALLET_ORIGIN=http://127.0.0.1
Environment=LRB_RATE_QPS=20
Environment=LRB_RATE_BURST=40
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-keys.conf  (size=610b)
```
[Service]
# Читаем файл с секретами (на будущее, если захочешь использовать keys.env)
EnvironmentFile=-/etc/logos/keys.env

# Узловые параметры (жёстко, чтобы сервис точно стартовал)
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_SK_HEX=31962399e9b0e278af3b328bc6e30bbd17d90c700a5f6c7ad3c4d4418ed8fd83
Environment=LRB_ADMIN_KEY=***MASKED***
Environment=LRB_BRIDGE_KEY=***MASKED***

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /etc/systemd/system/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-exporter.service  (size=148b)
```
[Unit]
Description=LRB textfile exporter (economy/head)

[Service]
Type=oneshot
ExecStart=/usr/local/bin/lrb_exporter.sh
User=nodeexp
Group=nodeexp

```

## FILE: /etc/systemd/system/lrb-exporter.timer  (size=120b)
```
[Unit]
Description=Run LRB exporter every 15s

[Timer]
OnBootSec=5
OnUnitActiveSec=15

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/node-exporter.service  (size=284b)
```
[Unit]
Description=Node Exporter (Prometheus)
After=network-online.target

[Service]
User=nodeexp
Group=nodeexp
ExecStart=/usr/local/bin/node_exporter \
  --collector.textfile.directory=/var/lib/node_exporter/textfile
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/prometheus.service  (size=352b)
```
[Unit]
Description=Prometheus
After=network-online.target

[Service]
User=prom
Group=prom
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus \
  --web.enable-lifecycle \
  --web.listen-address=127.0.0.1:9094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/syslog.service  (size=890b)
```
[Unit]
Description=System Logging Service
Requires=syslog.socket
Documentation=man:rsyslogd(8)
Documentation=man:rsyslog.conf(5)
Documentation=https://www.rsyslog.com/doc/

[Service]
Type=notify
ExecStartPre=/usr/lib/rsyslog/reload-apparmor-profile
ExecStart=/usr/sbin/rsyslogd -n -iNONE
StandardOutput=null
StandardError=journal
Restart=on-failure

# Increase the default a bit in order to allow many simultaneous
# files to be monitored, we might need a lot of fds.
LimitNOFILE=16384

CapabilityBoundingSet=CAP_BLOCK_SUSPEND CAP_CHOWN CAP_DAC_OVERRIDE CAP_LEASE CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SYS_RESOURCE CAP_SYSLOG CAP_MAC_ADMIN CAP_SETGID CAP_SETUID
SystemCallFilter=@system-service
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
NoNewPrivileges=yes
ProtectHome=no
ProtectClock=yes
ProtectHostname=yes

[Install]
WantedBy=multi-user.target
Alias=syslog.service

```

## FILE: /etc/systemd/system/vmtoolsd.service  (size=489b)
```
[Unit]
Description=Service for virtual machines hosted on VMware
Documentation=http://open-vm-tools.sourceforge.net/about.php
ConditionVirtualization=vmware
DefaultDependencies=no
Before=cloud-init-local.service
After=vgauth.service
After=apparmor.service
RequiresMountsFor=/tmp
After=systemd-remount-fs.service systemd-tmpfiles-setup.service systemd-modules-load.service

[Service]
ExecStart=/usr/bin/vmtoolsd
TimeoutStopSec=5

[Install]
WantedBy=multi-user.target
Alias=vmtoolsd.service

```

## FILE: /opt/logos/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /opt/logos/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /opt/logos/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /opt/logos/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /opt/logos/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /opt/logos/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /var/lib/grafana/dashboards/lrb_core.json  (size=920b)
```
{
  "title": "LOGOS LRB — Core",
  "panels": [
    { "type": "stat", "title": "Head Height", "targets": [ { "expr": "lrb_head_height" } ] },
    { "type": "stat", "title": "Supply", "targets": [ { "expr": "lrb_supply_total" } ] },
    { "type": "stat", "title": "Minted", "targets": [ { "expr": "lrb_minted_total" } ] },
    { "type": "stat", "title": "Burned", "targets": [ { "expr": "lrb_burned_total" } ] },
    { "type": "graph", "title": "HTTP p95 (s)", "targets": [ { "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))" } ] },
    { "type": "graph", "title": "HTTP RPS", "targets": [ { "expr": "sum(rate(http_requests_total[1m])) by (status)" } ] },
    { "type": "graph", "title": "5xx ratio (%)", "targets": [ { "expr": "100 * sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))" } ] }
  ],
  "schemaVersion": 36, "version": 1
}

```

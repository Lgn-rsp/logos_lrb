# LOGOS LRB — core — BOOK (LIVE 2025-10-05_16-54-43)

- Branch: `main`
- Commit: `54d27563ee2c`
- rustc: `rustc 1.89.0 (29483883e 2025-08-04)`  cargo: `cargo 1.89.0 (c24e10642 2025-06-23)`

## Project tree (core)
```text
.
__pycache__
```

## Files list (core)
```text
./__pycache__/offline_resonance.cpython-312.pyc
./__pycache__/onboarding_sim.cpython-312.pyc
./__pycache__/onboarding_ui.cpython-312.pyc
./__pycache__/rLGN_converter.cpython-312.pyc
./__pycache__/resonance_analyzer.cpython-312.pyc
./__pycache__/rid_builder.cpython-312.pyc
./__pycache__/ritual_quest.cpython-312.pyc
./beta_rollout.yaml
./offline_resonance.py
./onboarding_sim.py
./onboarding_ui.py
./rLGN_converter.py
./resonance_analyzer.py
./rid_builder.py
./ritual_quest.py
```

## Files content (core)

### `core/./beta_rollout.yaml`

```
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"

```

### `core/./offline_resonance.py`

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math  # нужно для math.pi и других функций
import json
import time
from dataclasses import dataclass
from typing import List, Tuple

# Минимальная самодостаточная версия: генерация сигнала Σ(t) оффлайн
# Параметры резонанса (можно расширять конфигом)
F1 = 7.83      # Гц
F2 = 1.618     # Гц
F3 = 432.0     # Гц

@dataclass
class Sample:
    t: float
    s: float

def sigma_t(t: float) -> float:
    return (
        math.sin(2.0 * math.pi * F1 * t) +
        math.sin(2.0 * math.pi * F2 * t) +
        math.sin(2.0 * math.pi * F3 * t)
    )

def generate(duration_s: float = 2.0, rate_hz: float = 48000.0) -> List[Sample]:
    dt = 1.0 / rate_hz
    n = int(duration_s * rate_hz)
    out: List[Sample] = []
    t = 0.0
    for _ in range(n):
        out.append(Sample(t, sigma_t(t)))
        t += dt
    return out

def main():
    samples = generate(duration_s=1.0, rate_hz=1000.0)
    print(json.dumps([s.__dict__ for s in samples[:10]], ensure_ascii=False))

if __name__ == "__main__":
    main()
```

### `core/./onboarding_sim.py`

```
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()
```

### `core/./onboarding_ui.py`

```
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()
```

### `core/./rLGN_converter.py`

```
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())
```

### `core/./resonance_analyzer.py`

```
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")
```

### `core/./rid_builder.py`

```
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))
```

### `core/./ritual_quest.py`

```
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")
```

## Artifacts

- Book size: 39K
- Snapshot size: 26K

# FULL CODE SNAPSHOT (logos_lrb) - Thu Sep  4 02:26:11 PM BST 2025
# root: /root/logos_lrb



## FILE: AUDIT_REPORT.md  (size=4963b)
```text
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: Cargo.toml  (size=713b)
```text
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: README.md  (size=841b)
```text
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: configs/genesis.yaml  (size=0b)
```text

```


## FILE: configs/logos_config.yaml  (size=0b)
```text

```


## FILE: core/beta_rollout.yaml  (size=3586b)
```text
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: core/offline_resonance.py  (size=5400b)
```text
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: core/onboarding_sim.py  (size=5458b)
```text
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: core/onboarding_ui.py  (size=5974b)
```text
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: core/rLGN_converter.py  (size=5518b)
```text
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: core/resonance_analyzer.py  (size=3470b)
```text
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: core/rid_builder.py  (size=5229b)
```text
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: core/ritual_quest.py  (size=7912b)
```text
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: docs/WORKFLOW.md  (size=5440b)
```text
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: docs/architecture.md  (size=10559b)
```text
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: infra/nginx/lrb_wallet.conf  (size=2666b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: infra/systemd/exec.conf  (size=85b)
```text
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/keys.conf  (size=226b)
```text
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/logos-node.service  (size=369b)
```text
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/logos-snapshot.service  (size=271b)
```text
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: infra/systemd/logos-snapshot.timer  (size=163b)
```text
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: infra/systemd/lrb-proxy.service  (size=395b)
```text
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/lrb-scanner.service  (size=378b)
```text
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/override.conf  (size=575b)
```text
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: infra/systemd/runas.conf  (size=143b)
```text
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: infra/systemd/security.conf  (size=337b)
```text
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/tuning.conf  (size=156b)
```text
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: infra/systemd/zz-consensus.conf  (size=137b)
```text
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: infra/systemd/zz-keys.conf  (size=417b)
```text
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/zz-logging.conf  (size=36b)
```text
[Service]
Environment=RUST_LOG=info

```


## FILE: lrb_core/Cargo.toml  (size=654b)
```text
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = { workspace = true }
thiserror = { workspace = true }
serde = { workspace = true }
serde_json.workspace = true
blake3 = { workspace = true }
bs58 = { workspace = true }
ed25519-dalek = { workspace = true }
rand = { workspace = true }
rand_core = { workspace = true }
sled = { workspace = true }
once_cell = { workspace = true }
uuid = { workspace = true }
time = { workspace = true }
tokio = { workspace = true }
base64.workspace = true
hex.workspace = true
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
sha2 = "0.10.9"

```


## FILE: lrb_core/src/anti_replay.rs  (size=947b)
```text
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self { ttl_ms, map: HashMap::new() }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: lrb_core/src/beacon.rs  (size=1781b)
```text
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::{time::Duration};
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop { t.tick().await; }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers.iter().any(|p| !(p.starts_with("http://") || p.starts_with("https://"))) {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: lrb_core/src/dynamic_balance.rs  (size=576b)
```text
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self { base_cost_microunits: base, slope_per_tx: slope }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: lrb_core/src/heartbeat.rs  (size=2076b)
```text
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(rid, HeartbeatState { last_seen_ms: now_ms });
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter().map(|(r, s)| (r.clone(), s.last_seen_ms)).collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: lrb_core/src/ledger.rs  (size=11298b)
```text
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: lrb_core/src/lib.rs  (size=552b)
```text
pub mod types;
pub mod phase_integrity;
pub mod spam_guard;
pub mod dynamic_balance;
pub mod ledger;
pub mod rcp_engine;
pub mod heartbeat;
pub mod beacon;
pub mod resonance;
pub mod quorum;
pub mod phase_consensus;
pub mod phase_filters;
pub mod sigpool;

pub use types::*;
pub use phase_integrity::*;
pub use spam_guard::*;
pub use dynamic_balance::*;
pub use ledger::*;
pub use rcp_engine::*;
pub use heartbeat::*;
pub use beacon::*;
pub use resonance::*;
pub use quorum::*;
pub use phase_consensus::*;
pub use phase_filters::*;
pub use sigpool::*;

```


## FILE: lrb_core/src/phase_consensus.rs  (size=1769b)
```text
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize { self.quorum_n }
    pub fn finalized(&self) -> u64 { self.finalized_h }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes.get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: lrb_core/src/phase_filters.rs  (size=1684b)
```text
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN").ok().map(|v| v == "1").unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',').filter_map(|s| s.trim().parse::<f64>().ok()).collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE").ok().and_then(|s| s.parse::<f64>().ok()).unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() { return 1.0; }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() { return true; }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: lrb_core/src/phase_integrity.rs  (size=544b)
```text
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig).map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: lrb_core/src/quorum.rs  (size=1192b)
```text
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, VerifyingKey, Verifier};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: lrb_core/src/rcp_engine.rs  (size=7015b)
```text
use crate::{ledger::Ledger, spam_guard::SpamGuard, dynamic_balance::DynamicBalance, types::*, phase_integrity};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use crate::sigpool::filter_valid_sigs_parallel;
use anyhow::Result;
use std::{sync::{Arc, Mutex}, time::{Duration, SystemTime, UNIX_EPOCH}};
use tokio::sync::{mpsc::{UnboundedSender, unbounded_channel}, broadcast};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key).ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key).ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap   = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx  = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount    = env_u64("LRB_MAX_AMOUNT",   u64::MAX/2);
        let slot_ms       = env_u64("LRB_SLOT_MS",      500);
        let quorum_n      = env_usize("LRB_QUORUM_N",   1);
        let sig_workers   = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> { self.ledger.clone() }
    pub fn proposer(&self) -> Rid { self.proposer.clone() }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) { *self.commit_tx.lock().unwrap() = Some(sender); }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> { self.guard.check_amount(amount) }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> { self.mempool_tx.clone() }
    pub fn mempool_len(&self) -> usize { self.mempool.lock().unwrap().len() }
    pub fn finalized_height(&self) -> u64 { self.consensus.lock().unwrap().finalized() }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() { continue; }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() { continue; }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() { continue; }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: lrb_core/src/resonance.rs  (size=1122b)
```text
use blake3::Hasher;
use crate::types::{Block, Tx};

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS { h.update(tag); }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs { mix_tx(&mut h, tx) }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: lrb_core/src/sigpool.rs  (size=1040b)
```text
use crate::types::Tx;
use crate::phase_integrity::verify_tx_signature;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() { return txs; }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res { out.append(&mut v); }
    }
    out
}

```


## FILE: lrb_core/src/spam_guard.rs  (size=782b)
```text
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self { max_mempool, max_tx_per_block, max_amount }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize { self.max_tx_per_block }
}

```


## FILE: lrb_core/src/types.rs  (size=3294b)
```text
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String,             // blake3 of canonical form
    pub from: Rid,              // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>,    // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,     // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 { return Err(anyhow!("bad pubkey len")); }
        if self.signature.len() != 64 { return Err(anyhow!("bad signature len")); }
        if self.amount == 0 { return Err(anyhow!("amount must be > 0")); }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: modules/beacon_emitter.rs  (size=7378b)
```text
// LOGOS Beacon Emitter — Λ0 Signal Broadcaster
// Автор: LOGOS Core Dev

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::{HashMap, HashSet};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct BeaconSignal {
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub channel: String, // "file", "radio", "json", "stdout", "lora", "ble", "satellite"
}

pub struct BeaconEmitter {
    pub default_symbol: String,
    pub default_freq: f64,
    pub default_phase: f64,
    pub channels: Vec<String>,
    pub log_file: String,
    pub last_emit_time: u64,
    pub min_interval_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl BeaconEmitter {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        BeaconEmitter {
            default_symbol: "Λ0".to_string(),
            default_freq: 7.83,
            default_phase: 0.0,
            channels: vec!["file".to_string(), "stdout".to_string(), "lora".to_string(), "ble".to_string(), "satellite".to_string()],
            log_file: "beacon_emitter_log.json".to_string(),
            last_emit_time: 0,
            min_interval_sec: 60,
            valid_symbols,
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_parameters(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Проверка символа, частоты и фазы
        self.valid_symbols.contains(symbol) &&
        (0.1 <= frequency && frequency <= 10000.0) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase)
    }

    pub fn emit(&mut self) -> bool {
        let now = Self::current_time();
        if now - self.last_emit_time < self.min_interval_sec {
            self.log_event("[SKIP] Beacon too frequent");
            return false;
        }

        // Проверка параметров
        if !self.validate_parameters(&self.default_symbol, self.default_freq, self.default_phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: symbol={}, freq={}, phase={}",
                self.default_symbol, self.default_freq, self.default_phase
            ));
            return false;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp() {
            self.log_event("[!] RCP не подтвердил сигнал");
            return false;
        }

        for ch in &self.channels {
            let signal = BeaconSignal {
                symbol: self.default_symbol.clone(),
                frequency: self.default_freq,
                phase: self.default_phase,
                timestamp: now,
                channel: ch.clone(),
            };

            match ch.as_str() {
                "file" => self.write_to_file(&signal),
                "stdout" => println!("[BEACON] {} @ {}Hz φ = {:.4}", signal.symbol, signal.frequency, signal.phase),
                "json" => self.export_to_json(&signal),
                "lora" => self.emit_to_lora(&signal), // Заглушка для LoRa
                "ble" => self.emit_to_ble(&signal),   // Заглушка для BLE
                "satellite" => self.emit_to_satellite(&signal), // Заглушка для satellite
                _ => self.log_event(&format!("[WARN] Unsupported channel: {}", ch)),
            }
        }

        self.last_emit_time = now;
        self.log_event(&format!(
            "[BEACON] Emitted: {} @ {}Hz φ={:.4} on channels: {:?}", 
            self.default_symbol, self.default_freq, self.default_phase, self.channels
        ));
        true
    }

    fn validate_with_rcp(&self) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        self.default_symbol == "Λ0" && (self.default_freq - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, signal: &BeaconSignal) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("beacon_emitter_out.txt")
        {
            let _ = writeln!(
                file,
                "[BEACON] {} @ {}Hz φ={:.4} [{}]",
                signal.symbol, signal.frequency, signal.phase, signal.timestamp
            );
        }
    }

    fn export_to_json(&self, signal: &BeaconSignal) {
        let json = serde_json::to_string_pretty(signal).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("beacon_emitter_out.json")
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn emit_to_lora(&self, signal: &BeaconSignal) {
        // Заглушка для LoRa
        self.log_event(&format!("[LORA] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_ble(&self, signal: &BeaconSignal) {
        // Заглушка для BLE
        self.log_event(&format!("[BLE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_satellite(&self, signal: &BeaconSignal) {
        // Заглушка для satellite
        self.log_event(&format!("[SATELLITE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"beacon_emitter\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/env_impact_tracker.py  (size=5447b)
```text
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: modules/external_phase_broadcaster.rs  (size=7992b)
```text
rust
// LOGOS External Phase Broadcaster
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BroadcastPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub confidence: f64,
    pub timestamp: u64,
    pub destination: String,    // "file", "sound", "radio", "ble"
}

pub struct ExternalPhaseBroadcaster {
    pub valid_symbols: HashSet<String>,
    pub supported_channels: HashSet<String>,
    pub lambda_zero: String,
    pub min_confidence: f64,
    pub log_file: String,
    pub state_file: String,
    pub last_broadcast: HashMap<String, u64>, // destination -> timestamp
    pub last_broadcast_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_interval_sec: u64,
    pub cipher_key: Vec<u8>,
}

impl ExternalPhaseBroadcaster {
    pub fn new() -> Self {
        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        let mut channels = HashSet::new();
        channels.insert("file".to_string());
        channels.insert("sound".to_string());
        channels.insert("radio".to_string());
        channels.insert("ble".to_string());

        ExternalPhaseBroadcaster {
            valid_symbols: symbols,
            supported_channels: channels,
            lambda_zero: "Λ0".to_string(),
            min_confidence: 0.6,
            log_file: "external_phase_broadcast_log.json".to_string(),
            state_file: "external_phase_broadcast_state.json".to_string(),
            last_broadcast: HashMap::new(),
            last_broadcast_rid: HashMap::new(),
            min_interval_sec: 30,
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate(&self, phase: &BroadcastPhase) -> bool {
        self.valid_symbols.contains(&phase.symbol) &&
        self.supported_channels.contains(&phase.destination) &&
        (0.1..=10000.0).contains(&phase.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase.phase) &&
        phase.confidence >= self.min_confidence &&
        self.validate_rid(&phase.rid)
    }

    pub fn broadcast(&mut self, phase: BroadcastPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты по каналу
        let last = self.last_broadcast.get(&phase.destination).cloned().unwrap_or(0);
        let adjusted_interval = if phase.symbol == self.lambda_zero {
            self.min_interval_sec / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval_sec
        };
        if now - last < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка по каналу");
            return false;
        }

        // Проверка частоты по RID
        let last_rid = self.last_broadcast_rid.get(&phase.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка от RID");
            return false;
        }

        // Валидация
        if !self.validate(&phase) {
            self.log_event(&phase, "[DROP] Неверная фаза, confidence или RID");
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&phase) {
            self.log_event(&phase, "[DROP] Analyzer отклонил фазу");
            return false;
        }

        match phase.destination.as_str() {
            "file" => self.write_to_file(&phase),
            "stdout" => println!("[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} (RID: {})", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid),
            "sound" => self.emit_sound(&phase),
            "radio" => self.emit_radio(&phase),
            "ble" => self.emit_ble(&phase),
            _ => self.log_event(&phase, "[WARN] Неизвестный канал"),
        }

        self.last_broadcast.insert(phase.destination.clone(), now);
        self.last_broadcast_rid.insert(phase.rid.clone(), now);
        self.save_state();
        self.log_event(&phase, "[BROADCAST] Фаза отправлена");
        true
    }

    fn validate_with_analyzer(&self, phase: &BroadcastPhase) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        phase.symbol == self.lambda_zero || (phase.frequency - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, phase: &BroadcastPhase) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("broadcast_phase_output.txt")
        {
            let _ = writeln!(file, "[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} RID={} [{}]", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, phase.timestamp);
        }
    }

    fn emit_sound(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_radio(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[RADIO] Эмиссия (не реализовано)");
    }

    fn emit_ble(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[BLE] Эмиссия (не реализовано)");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_broadcast).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, phase: &BroadcastPhase, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_broadcast\", \"symbol\": \"{}\", \"freq\": {:.2}, \"phase\": {:.3}, \"conf\": {:.2}, \"rid\": \"{}\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, message, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/external_phase_link.rs  (size=6896b)
```text
rust
// LOGOS External Phase Link — Bridge to External Phase Sources
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExternalPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub source: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub confidence: f64,        // Оценка достоверности [0.0 - 1.0]
}

pub struct ExternalPhaseLink {
    pub accepted_sources: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub min_confidence: f64,
    pub network_activity: f64,
    pub last_received: HashMap<String, u64>, // source -> timestamp
    pub min_receive_interval: u64,
}

impl ExternalPhaseLink {
    pub fn new() -> Self {
        let mut sources = HashSet::new();
        sources.insert("external_device".to_string());
        sources.insert("oracle_feed".to_string());
        sources.insert("bio_input".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        ExternalPhaseLink {
            accepted_sources: sources,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "external_phase_link_log.json".to_string(),
            state_file: "external_phase_link_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Заменить на реальный ключ
            min_confidence: 0.6,
            network_activity: 1.0,
            last_received: HashMap::new(),
            min_receive_interval: 60,
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Адаптивный порог достоверности
        self.network_activity = activity.clamp(0.1, 10.0);
        self.min_confidence = (0.6 / self.network_activity).clamp(0.4, 0.8);
        self.log_event(&format!(
            "[INFO] Network activity updated: {:.2}, min_confidence={:.2}",
            self.network_activity, self.min_confidence
        ));
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_input(&self, ep: &ExternalPhase) -> bool {
        self.accepted_sources.contains(&ep.source) &&
        self.valid_symbols.contains(&ep.symbol) &&
        (0.1..=10000.0).contains(&ep.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&ep.phase) &&
        ep.confidence >= self.min_confidence &&
        self.validate_rid(&ep.rid)
    }

    pub fn forward_phase(&self, ep: ExternalPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма
        let last = self.last_received.get(&ep.source).cloned().unwrap_or(0);
        let adjusted_interval = if ep.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last < adjusted_interval {
            self.log_event(&format!("[DROP] Слишком частый приём от '{}'", ep.source));
            return false;
        }

        // Валидация
        if !self.validate_input(&ep) {
            self.log_event(&format!("[DROP] Неверный сигнал от '{}': RID={}, symbol={}, conf={:.2}",
                ep.source, ep.rid, ep.symbol, ep.confidence));
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&ep) {
            self.log_event(&format!("[REJECT] RCP/analyzer отклонил фазу от '{}'", ep.source));
            return false;
        }

        // Сохранение состояния
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.last_received.insert(ep.source.clone(), now);
        self.save_state(&ep);

        self.log_event(&format!(
            "[LINK] Принята внешняя фаза от {}: RID={} {} @ {:.3}Hz φ={:.4}, conf={:.2}",
            ep.source, ep.rid, ep.symbol, ep.frequency, ep.phase, ep.confidence
        ));
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, ep: &ExternalPhase) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        ep.symbol == self.lambda_zero || (ep.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self, ep: &ExternalPhase) {
        let state = serde_json::to_string(ep).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
                let _ = file.write_all(b"\n");
            }
        }
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_link\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/genesis_fragment_seeds.rs  (size=6958b)
```text
rust
// LOGOS Genesis Fragment Seeds
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use shamirsecretsharing::{split_secret, recover_secret};

#[derive(Debug, Serialize, Deserialize)]
pub struct SeedFragment {
    pub node_id: String,
    pub fragment: Vec<u8>,
    pub timestamp: u64,
    pub symbol: String, // Связь с Λ0
}

pub struct GenesisFragmentSeeds {
    pub fragments: HashMap<String, SeedFragment>,
    pub required_shares: usize,
    pub total_shares: usize,
    pub original_seed: Vec<u8>,
    pub log_file: String,
    pub state_file: String,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub store_timestamps: HashMap<String, u64>, // node_id -> last store time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl GenesisFragmentSeeds {
    pub fn new(seed: Vec<u8>, total: usize, required: usize) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        GenesisFragmentSeeds {
            fragments: HashMap::new(),
            required_shares: required,
            total_shares: total,
            original_seed: seed,
            log_file: "genesis_fragment_log.json".to_string(),
            state_file: "genesis_fragment_state.json".to_string(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            store_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_node_id_and_symbol(&self, node_id: &str, symbol: &str) -> bool {
        node_id.contains(|c: char| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn generate_shards(&mut self) -> Vec<(usize, Vec<u8>)> {
        let shards = split_secret(self.total_shares, self.required_shares, &self.original_seed)
            .expect("Ошибка при фрагментации Λ0");
        self.log_event("[FRAG] Сгенерированы фрагменты ядра");
        shards
    }

    pub fn store_fragment(&mut self, node_id: &str, fragment: Vec<u8>, symbol: &str) -> bool {
        let now = Self::current_time();

        // Ограничение частоты
        let last_store = self.store_timestamps.get(node_id).cloned().unwrap_or(0);
        if now - last_store < 60 {
            self.log_event(&format!("[!] Слишком частое сохранение от {}", node_id));
            return false;
        }
        self.store_timestamps.insert(node_id.to_string(), now);

        // Валидация node_id и symbol
        if !self.validate_node_id_and_symbol(node_id, symbol) {
            self.log_event(&format!("[!] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        // Проверка связи с Λ0 (заглушка для resonance_analyzer.py)
        if symbol != self.lambda_zero && !self.validate_with_analyzer(node_id, symbol) {
            self.log_event(&format!("[!] Символ {} не связан с Λ0", symbol));
            return false;
        }

        let entry = SeedFragment {
            node_id: node_id.to_string(),
            fragment,
            timestamp: now,
            symbol: symbol.to_string(),
        };
        self.fragments.insert(node_id.to_string(), entry);
        self.save_state();
        self.log_event(&format!("[STORE] Фрагмент принят от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn recover_seed(&self) -> Option<Vec<u8>> {
        if self.fragments.len() < self.required_shares {
            self.log_event(&format!(
                "[WARN] Недостаточно фрагментов: {}/{}",
                self.fragments.len(), self.required_shares
            ));
            return None;
        }

        let shares: Vec<(usize, Vec<u8>)> = self
            .fragments
            .iter()
            .take(self.required_shares)
            .enumerate()
            .map(|(i, (_, frag))| (i + 1, frag.fragment.clone()))
            .collect();

        match recover_secret(&shares) {
            Ok(seed) => {
                self.log_event("[SUCCESS] Λ0 восстановлен из фрагментов");
                Some(seed)
            }
            Err(e) => {
                self.log_event(&format!("[FAIL] Ошибка восстановления Λ0: {}", e));
                None
            }
        }
    }

    fn validate_with_analyzer(&self, _node_id: &str, symbol: &str) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        symbol == self.lambda_zero
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.fragments).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"genesis_fragment\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/go_to_market.yaml  (size=3633b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: modules/heartbeat_monitor.rs  (size=7769b)
```text
rust
// LOGOS Network Heartbeat Monitor
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions, File};
use std::io::{Write, Read};
use std::net::{UdpSocket, SocketAddr};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

#[derive(Debug, Serialize, Deserialize)]
pub struct Heartbeat {
    pub rid: String,
    pub timestamp: u64,
    pub symbol: String,
    pub Σ_t: f64,
}

pub struct HeartbeatMonitor {
    pub active_nodes: HashMap<String, Heartbeat>,
    pub timeout_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub udp_port: u16,
    pub heartbeat_timestamps: HashMap<String, u64>, // RID -> last heartbeat time
}

impl HeartbeatMonitor {
    pub fn new(port: u16, timeout: u64) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        HeartbeatMonitor {
            active_nodes: HashMap::new(),
            timeout_sec: timeout,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "heartbeat_log.json".to_string(),
            state_file: "heartbeat_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            udp_port: port,
            heartbeat_timestamps: HashMap::new(),
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn listen(&mut self) {
        let socket = UdpSocket::bind(format!("0.0.0.0:{}", self.udp_port)).expect("Не удалось привязать сокет");
        let mut buf = [0u8; 1024];
        loop {
            match socket.recv_from(&mut buf) {
                Ok((len, addr)) => {
                    let raw = &buf[..len];
                    if let Some(hb) = self.parse_heartbeat(raw) {
                        self.register_heartbeat(hb, addr);
                    }
                }
                Err(e) => {
                    self.log_event(&format!("[ERR] UDP receive error: {}", e));
                }
            }
        }
    }

    pub fn parse_heartbeat(&self, raw: &[u8]) -> Option<Heartbeat> {
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut raw_buf = raw.to_vec();
        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut raw_buf) {
            if let Ok(hb) = serde_json::from_slice::<Heartbeat>(decrypted) {
                if self.validate_heartbeat(&hb) {
                    return Some(hb);
                }
            }
        }
        self.log_event("[ERR] Ошибка парсинга или валидации heartbeat");
        None
    }

    pub fn validate_heartbeat(&self, hb: &Heartbeat) -> bool {
        // Проверка RID, символа и Σ(t)
        let valid = self.validate_rid(&hb.rid) &&
                    self.valid_symbols.contains(&hb.symbol) &&
                    hb.Σ_t.is_finite() &&
                    // Проверка Λ0
                    (hb.symbol == self.lambda_zero || (hb.Σ_t.abs() < 10.0)); // Более мягкие условия для Λ0
        if !valid {
            self.log_event(&format!("[!] Недопустимый heartbeat от RID {}: symbol={}, Σ(t)={}", 
                hb.rid, hb.symbol, hb.Σ_t));
        }
        valid
    }

    pub fn register_heartbeat(&mut self, hb: Heartbeat, addr: SocketAddr) {
        let now = Self::current_time();

        // Проверка частоты heartbeat
        let last_heartbeat = self.heartbeat_timestamps.get(&hb.rid).cloned().unwrap_or(0);
        let adjusted_timeout = if hb.symbol == self.lambda_zero {
            self.timeout_sec * 2 // Увеличенный таймаут для Λ0
        } else {
            self.timeout_sec
        };
        if now - last_heartbeat < adjusted_timeout / 10 {
            self.log_event(&format!("[!] Слишком частый heartbeat от RID {}", hb.rid));
            return;
        }
        self.heartbeat_timestamps.insert(hb.rid.clone(), now);

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&hb) {
            self.log_event(&format!("[!] RCP не подтвердил heartbeat от RID {}", hb.rid));
            return;
        }

        self.active_nodes.insert(hb.rid.clone(), hb.clone());
        self.save_state();
        self.log_event(&format!(
            "[HEARTBEAT] RID {} — Σ(t) = {:.4} @ {} (from {})",
            hb.rid, hb.Σ_t, hb.timestamp, addr
        ));
    }

    pub fn validate_with_rcp(&self, _hb: &Heartbeat) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        true // TODO: Реализовать
    }

    pub fn purge_inactive(&mut self) {
        let now = Self::current_time();
        self.active_nodes.retain(|rid, hb| {
            let adjusted_timeout = if hb.symbol == self.lambda_zero {
                self.timeout_sec * 2
            } else {
                self.timeout_sec
            };
            if now - hb.timestamp <= adjusted_timeout {
                true
            } else {
                self.log_event(&format!("[CLEANUP] Удалён неактивный RID {}", rid));
                false
            }
        });
        self.save_state();
        self.log_event("[CLEANUP] Удалены неактивные узлы");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.active_nodes).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"heartbeat\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = log_entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/legacy_migrator.rs  (size=6851b)
```text
// LOGOS Legacy Blockchain Migrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct LegacyTx {
    pub origin_chain: String,
    pub legacy_address: String,
    pub tx_hash: String,
    pub amount: f64,
    pub timestamp: u64,
    pub symbol_hint: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MigratedTx {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub amount: f64,
    pub migrated_from: String,
    pub original_tx_hash: String,
    pub timestamp: u64,
}

pub struct LegacyMigrator {
    pub migration_log: String,
    pub symbol_map: HashMap<String, String>,
    pub frequency_map: HashMap<String, f64>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl LegacyMigrator {
    pub fn new() -> Self {
        let mut symbol_map = HashMap::new();
        symbol_map.insert("ethereum".to_string(), "☉".to_string());
        symbol_map.insert("cosmos".to_string(), "??".to_string());
        symbol_map.insert("polkadot".to_string(), "♁".to_string());

        let mut frequency_map = HashMap::new();
        frequency_map.insert("ethereum".to_string(), 432.0);
        frequency_map.insert("cosmos".to_string(), 7.83);
        frequency_map.insert("polkadot".to_string(), 1.618);

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        LegacyMigrator {
            migration_log: "legacy_migration_log.json".to_string(),
            symbol_map,
            frequency_map,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_tx(&self, tx: &LegacyTx) -> bool {
        // Проверка данных транзакции
        !tx.origin_chain.is_empty() &&
        !tx.legacy_address.is_empty() &&
        !tx.tx_hash.is_empty() &&
        tx.amount > 0.0 &&
        tx.timestamp > 0 &&
        tx.symbol_hint.as_ref().map_or(true, |s| self.valid_symbols.contains(s))
    }

    pub fn migrate(&self, legacy_tx: LegacyTx) -> Option<MigratedTx> {
        if !self.validate_tx(&legacy_tx) {
            self.log_migration_event(&format!(
                "[!] Недопустимая транзакция: chain={}, amount={}",
                legacy_tx.origin_chain, legacy_tx.amount
            ));
            return None;
        }

        let chain = legacy_tx.origin_chain.to_lowercase();
        let symbol = legacy_tx.symbol_hint.clone().unwrap_or_else(|| {
            self.symbol_map.get(&chain).cloned().unwrap_or(self.lambda_zero.clone())
        });

        if !self.valid_symbols.contains(&symbol) {
            self.log_migration_event(&format!("[!] Недопустимый символ: {}", symbol));
            return None;
        }

        let freq = self.frequency_map.get(&chain).cloned().unwrap_or(7.83);
        let phase = self.estimate_phase(&legacy_tx);

        // Проверка фазы через RCP (заглушка)
        if !self.validate_with_rcp(&symbol, freq, phase) {
            self.log_migration_event(&format!(
                "[!] RCP не подтвердил: {} @ {} Hz, φ={:.4}",
                symbol, freq, phase
            ));
            return None;
        }

        let rid = format!("{}@{}Hzφ{:.4}", symbol, freq, phase);

        let migrated = MigratedTx {
            rid: rid.clone(),
            symbol,
            frequency: freq,
            phase,
            amount: legacy_tx.amount,
            migrated_from: legacy_tx.origin_chain.clone(),
            original_tx_hash: legacy_tx.tx_hash.clone(),
            timestamp: legacy_tx.timestamp,
        };

        self.log_migration(&migrated);
        Some(migrated)
    }

    fn validate_with_rcp(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        symbol == self.lambda_zero || (frequency - 7.83).abs() < 0.1
    }

    fn estimate_phase(&self, tx: &LegacyTx) -> f64 {
        let h = tx.tx_hash.bytes().fold(0u64, |acc, b| acc.wrapping_add(b as u64));
        let phase = ((h % 6283) as f64 / 1000.0) - std::f64::consts::PI;
        phase
    }

    fn log_migration(&self, migrated: &MigratedTx) {
        let json = serde_json::to_string(migrated).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap(); // Заглушка для nonce
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.migration_log)
            {
                let _ = writeln!(file, "{}", String::from_utf8_lossy(&in_out));
            }
        }
    }

    fn log_migration_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"legacy_migration\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.migration_log)
        {
            let _ = file.write_all(log_entry.as_bytes());
        }
    }

    pub fn load_legacy_batch(&self, path: &str) -> Vec<LegacyTx> {
        if let Ok(mut f) = File::open(path) {
            let mut contents = String::new();
            if f.read_to_string(&mut contents).is_ok() {
                if let Ok(list) = serde_json::from_str::<Vec<LegacyTx>>(&contents) {
                    return list.into_iter().filter(|tx| self.validate_tx(tx)).collect();
                }
            }
        }
        self.log_migration_event(&format!("[!] Ошибка загрузки батча: {}", path));
        vec![]
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/maintenance_strategy.yaml  (size=2361b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: modules/resonance_analytics_frontend.tsx  (size=4632b)
```text
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: modules/resonance_emergency_plan.yaml  (size=3420b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: modules/resonance_meshmap.yaml  (size=1877b)
```text
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: modules/resonance_tutor.py  (size=6414b)
```text
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: modules/ritual_engine.rs  (size=7546b)
```text
rust
// LOGOS Ritual Engine
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualAction {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualDefinition {
    pub id: String,
    pub title: String,
    pub required_symbol: String,
    pub required_frequency: f64,
    pub required_phase: Option<f64>,
    pub min_phase: Option<f64>,
    pub max_phase: Option<f64>,
    pub reward_lgn: f64,
    pub repeatable: bool,
}

pub struct RitualEngine {
    pub rituals: HashMap<String, RitualDefinition>,
    pub completed: HashMap<String, Vec<String>>, // RID -> list of ritual IDs
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub action_timestamps: HashMap<String, u64>, // RID -> last action time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl RitualEngine {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        RitualEngine {
            rituals: HashMap::new(),
            completed: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "ritual_engine_log.json".to_string(),
            action_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_rid_and_symbol(&self, rid: &str, symbol: &str) -> bool {
        !rid.is_empty() &&
        rid.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn load_rituals(&mut self, path: &str) {
        if let Ok(file) = std::fs::read_to_string(path) {
            if let Ok(map) = serde_json::from_str::<Vec<RitualDefinition>>(&file) {
                for r in map {
                    if self.valid_symbols.contains(&r.required_symbol) {
                        self.rituals.insert(r.id.clone(), r);
                    } else {
                        self.log_event(&format!("[!] Недопустимый символ в ритуале: {}", r.required_symbol));
                    }
                }
                self.log_event("[INFO] Загружены ритуалы");
            } else {
                self.log_event("[!] Ошибка парсинга ритуалов");
            }
        } else {
            self.log_event(&format!("[!] Ошибка чтения файла ритуалов: {}", path));
        }
    }

    pub fn submit_action(&mut self, action: RitualAction) -> Option<f64> {
        let now = Self::current_time();

        // Проверка частоты действий
        let last_action = self.action_timestamps.get(&action.rid).cloned().unwrap_or(0);
        if now - last_action < 60 {
            self.log_event(&format!("[!] Слишком частое действие от RID {}", action.rid));
            return None;
        }
        self.action_timestamps.insert(action.rid.clone(), now);

        // Валидация RID и символа
        if !self.validate_rid_and_symbol(&action.rid, &action.symbol) {
            self.log_event(&format!("[!] Недопустимый RID или символ: {}, {}", action.rid, action.symbol));
            return None;
        }

        // Проверка параметров
        if action.frequency <= 0.0 || action.frequency > 10000.0 ||
           !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&action.phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: f={}, φ={:.4}",
                action.frequency, action.phase
            ));
            return None;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&action) {
            self.log_event(&format!(
                "[!] RCP не подтвердил: {} @ {}Hz φ={:.4}",
                action.symbol, action.frequency, action.phase
            ));
            return None;
        }

        for (id, ritual) in self.rituals.iter() {
            if !ritual.repeatable && self.completed.get(&action.rid).map_or(false, |r| r.contains(id)) {
                continue;
            }

            if ritual.required_symbol != action.symbol {
                continue;
            }

            if (ritual.required_frequency - action.frequency).abs() > 0.1 {
                continue;
            }

            if let Some(req_phase) = ritual.required_phase {
                if (req_phase - action.phase).abs() > 0.05 {
                    continue;
                }
            }

            if let Some(min) = ritual.min_phase {
                if action.phase < min {
                    continue;
                }
            }

            if let Some(max) = ritual.max_phase {
                if action.phase > max {
                    continue;
                }
            }

            let reward = if action.symbol == self.lambda_zero {
                ritual.reward_lgn * 1.2 // Бонус для Λ0
            } else {
                ritual.reward_lgn
            };

            self.completed
                .entry(action.rid.clone())
                .or_default()
                .push(ritual.id.clone());

            self.log_event(&format!(
                "[RITUAL] RID {} выполнил ритуал {}: {} (+{} LGN)",
                action.rid, ritual.id, ritual.title, reward
            ));
            return Some(reward);
        }

        self.log_event(&format!("[MISS] RID {} не активировал ни один ритуал", action.rid));
        None
    }

    fn validate_with_rcp(&self, action: &RitualAction) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        action.symbol == self.lambda_zero || (action.frequency - 7.83).abs() < 0.1
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"ritual_engine\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/symbolic_parser.py  (size=4615b)
```text
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: modules/uplink_controller.rs  (size=7680b)
```text
rust
// LOGOS Uplink Controller — External Uplink & Relay Orchestrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkEvent {
    pub symbol: String,
    pub channel: String, // "lora", "ble", "satellite", "sound", "qr"
    pub status: String,  // "emitted", "received", "failed"
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkController {
    pub supported_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>,
    pub log_file: String,
    pub emit_timestamps: HashMap<String, u64>, // channel -> last emit time
    pub min_emit_interval: u64, // Минимальный интервал в секундах
}

impl UplinkController {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("satellite".to_string());
        channels.insert("sound".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkController {
            supported_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            log_file: "uplink_log.json".to_string(),
            emit_timestamps: HashMap::new(),
            min_emit_interval: 60, // 1 минута
        }
    }

    pub fn validate_symbol(&self, symbol: &str) -> bool {
        self.valid_symbols.contains(symbol)
    }

    pub fn validate_channel(&self, channel: &str) -> bool {
        self.supported_channels.contains(channel)
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        // Проверка размера и формата payload
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn emit(&self, symbol: &str, channel: &str, payload: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты эмиссии
        let last_emit = self.emit_timestamps.get(channel).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_emit_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_emit_interval
        };
        if now - last_emit < adjusted_interval {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Слишком частая эмиссия");
            return false;
        }

        // Валидация
        if !self.validate_symbol(symbol) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый символ");
            return false;
        }

        if !self.validate_channel(channel) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый канал");
            return false;
        }

        if !self.validate_payload(payload) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый payload");
            return false;
        }

        // Реализация каналов
        let event = UplinkEvent {
            symbol: symbol.to_string(),
            channel: channel.to_string(),
            status: "emitted".to_string(),
            payload: payload.to_string(),
            timestamp: now,
        };

        match channel {
            "lora" => self.emit_to_lora(&event),
            "ble" => self.emit_to_ble(&event),
            "satellite" => self.emit_to_satellite(&event),
            "sound" => self.emit_to_sound(&event),
            "qr" => self.emit_to_qr(&event),
            _ => {
                self.log_event(event.clone(), &format!("[WARN] Unsupported channel: {}", channel));
                return false;
            }
        }

        // Обновление времени эмиссии
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.emit_timestamps.insert(channel.to_string(), now);
        self.log_event(event, "Успешная эмиссия");
        true
    }

    fn emit_to_lora(&self, event: &UplinkEvent) {
        // Заглушка для LoRa
        self.log_event(event.clone(), "[LORA] Эмиссия (не реализовано)");
    }

    fn emit_to_ble(&self, event: &UplinkEvent) {
        // Заглушка для BLE
        self.log_event(event.clone(), "[BLE] Эмиссия (не реализовано)");
    }

    fn emit_to_satellite(&self, event: &UplinkEvent) {
        // Заглушка для satellite
        self.log_event(event.clone(), "[SATELLITE] Эмиссия (не реализовано)");
    }

    fn emit_to_sound(&self, event: &UplinkEvent) {
        // Заглушка для sound
        self.log_event(event.clone(), "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_to_qr(&self, event: &UplinkEvent) {
        // Заглушка для QR
        self.log_event(event.clone(), "[QR] Эмиссия (не реализовано)");
    }

    fn log_event(&self, event: UplinkEvent, message: &str) {
        let json = serde_json::to_string(&event).unwrap_or_default();
        let log_entry = format!(
            "{{\"event\": \"uplink_controller\", \"message\": \"{}\", \"data\": {}, \"timestamp\": {}}}\n",
            message, json, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buffer = log_entry.as_bytes().to_vec();

        if aead.seal_in_place_append_tag(nonce, &[], &mut buffer).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buffer);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/uplink_router.rs  (size=7301b)
```text
rust
// LOGOS Uplink Router — External Signal Receiver
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkSignal {
    pub rid: String, // Добавлено для идентификации узла
    pub channel: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkRouter {
    pub valid_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub last_received: HashMap<String, u64>, // channel -> timestamp
    pub last_received_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_receive_interval: u64,
}

impl UplinkRouter {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("sound".to_string());
        channels.insert("satellite".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkRouter {
            valid_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "uplink_router_log.json".to_string(),
            state_file: "uplink_router_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            last_received: HashMap::new(),
            last_received_rid: HashMap::new(),
            min_receive_interval: 10,
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn receive(&mut self, signal: UplinkSignal) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма по каналу
        let last_channel = self.last_received.get(&signal.channel).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last_channel < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём по каналу");
            return false;
        }

        // Проверка частоты приёма по RID
        let last_rid = self.last_received_rid.get(&signal.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём от RID");
            return false;
        }

        // Валидация RID
        if !self.validate_rid(&signal.rid) {
            self.log_event(&signal, "[DROP] Недопустимый RID");
            return false;
        }

        // Валидация символа и канала
        if !self.valid_symbols.contains(&signal.symbol) {
            self.log_event(&signal, "[DROP] Недопустимый символ");
            return false;
        }
        if !self.valid_channels.contains(&signal.channel) {
            self.log_event(&signal, "[DROP] Недопустимый канал");
            return false;
        }

        // Проверка частоты/фазы
        if signal.frequency <= 0.0 || signal.frequency > 10000.0 || !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&signal.phase) {
            self.log_event(&signal, "[DROP] Неверная частота или фаза");
            return false;
        }

        // Проверка payload
        if !self.validate_payload(&signal.payload) {
            self.log_event(&signal, "[DROP] Недопустимый payload");
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&signal) {
            self.log_event(&signal, "[DROP] RCP или analyzer отклонил сигнал");
            return false;
        }

        self.last_received.insert(signal.channel.clone(), now);
        self.last_received_rid.insert(signal.rid.clone(), now);
        self.save_state();
        self.log_event(&signal, "[OK] Сигнал принят");
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, signal: &UplinkSignal) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_received).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, signal: &UplinkSignal, msg: &str) {
        let entry = format!(
            "{{\"event\":\"uplink_router\",\"message\":\"{}\",\"rid\":\"{}\",\"channel\":\"{}\",\"symbol\":\"{}\",\"frequency\":{},\"phase\":{},\"timestamp\":{}}}\n",
            msg, signal.rid, signal.channel, signal.symbol, signal.frequency, signal.phase, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: node/Cargo.toml  (size=557b)
```text
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
tokio = { version = "1", features = ["full"] }
axum = "0.6"
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls", "json"] }
tower = "0.4"
tower-http = { version = "0.4.4", features = ["cors"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.19"
prometheus = "0.13"
rand = "0.8"
ed25519-dalek = "2"
bs58 = "0.5"
hex = "0.4"
base64 = "0.22"
jsonwebtoken = "9"

lrb_core = { path = "../lrb_core" }

```


## FILE: node/src/admin.rs  (size=6316b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use serde::{Serialize, Deserialize};
use std::{fs, path::PathBuf};
use crate::{state::AppState, auth};

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub vk_b58: String,
    pub slot_ms: Option<u64>,
    pub max_block_txs: Option<usize>,
    pub mempool_cap: Option<usize>,
    pub env: serde_json::Value,
}

pub async fn node_info(Extension(st): Extension<AppState>) -> Json<NodeInfo> {
    let vk_b58 = bs58::encode(st.self_vk.to_bytes()).into_string();
    let rid = vk_b58.clone();
    let slot_ms = std::env::var("LRB_SLOT_MS").ok().and_then(|s| s.parse::<u64>().ok());
    let max_block_txs = std::env::var("LRB_MAX_BLOCK_TX").ok().and_then(|s| s.parse::<usize>().ok());
    let mempool_cap = std::env::var("LRB_MEMPOOL_CAP").ok().and_then(|s| s.parse::<usize>().ok());
    let keys = [
        "LRB_SLOT_MS","LRB_MAX_BLOCK_TX","LRB_MEMPOOL_CAP","LRB_MAX_AMOUNT",
        "LRB_DEV","LRB_PEERS","LRB_VALIDATORS","LRB_QUORUM_N",
        "LRB_BRIDGE_MAX_PER_TX","LRB_DATA_PATH","LRB_NODE_KEY_PATH",
    ];
    let mut envmap = serde_json::Map::new();
    for k in keys.iter() { if let Ok(val) = std::env::var(k) { envmap.insert((*k).to_string(), serde_json::Value::String(val)); } }
    Json(NodeInfo { rid, vk_b58, slot_ms, max_block_txs, mempool_cap, env: serde_json::Value::Object(envmap) })
}

/* ===== JWT mint для админки ===== */
#[derive(Serialize)] pub struct TokenResp { pub ok:bool, pub token:String, pub ttl_sec:usize }
pub async fn admin_token(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(q): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<TokenResp>, StatusCode> {
    // Требуем предъявить действительный ADMIN KEY (или Bearer KEY) для выдачи токена
    // IP ACL внутри require_admin
    let ip = None; // опционально можно протащить remote_ip из Tower layers
    auth::require_admin(&headers, ip)?;

    let ttl = q.get("ttl").and_then(|s| s.parse::<usize>().ok()).unwrap_or(600);
    let secret = std::env::var("LRB_ADMIN_JWT_SECRET").map_err(|_| StatusCode::UNAUTHORIZED)?;
    if secret.trim().is_empty() { return Err(StatusCode::UNAUTHORIZED); }
    let tok = auth::mint_jwt(&secret, "admin", ttl as i64)?;
    Ok(Json(TokenResp { ok:true, token: tok, ttl_sec: ttl }))
}

/* ===== Snapshot / Restore ===== */
#[derive(Serialize, Deserialize)]
pub struct Snapshot { pub head:u64, pub finalized:u64, pub lgn_balances:Vec<(String,u64)>, pub rlgn_balances:Vec<(String,u64)> }

pub async fn snapshot(Extension(st): Extension<AppState>, headers: HeaderMap)
-> Result<Json<Snapshot>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg }))
}

pub async fn snapshot_file(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let name = params.get("name").cloned().unwrap_or_else(|| format!("snap-{}.json", crate::state::now_ms()));
    let safe = name.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.');
    if !safe { return Err(StatusCode::BAD_REQUEST); }

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let snap = Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg };
    let data = serde_json::to_vec_pretty(&snap).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut path = PathBuf::from("/var/lib/logos/snapshots"); path.push(name);
    fs::write(&path, data).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "file": path.to_string_lossy()})))
}

#[derive(Deserialize)] pub struct RestoreReq { pub file: String }
pub async fn restore(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RestoreReq>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let safe = req.file.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.' || c=='/' );
    if !safe || !req.file.starts_with("/var/lib/logos/snapshots/") { return Err(StatusCode::BAD_REQUEST); }
    let data = fs::read(&req.file).map_err(|_| StatusCode::NOT_FOUND)?;
    let snap: Snapshot = serde_json::from_slice(&data).map_err(|_| StatusCode::BAD_REQUEST)?;
    for (rid_s, amt) in snap.lgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_balance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    for (rid_s, amt) in snap.rlgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_rbalance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    Ok(Json(serde_json::json!({"ok": true})))
}

/* validators info */
#[derive(Serialize)] pub struct ValidatorsInfo { pub validators: Vec<String>, pub quorum_n: usize }
pub async fn validators_info(Extension(st): Extension<AppState>) -> Json<ValidatorsInfo> {
    let vals = st.validators.iter().cloned().collect::<Vec<_>>();
    Json(ValidatorsInfo { validators: vals, quorum_n: st.quorum_n })
}

```


## FILE: node/src/api.rs  (size=10732b)
```text
use axum::{
    extract::{Path, Extension, Query},
    Json,
};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use lrb_core::*;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

use crate::state::*;

/* ---------- типы ---------- */
#[derive(Serialize)] pub struct Healthz { pub ok: bool }
#[derive(Deserialize)] pub struct SubmitTx {
    pub from:String, pub to:String, pub amount:u64, pub nonce:u64,
    pub public_key_b58:String, pub signature_b64:String
}
#[derive(Serialize)] pub struct SubmitResp { pub accepted: bool, pub tx_id: String, pub lgn_cost_microunits: u64 }
#[derive(Deserialize)] pub struct DebugCanonReq { pub from:String, pub to:String, pub amount:u64, pub nonce:u64, pub public_key_b58:String }
#[derive(Serialize)] pub struct DebugCanonResp { pub canon_hex:String, pub server_tx_id:String }

/* ---------- базовые ---------- */
pub async fn healthz() -> Json<Healthz> { Json(Healthz{ok:true}) }

pub async fn head(Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let (h, hash) = st.engine.ledger().head().unwrap_or((0, String::new()));
    let fin = st.engine.ledger().get_finalized().unwrap_or(0);
    Json(serde_json::json!({ "height": h, "hash": hash, "finalized": fin }))
}

pub async fn balance(Path(rid): Path<String>, Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let rid = Rid(rid); let bal = st.engine.ledger().get_balance(&rid);
    Json(serde_json::json!({ "rid": rid.as_str(), "balance": bal }))
}

/* ---------- состояние аккаунта ---------- */
pub async fn account_state(Path(rid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    let r = Rid(rid);
    let bal = st.engine.ledger().get_balance(&r);
    let n   = st.engine.ledger().get_nonce(&r);
    Ok(Json(serde_json::json!({ "rid": r.as_str(), "balance": bal, "nonce": n })))
}

/* ---------- одиночный submit ---------- */
pub async fn submit_tx(Extension(st): Extension<AppState>, Json(req): Json<SubmitTx>)
-> Result<Json<SubmitResp>, StatusCode> {
    if !st.rl_submit.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    TX_SUBMITTED.inc();
    if req.amount == 0 { return Err(StatusCode::BAD_REQUEST); }
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".into(), from:Rid(req.from.clone()), to:Rid(req.to.clone()),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:sig_bytes };
    let tx = Tx { id: tx.compute_id(), ..tx };
    if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    st.engine.mempool_sender().send(tx.clone()).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(SubmitResp { accepted:true, tx_id: tx.id, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- batch submit ---------- */
#[derive(Serialize)] pub struct BatchItem { pub tx_id:String, pub ok:bool, pub err:Option<String> }
#[derive(Serialize)] pub struct BatchResp { pub accepted:usize, pub rejected:usize, pub items:Vec<BatchItem>, pub lgn_cost_microunits:u64 }

pub async fn submit_tx_batch(Extension(st): Extension<AppState>, Json(reqs): Json<Vec<SubmitTx>>)
-> Result<Json<BatchResp>, StatusCode> {
    let n = reqs.len(); if n == 0 { return Err(StatusCode::BAD_REQUEST); }
    let maxb = std::env::var("LRB_MAX_BATCH").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(1000);
    if n > maxb { return Err(StatusCode::PAYLOAD_TOO_LARGE); }
    if !st.rl_submit.try_take(n as u64) { return Err(StatusCode::TOO_MANY_REQUESTS); }

    let mut items = Vec::with_capacity(n); let mut accepted = 0usize;
    let sender = st.engine.mempool_sender();
    for r in reqs {
        if r.amount == 0 {
            items.push(BatchItem{ tx_id:String::new(), ok:false, err:Some("amount=0".into())});
            continue;
        }
        let pk_bytes = match bs58::decode(&r.public_key_b58).into_vec() { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad public_key_b58".into())}); continue; } };
        let sig_bytes = match B64.decode(r.signature_b64.as_bytes()) { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad signature_b64".into())}); continue; } };
        let tx = Tx { id:String::new(), from:Rid(r.from), to:Rid(r.to), amount:r.amount, nonce:r.nonce, public_key:pk_bytes, signature:sig_bytes };
        let tx = Tx { id: tx.compute_id(), ..tx };
        if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("bad signature".into())}); continue; }
        if sender.send(tx.clone()).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("enqueue failed".into())}); continue; }
        items.push(BatchItem{tx_id:tx.id, ok:true, err:None}); accepted+=1;
    }
    TX_SUBMITTED.inc_by(accepted as u64);
    Ok(Json(BatchResp{ accepted, rejected: items.len()-accepted, items, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- debug / block / tx ---------- */
pub async fn debug_canon(Json(req): Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".to_string(), from:Rid(req.from), to:Rid(req.to),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:vec![0u8;64] };
    Ok(Json(DebugCanonResp { canon_hex: hex::encode(tx.canonical_bytes()), server_tx_id: tx.compute_id() }))
}

pub async fn get_block(Path(height): Path<u64>, Extension(st): Extension<AppState>)
-> Result<Json<Block>, StatusCode> {
    st.engine.ledger().get_block_by_height(height).map(Json).map_err(|_| StatusCode::NOT_FOUND)
}

/* простой ответ по tx: только высота, если есть */
pub async fn get_tx(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => Ok(Json(serde_json::json!({ "tx_id": txid, "height": h }))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

/* детальный ответ по tx (блок целиком) */
#[derive(Serialize)] pub struct TxFull { pub tx_id:String, pub height:u64, pub block:serde_json::Value, pub found:bool }
pub async fn get_tx_full(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<TxFull>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => {
            let blk = st.engine.ledger().get_block_by_height(h).map_err(|_| StatusCode::NOT_FOUND)?;
            let blk_json = serde_json::to_value(&blk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
            Ok(Json(TxFull{ tx_id: txid, height: h, block: blk_json, found:true }))
        }
        None => Ok(Json(TxFull{ tx_id: txid, height: 0, block: serde_json::json!({}), found:false })),
    }
}

/* ---------- история аккаунта (пагинация курсором) ---------- */
#[derive(Serialize)] pub struct AccountTxsPage {
    pub rid:String, pub limit:usize, pub items:Vec<serde_json::Value>,
    pub next_cursor_h: Option<u64>, pub next_cursor_seq: Option<u32>
}
pub async fn account_txs(
    Path(rid_s): Path<String>,
    Query(q): Query<HashMap<String,String>>,
    Extension(st): Extension<AppState>
) -> Result<Json<AccountTxsPage>, StatusCode> {
    let rid = Rid(rid_s);
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(100);
    let ch = q.get("cursor_h").and_then(|s| s.parse::<u64>().ok());
    let cs = q.get("cursor_seq").and_then(|s| s.parse::<u32>().ok());
    let (items, next_h, next_s) = st.engine.ledger().list_account_txs_page(&rid, ch, cs, limit)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(AccountTxsPage{
        rid: rid.as_str().to_string(), limit, items,
        next_cursor_h: next_h, next_cursor_seq: next_s
    }))
}

/* ---------- эксплорер (последние блоки/tx) ---------- */
#[derive(Serialize)] pub struct RecentBlocks { pub items: Vec<serde_json::Value> }
pub async fn recent_blocks(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentBlocks>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<u64>().ok()).unwrap_or(20);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    for _ in 0..limit {
        if h == 0 { break; }
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            out.push(serde_json::to_value(b).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?);
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentBlocks{ items: out }))
}

#[derive(Serialize)] pub struct RecentTxs { pub items: Vec<serde_json::Value> }
pub async fn recent_txs(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentTxs>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(50);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    while out.len() < limit && h > 0 {
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            for tx in b.txs.iter().rev() {
                if out.len() >= limit { break; }
                out.push(serde_json::json!({"height": b.height, "tx_id": tx.id, "from": tx.from.0, "to": tx.to.0, "amount": tx.amount}));
            }
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentTxs{ items: out }))
}

/* ---------- DEV faucet ---------- */
#[allow(dead_code)]
pub async fn faucet(Path((rid_s,amount_s)):Path<(String,String)>, Extension(st):Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    if !st.dev_mode { return Err(StatusCode::FORBIDDEN); }
    let rid = Rid(rid_s); let amount:u64 = amount_s.parse().map_err(|_| StatusCode::BAD_REQUEST)?;
    let cur = st.engine.ledger().get_balance(&rid); let newb = cur.saturating_add(amount);
    st.engine.ledger().set_balance(&rid, newb).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "rid": rid.as_str(), "balance": newb })))
}

```


## FILE: node/src/auth.rs  (size=5131b)
```text
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: node/src/bridge.rs  (size=3607b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signer, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};
use crate::state::{AppState, BR_DEPOSIT, BR_REDEEM, now_ms};
use crate::auth;

#[derive(Deserialize)] pub struct DepositReq { pub rid:String, pub amount:u64, pub ext_txid:String }
#[derive(Serialize)]   pub struct DepositResp { pub ok:bool, pub rid:String, pub r_balance:u64 }
#[derive(Deserialize)] pub struct RedeemReq { pub rid:String, pub amount:u64, pub request_id:String }
#[derive(Serialize)]   pub struct RedeemResp { pub ok:bool, pub rid:String, pub r_balance:u64, pub redeem_ticket:String, pub signature_b64:String }
#[derive(Deserialize)] pub struct VerifyReq { pub ticket:String, pub signature_b64:String, pub vk_b58:String }
#[derive(Serialize)]   pub struct VerifyResp { pub ok:bool }

pub async fn deposit(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<DepositReq>)
-> Result<Json<DepositResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?;  // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("dep:{}", req.ext_txid);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    BR_DEPOSIT.inc();
    Ok(Json(DepositResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb }))
}

pub async fn redeem(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RedeemReq>)
-> Result<Json<RedeemResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?; // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("red:{}", req.request_id);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;
    BR_REDEEM.inc();

    let ticket = format!("redeem:{}:{}:{}", rid.as_str(), req.amount, req.request_id);
    let sig = st.sk.sign(ticket.as_bytes());
    let signature_b64 = B64.encode(sig.to_bytes());
    Ok(Json(RedeemResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb, redeem_ticket: ticket, signature_b64 }))
}

pub async fn verify(Json(req): Json<VerifyReq>) -> Result<Json<VerifyResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.vk_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig = ed25519_dalek::Signature::from_bytes(&sig_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?);
    Ok(Json(VerifyResp { ok: vk.verify(req.ticket.as_bytes(), &sig).is_ok() }))
}

```


## FILE: node/src/fork.rs  (size=429b)
```text
use anyhow::Result;
use lrb_core::Block;
use crate::state::AppState;

/// Временная реализация: делаем вид, что реорг не требуется.
/// Когда включим полноценный fork-choice, сюда добавим сравнение sigma/weight.
pub fn apply_or_reorg_deep(_st: &AppState, _incoming: &Block, _sigma_hex: &str, _prev_hash: &str) -> Result<()> {
    Ok(())
}

```


## FILE: node/src/gossip.rs  (size=5147b)
```text
use anyhow::Result;
use axum::{extract::Extension, Json};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, Signer, VerifyingKey};
use serde::{Deserialize, Serialize};
use lrb_core::{Block, resonance, phase_filters::block_passes_phase};
use crate::state::{AppState, now_ms, GOSSIP_BLK_SENT, GOSSIP_BLK_RECV, GOSSIP_VOTE_SENT, GOSSIP_VOTE_RECV, CONS_VOTES, PHASE_BLOCK_ACCEPTED, PHASE_BLOCK_REJECTED};

#[derive(Serialize, Deserialize, Clone)]
pub struct GossipHeader { pub height:u64, pub prev_hash:String, pub block_hash:String, pub proposer_rid:String, pub timestamp_ms:u128, pub sigma_hex:String }
#[derive(Serialize, Deserialize, Clone)]
pub struct GossipBlockMsg { pub header:GossipHeader, pub block:Block, pub sender_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }
#[derive(Serialize, Deserialize, Clone)]
pub struct VoteMsg { pub height:u64, pub block_hash:String, pub sigma_hex:String, pub voter_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }

fn verify_gossip_sig(msg: &GossipBlockMsg) -> Result<()> {
    let pk_bytes = bs58::decode(&msg.sender_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(msg.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);
    let mut payload = Vec::new();
    payload.extend_from_slice(msg.header.sigma_hex.as_bytes());
    payload.extend_from_slice(msg.header.block_hash.as_bytes());
    payload.extend_from_slice(&msg.nonce_ms.to_le_bytes());
    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

pub async fn send_block(peers:&[String], st:&AppState, block:&Block) {
    let sigma_hex = resonance::sigma_digest_block_hex(block);
    let nonce_ms = now_ms();
    let mut pl = Vec::new();
    pl.extend_from_slice(sigma_hex.as_bytes());
    pl.extend_from_slice(block.block_hash.as_bytes());
    pl.extend_from_slice(&nonce_ms.to_le_bytes());
    let sig_b64 = B64.encode(st.sk.sign(&pl).to_bytes());
    let header = GossipHeader {
        height:block.height, prev_hash:block.prev_hash.clone(), block_hash:block.block_hash.clone(),
        proposer_rid:block.proposer.0.clone(), timestamp_ms:block.timestamp_ms, sigma_hex:sigma_hex.clone()
    };
    let msg = GossipBlockMsg {
        header, block:block.clone(),
        sender_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(),
        sig_b64, nonce_ms
    };
    for p in peers {
        let _ = st.http.post(&format!("{}/gossip/block", p.trim_end_matches('/'))).json(&msg).send().await;
        GOSSIP_BLK_SENT.inc();
    }

    let vote_nonce = now_ms();
    let mut pv = Vec::new();
    pv.extend_from_slice(sigma_hex.as_bytes());
    pv.extend_from_slice(block.block_hash.as_bytes());
    pv.extend_from_slice(&block.height.to_le_bytes());
    pv.extend_from_slice(&vote_nonce.to_le_bytes());
    let vote_sig_b64 = B64.encode(st.sk.sign(&pv).to_bytes());
    let vmsg = VoteMsg {
        height:block.height, block_hash:block.block_hash.clone(), sigma_hex: sigma_hex.clone(),
        voter_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(), sig_b64: vote_sig_b64, nonce_ms: vote_nonce
    };
    for p in peers { let _ = st.http.post(&format!("{}/gossip/vote", p.trim_end_matches('/'))).json(&vmsg).send().await; GOSSIP_VOTE_SENT.inc(); }
}

pub async fn gossip_block(Extension(st): Extension<AppState>, Json(msg): Json<GossipBlockMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    GOSSIP_BLK_RECV.inc();

    let local_sigma = resonance::sigma_digest_block_hex(&msg.block);
    if local_sigma != msg.header.sigma_hex { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if verify_gossip_sig(&msg).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }

    // фазовый фильтр: блоки вне фазы не принимаем
    if !block_passes_phase(&msg.block) {
        PHASE_BLOCK_REJECTED.inc();
        return Err(StatusCode::UNPROCESSABLE_ENTITY);
    }
    PHASE_BLOCK_ACCEPTED.inc();

    crate::fork::apply_or_reorg_deep(&st, &msg.block, &msg.header.sigma_hex, &msg.header.prev_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true})))
}

pub async fn gossip_vote(Extension(st): Extension<AppState>, Json(v): Json<VoteMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.validators.is_empty() && !st.validators.contains(&v.voter_pk_b58) { return Err(StatusCode::FORBIDDEN); }
    GOSSIP_VOTE_RECV.inc();
    let vv = lrb_core::quorum::Vote {
        height: v.height, block_hash: v.block_hash.clone(), sigma_hex: v.sigma_hex.clone(),
        voter_pk_b58: v.voter_pk_b58.clone(), sig_b64: v.sig_b64.clone(), nonce_ms: v.nonce_ms
    };
    if let Err(_) = lrb_core::quorum::verify_vote(&vv) { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if st.engine.register_vote(v.height, &v.block_hash, &v.voter_pk_b58) { CONS_VOTES.inc(); }
    Ok(Json(serde_json::json!({"ok": true})))
}

```


## FILE: node/src/main.rs  (size=5036b)
```text
// node/src/main.rs — прод-роутер с историей/индексами и базовой инициализацией
mod bridge;
mod admin;
mod fork;
mod state;
mod gossip;
mod metrics;
mod api;
mod peers;

use anyhow::Result;
use axum::{
    extract::DefaultBodyLimit,
    routing::{get, post},
    Extension, Router,
};
use std::{env, net::SocketAddr, time::Duration};
use tokio::{signal, time::interval};

use lrb_core::*;
use crate::state::AppState;

#[tokio::main]
async fn main() -> Result<()> {
    // --------- инициализация ключей/ledger/engine ----------
    // Ключи/ledger/engine инициализируй так, как у тебя уже сделано — здесь оставляем существующую логику.
    // Ниже только минимальные обязательные шаги, чтобы не поломать твой запуск.

    // Открываем базу
    let data_path = env::var("LRB_DATA_PATH").unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());
    let ledger = Ledger::open(&data_path)?;

    // ИНИЦИАЛИЗАЦИЯ ENGINE — используй фактическую функцию/конструктор, которая уже есть у тебя:
    // предположим у тебя есть что-то вроде: let (engine, _mp) = engine_with_channels(ledger, self_rid.clone());
    // Здесь для совместимости:
    let (engine, _mp) = {
        // В твоём коде уже есть построение self_rid / ключей — оставь его.
        // Ниже упрощённый вызов: если у тебя другой — подставь свой.
        let dummy_rid = Rid("DUMMY_RID".to_string());
        engine_with_channels(ledger, dummy_rid)
    };

    // Запуск block producer (оставляем как в твоём коде)
    {
        let eng = engine.clone();
        tokio::spawn(async move {
            let _ = eng.run_block_producer().await;
        });
    }

    // Собираем AppState из твоей реализации
    let st = AppState::new_for_router(engine.clone())?;

    // --------- Роуты (все действующие + история/индексы) ----------
    let mut app = Router::new()
        // базовые
        .route("/healthz", get(api::healthz))
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/account/:rid/state", get(api::account_state))
        // отправка транзакций
        .route("/submit_tx",        post(api::submit_tx))
        .route("/submit_tx_batch",  post(api::submit_tx_batch))
        // отладка канона/подписи
        .route("/debug_canon", post(api::debug_canon))
        // faucet (DEV)
        .route("/faucet/:rid/:amount", post(api::faucet))
        // мост
        .route("/bridge/deposit", post(api::bridge_deposit))
        .route("/bridge/redeem",  post(api::bridge_redeem))
        .route("/bridge/verify",  post(api::bridge_verify))
        // админка
        .route("/admin/snapshot",      get(api::snapshot))
        .route("/admin/snapshot-file", get(api::snapshot_file))
        .route("/admin/restore",       post(api::restore))
        .route("/admin/token",         get(api::admin_token))
        .route("/node/info",           get(api::node_info))
        // НОВОЕ: история/индексы
        .route("/block/:height", get(api::get_block))
        .route("/tx/:id",        get(api::get_tx))
        .route("/account/:rid/txs", get(api::account_txs))
        // лимит тела (предохраняемся от больших batch’ей)
        .layer(DefaultBodyLimit::max(64 * 1024))
        .layer(Extension(st.clone()));

    // Фоновая метрика — обновляем chain_height/mempool_len периодически (если у тебя уже есть — оставь свою)
    {
        let stc = st.clone();
        tokio::spawn(async move {
            let mut t = interval(Duration::from_millis(500));
            loop {
                t.tick().await;
                if let Ok((h, _)) = stc.engine.ledger().head() {
                    crate::state::HEIGHT_GAUGE.set(h as i64);
                }
                if let Ok(f) = stc.engine.ledger().get_finalized() {
                    crate::state::FINAL_GAUGE.set(f as i64);
                }
                crate::state::MEMPOOL_GAUGE.set(stc.engine.mempool_len() as i64);
            }
        });
    }

    // --------- запуск сервера ----------
    let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
    println!("LOGOS LRB node listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(async {
            let _ = signal::ctrl_c().await;
            eprintln!("shutdown...");
        })
        .await?;

    Ok(())
}

```


## FILE: node/src/metrics.rs  (size=498b)
```text
use axum::http::{HeaderMap, HeaderValue};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics_handler() -> (HeaderMap, Vec<u8>) {
    let mut buffer = Vec::<u8>::new();
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let mut headers = HeaderMap::new();
    headers.insert(axum::http::header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    (headers, buffer)
}

```


## FILE: node/src/peers.rs  (size=4411b)
```text
use crate::state::now_ms;
use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{collections::HashMap, sync::{Arc, Mutex}, time::Duration};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self { last_seen_ms: now_ms(), score_milli: 0, fails: 0, dups: 0, banned_until_ms: 0 }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self { Self { inner: Arc::new(Mutex::new(HashMap::new())), policy } }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> { self.inner.lock().unwrap() }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 { s.score_milli = 5000; }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli { s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms; }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk).map(|s| now_ms() < s.banned_until_ms).unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 { s.score_milli = 0; }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now { banned += 1; }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop { t.tick().await; book.tick(); }
    });
}

```


## FILE: node/src/state.rs  (size=5557b)
```text
use std::{collections::{HashMap, HashSet}, sync::{Arc, Mutex}, time::{SystemTime, UNIX_EPOCH}};
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::Lazy;
use prometheus::{register_histogram, register_int_counter, register_int_gauge, Histogram, IntCounter, IntGauge};
use reqwest::Client;
use lrb_core::Engine;

pub fn now_ms() -> u128 { SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() }

/* ---- метрики (как у тебя) ---- */
pub static TX_SUBMITTED:    Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_submitted_total","submitted tx").unwrap());
pub static TX_APPLIED:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_applied_total",  "applied tx").unwrap());
pub static GOSSIP_BLK_SENT: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_sent_total","gossip blocks sent").unwrap());
pub static GOSSIP_BLK_RECV: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_recv_total","gossip blocks recv").unwrap());
pub static GOSSIP_VOTE_SENT:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_sent_total","gossip votes sent").unwrap());
pub static GOSSIP_VOTE_RECV:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_recv_total","gossip votes recv").unwrap());
pub static CONS_VOTES:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("consensus_votes_total","accepted consensus votes").unwrap());
pub static HEIGHT_GAUGE:    Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_height","current height").unwrap());
pub static FINAL_GAUGE:     Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_finalized","finalized height").unwrap());
pub static MEMPOOL_GAUGE:   Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("mempool_len","mempool length").unwrap());
pub static SLOT_TXS_GAUGE:  Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("slot_tx_count","tx in last committed block").unwrap());
pub static BR_DEPOSIT:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_deposit_total","bridge deposits").unwrap());
pub static BR_REDEEM:       Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_redeem_total","bridge redeems").unwrap());
pub static PHASE_BLOCK_ACCEPTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_accepted_total","blocks passed phase filter").unwrap());
pub static PHASE_BLOCK_REJECTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_rejected_total","blocks rejected by phase filter").unwrap());
pub static SLOT_LAT_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_latency_ms_hist","slot latency histogram (ms)",
        vec![10.0,25.0,50.0,100.0,250.0,500.0,750.0,1000.0,1500.0,2000.0,3000.0]).unwrap()
});
pub static SLOT_TXS_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_tx_count_hist","tx per block histogram",
        vec![10.0,50.0,100.0,500.0,1000.0,2000.0,5000.0,10000.0,20000.0]).unwrap()
});

/* ---- Anti-replay окно ---- */
#[derive(Default, Clone)]
pub struct ReplayWindow {
    map: Arc<Mutex<HashMap<String,u128>>>,
    pub ttl_ms: u128,
    pub max_items: usize,
}
impl ReplayWindow {
    pub fn new(ttl_ms: u128, max_items: usize) -> Self { Self { map: Arc::new(Mutex::new(HashMap::new())), ttl_ms, max_items } }
    pub fn check_and_note(&self, key: String, ts_ms: u128) -> bool {
        let mut m = self.map.lock().unwrap();
        if m.len() > self.max_items {
            let cutoff = now_ms().saturating_sub(self.ttl_ms);
            m.retain(|_, &mut t| t >= cutoff);
        }
        if let Some(prev) = m.get(&key) { if ts_ms <= *prev + self.ttl_ms { return false; } }
        m.insert(key, ts_ms);
        true
    }
}

/* ---- Токен-бакет ---- */
#[derive(Clone)]
pub struct TokenBucket { inner: Arc<Mutex<BucketInner>>, }
#[derive(Debug)]
struct BucketInner { capacity:u64, tokens:u64, refill_per_ms:f64, last_ms:u128 }
impl TokenBucket {
    pub fn new(capacity:u64, refill_per_sec:u64) -> Self {
        let now = now_ms();
        Self { inner: Arc::new(Mutex::new(BucketInner{
            capacity, tokens: capacity, refill_per_ms: refill_per_sec as f64 / 1000.0, last_ms: now
        })) }
    }
    pub fn try_take(&self, n:u64) -> bool {
        let now = now_ms();
        let mut b = self.inner.lock().unwrap();
        let elapsed = (now - b.last_ms) as f64;
        let refill = (elapsed * b.refill_per_ms) as u64;
        if refill > 0 { b.tokens = (b.tokens + refill).min(b.capacity); b.last_ms = now; }
        if b.tokens >= n { b.tokens -= n; true } else { false }
    }
}

/* ---- AppState ---- */
#[derive(Clone)]
pub struct AppState {
    pub engine: Arc<Engine>,
    pub http: Client,
    pub dev_mode: bool,
    pub peers: Vec<String>,

    pub self_vk: VerifyingKey,
    pub sk: Arc<SigningKey>,

    // gossip/кворум
    pub seen_blocks: Arc<Mutex<HashSet<String>>>,
    pub vote_seen: Arc<Mutex<HashSet<String>>>,
    pub vote_tally: Arc<Mutex<HashMap<(u64,String), HashSet<String>>>>,
    pub validators: Arc<HashSet<String>>,
    pub quorum_n: usize,

    // anti-replay
    pub replay_blk: ReplayWindow,
    pub replay_vote: ReplayWindow,

    // rate-limit
    pub rl_submit: TokenBucket,
    pub rl_admin:  TokenBucket,     // NEW: лимит на админ-ручки

    // peer scoring
    pub peerbook: crate::peers::PeerBook,

    // bridge
    pub rl_bridge: TokenBucket,
    pub replay_bridge: ReplayWindow,
    pub bridge_max_per_tx: u64,
    pub bridge_key: Option<String>,
}

```


## FILE: src/bin/ai_signal_listener.rs  (size=8704b)
```text

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: src/bin/orchestration_control.rs  (size=6987b)
```text
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/rcp_engine.rs  (size=4122b)
```text
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: src/bin/resonance_mesh.rs  (size=8051b)
```text
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/resonance_sync.rs  (size=11282b)
```text
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/sigma_t.rs  (size=3522b)
```text

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: src/core/biosphere_scanner.rs  (size=5196b)
```text
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: src/core/dao.rs  (size=2106b)
```text

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/logos_self.rs  (size=2771b)
```text

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/phase.rs  (size=5790b)
```text

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/resonance.rs  (size=3016b)
```text

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/tx_spam_guard.rs  (size=3175b)
```text

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/lib.rs  (size=921b)
```text

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: src/utils/filters.rs  (size=322b)
```text

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: src/utils/frequency.rs  (size=380b)
```text

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: src/utils/math.rs  (size=394b)
```text

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: src/utils/types.rs  (size=215b)
```text

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: tools/admin_cli.sh  (size=5214b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: tools/go_test/main.go  (size=3201b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: tools/go_test/two_rids.go  (size=3944b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: tools/load/load_submit_tx.go  (size=7096b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: tools/lrb_audit.sh  (size=3026b)
```text
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: tools/test_tx.sh  (size=1841b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: wallet-proxy/app.py  (size=7115b)
```text
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: wallet-proxy/requirements.txt  (size=1147b)
```text
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: wallet-proxy/scanner.py  (size=5538b)
```text
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: www/wallet/index.html  (size=7993b)
```text
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS LRB — Web Wallet</title>
  <style>
    :root{--bg:#0b0e12;--fg:#e8eef4;--muted:#9aa8b3;--card:#121821;--acc:#78e08f;--warn:#e77;--ok:#8f8;--link:#79a6ff}
    *{box-sizing:border-box} body{background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,Arial,sans-serif;margin:0}
    header{padding:18px 20px;background:#0e131a;position:sticky;top:0;border-bottom:1px solid #1f2834}
    h1{margin:0;font-size:18px} a{color:var(--link)} main{max-width:1080px;margin:18px auto;padding:0 16px}
    .grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
    .card{background:var(--card);border:1px solid #1f2834;border-radius:14px;padding:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap} .mono{font-family:ui-monospace,Consolas,monospace}
    label{display:block;margin:6px 0 2px;color:var(--muted)} input,button,select,textarea{background:#0c1219;color:var(--fg);
      border:1px solid #243141;border-radius:10px;padding:9px 10px} input,select,textarea{width:100%}
    button{cursor:pointer} button.primary{background:#112236;border-color:#213f66} button.ok{background:#103418;border-color:#1c5c2b}
    .muted{color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .kvs div{display:flex;justify-content:space-between}
    .kvs div span:first-child{color:var(--muted)} .pill{display:inline-block;border:1px solid #2a394d;padding:2px 8px;border-radius:999px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #1f2834;padding:8px 6px;text-align:left}
    .small{font-size:12px} .right{text-align:right}
    .tabs{display:flex;gap:6px;margin-bottom:8px} .tabs button{padding:6px 10px;border-radius:8px;border:1px solid #2a394d;background:#0d141c}
    .tabs button.active{background:#1a2635}
  </style>
</head>
<body>
  <header><h1>LOGOS LRB — Web Wallet</h1></header>
  <main class="grid">

    <!-- Сеть / нода -->
    <section class="card">
      <h3>Сеть / Нода</h3>
      <label>Node URL</label>
      <input id="nodeUrl" placeholder="http://45.159.248.232:8080"/>
      <div class="row">
        <button id="saveNode" class="primary">Сохранить</button>
        <button id="ping">Проверить /healthz</button>
        <span id="pingRes" class="mono"></span>
      </div>
      <div class="kvs small" style="margin-top:8px">
        <div><span>height</span><span id="headHeight" class="mono">-</span></div>
        <div><span>finalized</span><span id="headFinal" class="mono">-</span></div>
        <div><span>hash</span><span id="headHash" class="mono">-</span></div>
      </div>
    </section>

    <!-- Ключи -->
    <section class="card">
      <h3>Ключи (Ed25519, локально)</h3>
      <div class="row">
        <button id="gen" class="primary">Сгенерировать</button>
        <button id="wipe">Удалить из браузера</button>
      </div>
      <label>RID (base58)</label>
      <div id="rid" class="mono small"></div>
      <label>Публичный ключ (base58)</label>
      <div id="pk58" class="mono small"></div>
      <details style="margin-top:8px"><summary class="muted">Экспорт/импорт</summary>
        <label>Приватный ключ (hex)</label>
        <textarea id="skHex" rows="3" class="mono" placeholder="hex..."></textarea>
        <div class="row"><button id="importSk">Импорт</button><button id="exportSk">Экспорт</button><span id="impRes" class="mono"></span></div>
      </details>
    </section>

    <!-- Состояние -->
    <section class="card">
      <h3>Состояние аккаунта</h3>
      <div class="row"><button id="refreshState">Обновить</button><span id="stateRes" class="mono"></span></div>
      <div class="kvs">
        <div><span>Баланс (μLGN)</span><span id="balance" class="mono">0</span></div>
        <div><span>Nonce</span><span id="nonce" class="mono">0</span></div>
      </div>
    </section>

    <!-- Перевод -->
    <section class="card">
      <div class="tabs"><button id="tabSend" class="active">Перевод</button><button id="tabBatch">Батч</button></div>

      <div id="panelSend">
        <label>Получатель (RID)</label><input id="toRid" placeholder="RID получателя"/>
        <label>Сумма (μLGN)</label><input id="amount" type="number" value="1"/>
        <div class="row"><button id="send" class="ok">Отправить</button><span id="sendRes" class="mono small"></span></div>
      </div>

      <div id="panelBatch" style="display:none">
        <label>Список получателей (по одному RID в строке)</label>
        <textarea id="batchList" rows="6" placeholder="RID1&#10;RID2&#10;..."></textarea>
        <label>Сумма на каждого (μLGN)</label><input id="batchAmount" type="number" value="1"/>
        <label>Размер батча (tx за один запрос)</label><input id="batchSize" type="number" value="50"/>
        <div class="row"><button id="sendBatch" class="ok">Отправить батч</button><span id="batchRes" class="mono small"></span></div>
      </div>
    </section>

    <!-- История / Недавние -->
    <section class="card">
      <h3>История</h3>
      <div class="row"><button id="loadTxs">Загрузить</button><button id="nextTxs">Дальше</button><span id="histRes" class="mono small"></span></div>
      <table id="hist"><thead><tr><th>H</th><th>Tx</th><th>Dir</th><th class="right">Amount</th><th>Counterparty</th></tr></thead><tbody></tbody></table>
    </section>

    <section class="card">
      <h3>Недавние</h3>
      <div class="row"><button id="recentBlocks">Блоки</button><button id="recentTxs">Tx</button><span id="recentRes" class="mono small"></span></div>
      <table id="recent"><thead><tr><th>Тип</th><th>Данные</th></tr></thead><tbody></tbody></table>
    </section>

    <!-- Мост (для операторов/интегратора) -->
    <section class="card">
      <h3>rToken мост (оператор)</h3>
      <label>X-Bridge-Key (или Bearer JWT)</label><input id="bridgeKey" placeholder="введите ключ или JWT (опц.)"/>
      <label>RID</label><input id="bridgeRid" placeholder="RID для зачисления/списания"/>
      <div class="row">
        <div style="flex:1">
          <label>Deposit (μrLGN)</label><input id="depAmount" type="number" value="1000"/>
          <label>ext_txid</label><input id="depExt" placeholder="например, txid внешней сети"/>
          <button id="deposit" class="primary">Deposit</button>
        </div>
        <div style="flex:1">
          <label>Redeem (μrLGN)</label><input id="redAmount" type="number" value="500"/>
          <label>request_id</label><input id="redReq" placeholder="уникальный ID запроса"/>
          <button id="redeem" class="primary">Redeem</button>
        </div>
      </div>
      <div class="small mono" id="bridgeRes"></div>
    </section>

    <!-- Админ-токен -->
    <section class="card">
      <h3>Админ (JWT)</h3>
      <label>X-Admin-Key</label><input id="adminKey" placeholder="только для операторов"/>
      <div class="row"><label class="muted">TTL (сек)</label><input id="adminTtl" type="number" value="600" style="width:120px"/>
        <button id="mintAdminToken">Получить токен</button><span id="adminRes" class="mono small"></span></div>
    </section>

  </main>

  <!-- noble-ed25519 + bs58 CDN -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm"></script>
  <script type="module" src="./wallet.js"></script>
</body>
</html>

```


## FILE: www/wallet/wallet.js  (size=10848b)
```text
import * as ed from "https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm";
import bs58 from "https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm";

/* =============== helpers =============== */
const $ = (id)=>document.getElementById(id);
const enc = new TextEncoder();

const st = {
  node: localStorage.getItem("lrb_node") || "http://45.159.248.232:8080",
  skHex: localStorage.getItem("lrb_sk") || "",
  pkHex: localStorage.getItem("lrb_pk") || "",
  cursor_h: null, cursor_seq: null
};

function ridFromPkHex(pkHex){ return bs58.encode(Buffer.from(pkHex,"hex")); }
function toB64(u8){ return btoa(String.fromCharCode(...u8)); }

function canonicalBytes(from, to, amount, nonce, pkHex) {
  const pk = Buffer.from(pkHex, "hex");
  const a = enc.encode(from), b = enc.encode(to),
        c = enc.encode(String(amount)), d = enc.encode(String(nonce));
  const out = new Uint8Array(a.length+b.length+c.length+d.length+pk.length);
  out.set(a,0); out.set(b,a.length); out.set(c,a.length+b.length);
  out.set(d,a.length+b.length+c.length); out.set(pk,a.length+b.length+c.length+d.length);
  return out;
}

async function getJSON(url, opts={}) {
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}
async function postJSON(url, body, headers={}) {
  const r = await fetch(url, {method:"POST",headers:{'content-type':'application/json',...headers},body:JSON.stringify(body)});
  const t = await r.text();
  try { return { ok:r.ok, status:r.status, body: JSON.parse(t||"{}") }; }
  catch { return { ok:r.ok, status:r.status, body: t }; }
}

/* =============== network / head =============== */
$("nodeUrl").value = st.node;
$("saveNode").onclick = () => { st.node = $("nodeUrl").value.trim(); localStorage.setItem("lrb_node", st.node); alert("Node URL сохранён"); };
$("ping").onclick = async ()=>{
  try {
    const h = await getJSON(`${st.node}/healthz`); $("pingRes").textContent = h.ok?"OK":"ERR";
    const head = await getJSON(`${st.node}/head`);
    $("headHeight").textContent = head.height ?? "-";
    $("headFinal").textContent  = head.finalized ?? "-";
    $("headHash").textContent   = (head.hash||"").slice(0,16)+"…";
  } catch(e){ $("pingRes").textContent = `ERR: ${e.message}`; }
};

/* =============== keys =============== */
function renderKeys(){
  const pkHex = st.pkHex;
  $("pk58").textContent = pkHex? bs58.encode(Buffer.from(pkHex,"hex")) : "";
  $("rid").textContent  = pkHex? ridFromPkHex(pkHex) : "";
  $("skHex").value = st.skHex || "";
}
$("gen").onclick = async ()=>{
  const sk = ed.utils.randomPrivateKey(); const pk = await ed.getPublicKey(sk);
  st.skHex = Buffer.from(sk).toString("hex"); st.pkHex = Buffer.from(pk).toString("hex");
  localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
};
$("wipe").onclick = ()=>{ localStorage.removeItem("lrb_sk"); localStorage.removeItem("lrb_pk"); st.skHex=""; st.pkHex=""; renderKeys(); };
$("importSk").onclick = async ()=>{
  try{
    const val = $("skHex").value.trim(); if(!val) throw new Error("пусто");
    const sk = Buffer.from(val,"hex"); const pk = await ed.getPublicKey(sk);
    st.skHex = val; st.pkHex = Buffer.from(pk).toString("hex");
    localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
    $("impRes").textContent = "OK";
  }catch(e){ $("impRes").textContent = "ERR"; }
};
$("exportSk").onclick = ()=>{ $("skHex").value = st.skHex || ""; };

renderKeys();

/* =============== account state =============== */
$("refreshState").onclick = async ()=>{
  $("stateRes").textContent = "";
  if(!st.pkHex) return $("stateRes").textContent = "Нет ключа";
  try{
    const rid = $("rid").textContent;
    const s = await getJSON(`${st.node}/account/${rid}/state`);
    $("balance").textContent = s.balance ?? 0;
    $("nonce").textContent   = s.nonce ?? 0;
    $("stateRes").textContent = "OK";
  }catch(e){ $("stateRes").textContent = `ERR: ${e.message}`; }
};

/* =============== send / batch =============== */
function nextNonce(){ return (parseInt($("nonce").textContent||"0",10) || 0) + 1; }

$("tabSend").onclick = ()=>{ $("panelSend").style.display="block"; $("panelBatch").style.display="none"; $("tabSend").classList.add("active"); $("tabBatch").classList.remove("active"); };
$("tabBatch").onclick= ()=>{ $("panelSend").style.display="none"; $("panelBatch").style.display="block"; $("tabBatch").classList.add("active"); $("tabSend").classList.remove("active"); };

$("send").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim(), to=$("toRid").value.trim();
    const amount = parseInt($("amount").value||"0",10); if(!to||!amount) throw new Error("проверь поля");
    const nonce = nextNonce();
    const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
    const sig = await ed.sign(canon, st.skHex);
    const item = { from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) };
    const r = await postJSON(`${st.node}/submit_tx_batch`, [item]);
    $("sendRes").textContent = r.ok? `OK accepted=${r.body.accepted||0}` : `ERR ${r.status}`;
    // обновим nonce
    await $("refreshState").onclick();
  }catch(e){ $("sendRes").textContent = `ERR: ${e.message}`; }
};

$("sendBatch").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim();
    const list = $("batchList").value.split("\n").map(s=>s.trim()).filter(Boolean);
    const amount = parseInt($("batchAmount").value||"0",10);
    const batchSize = parseInt($("batchSize").value||"50",10);
    if(list.length===0 || !amount) throw new Error("укажи получателей и сумму");
    let nonce = nextNonce(), accepted=0, sent=0;
    for(let i=0;i<list.length;i+=batchSize){
      const chunk = list.slice(i,i+batchSize);
      const req = [];
      for(const to of chunk){
        const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
        const sig   = await ed.sign(canon, st.skHex);
        req.push({ from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) });
        nonce++;
      }
      const r = await postJSON(`${st.node}/submit_tx_batch`, req);
      sent += req.length; if(r.ok) accepted += (r.body.accepted||0);
      $("batchRes").textContent = `sent=${sent} accepted=${accepted}`;
    }
    await $("refreshState").onclick();
  }catch(e){ $("batchRes").textContent = `ERR: ${e.message}`; }
};

/* =============== history / recent =============== */
async function loadAccountTxs(next=false){
  try{
    const rid = $("rid").textContent.trim(), params=[];
    params.push(`limit=20`);
    if(next && st.cursor_h!=null && st.cursor_seq!=null){
      params.push(`cursor_h=${st.cursor_h}`); params.push(`cursor_seq=${st.cursor_seq}`);
    }
    const url = `${st.node}/account/${rid}/txs?`+params.join("&");
    const r = await getJSON(url);
    const tbody = $("hist").querySelector("tbody");
    if(!next) tbody.innerHTML="";
    for(const it of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="mono small">${it.height??""}</td>
                      <td class="mono small">${(it.tx_id||"").slice(0,12)}…</td>
                      <td>${it.dir==-1?"→":"←"}</td>
                      <td class="right mono">${it.amount??0}</td>
                      <td class="mono small">${(it.counterparty||"").slice(0,10)}…</td>`;
      tbody.appendChild(tr);
    }
    st.cursor_h = r.next_cursor_h ?? null;
    st.cursor_seq = r.next_cursor_seq ?? null;
    $("histRes").textContent = r.items?.length ? "OK" : "—";
  }catch(e){ $("histRes").textContent = `ERR: ${e.message}`; }
}
$("loadTxs").onclick = ()=>loadAccountTxs(false);
$("nextTxs").onclick = ()=>loadAccountTxs(true);

$("recentBlocks").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/blocks?limit=10`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const b of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Block</td><td class="mono small">h=${b.height} tx=${(b.txs||[]).length} hash=${(b.block_hash||"").slice(0,14)}…</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};
$("recentTxs").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/txs?limit=20`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const t of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Tx</td><td class="mono small">h=${t.height} tx=${(t.tx_id||"").slice(0,12)}… ${t.from?.slice(0,8)}→${t.to?.slice(0,8)} a=${t.amount}</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};

/* =============== bridge (operator) =============== */
function authHeader(val){
  const s = (val||"").trim(); if(!s) return {};
  // Если строка похожа на JWT — отправим как Bearer, иначе X-Bridge-Key
  return s.split(".").length===3 ? {Authorization:`Bearer ${s}`} : {"X-Bridge-Key": s};
}
$("deposit").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("depAmount").value||"0",10), ext = $("depExt").value.trim();
  const r = await postJSON(`${st.node}/bridge/deposit`, {rid,amount,ext_txid:ext}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `deposit OK: r_balance=${r.body.r_balance}` : `ERR ${r.status}`;
};
$("redeem").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("redAmount").value||"0",10), req = $("redReq").value.trim();
  const r = await postJSON(`${st.node}/bridge/redeem`, {rid,amount,request_id:req}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `redeem OK: ticket=${r.body.redeem_ticket.slice(0,18)}…` : `ERR ${r.status}`;
};

/* =============== admin JWT =============== */
$("mintAdminToken").onclick = async ()=>{
  const key = $("adminKey").value.trim(), ttl = parseInt($("adminTtl").value||"600",10);
  const r = await fetch(`${st.node}/admin/token?ttl=${ttl}`, {headers: {"X-Admin-Key": key}});
  const body = await r.json().catch(()=>({}));
  $("adminRes").textContent = r.ok ? `OK token=${(body.token||"").slice(0,16)}…` : `ERR ${r.status}`;
};

/* =============== init =============== */
(async()=>{ await $("ping").onclick(); if(st.pkHex) await $("refreshState").onclick(); })();

```

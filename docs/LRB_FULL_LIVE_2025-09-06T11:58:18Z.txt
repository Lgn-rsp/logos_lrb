# FULL LIVE SNAPSHOT — 2025-09-06T11:58:18Z
# sources: /root/logos_lrb + infra (/etc, /opt)
# size limit per file: 2000000 bytes


## FILE: /root/logos_lrb/Cargo.toml  (size=713b)
```
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```

## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/genesis.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
```
# LOGOS node (пример ENV)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_SLOT_MS=500
LRB_MAX_BLOCK_TX=10000
LRB_MEMPOOL_CAP=100000
LRB_MAX_AMOUNT=18446744073709551615
LRB_BRIDGE_MAX_PER_TX=10000000

# Секреты — задаются ТОЛЬКО вне репозитория:
# LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
# LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=<optional>

```

## FILE: /root/logos_lrb/configs/logos_config.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
```
# Wallet Proxy / Scanner (пример ENV)
# !!! НЕ коммить настоящие ключи/приватники !!!
ETH_PROVIDER_URL=https://mainnet.infura.io/v3/XXXX...
USDT_CONTRACT=0xdAC17F958D2ee523a2206206994597C13D831ec7

# hot-кошелёк оператора (для withdraw/fee)
HOT_WALLET_ADDRESS=0x...
HOT_WALLET_PRIVATE_KEY= # НЕ класть в git, подставлять только в прод окружении

```

## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=3062b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки ---
    add_header X-Frame-Options        SAMEORIGIN       always;
    add_header X-Content-Type-Options nosniff          always;
    add_header Referrer-Policy        strict-origin-when-cross-origin always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # CSP: только self, без inline/CDN. Разрешаем data: для иконок/картинок в UI.
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
```
# Пример (НЕ БОЕВОЙ! замените на свои)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=   # задаётся опционально

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service  (size=369b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```

## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```

## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```

## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1617b)
```
// Безопасный AEAD: XChaCha20-Poly1305 с уникальным nonce.
// Формат шифротекста: [24-байт nonce || ciphertext+tag]

use anyhow::Result;
use chacha20poly1305::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Key, XChaCha20Poly1305, XNonce,
};

pub struct AeadBox {
    key: Key,
}

impl AeadBox {
    pub fn from_key(key_bytes: &[u8; 32]) -> Self {
        let key = Key::from_slice(key_bytes);
        Self { key: *key }
    }

    pub fn seal(&self, aad: &[u8], plaintext: &[u8]) -> Vec<u8> {
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XChaCha20Poly1305::generate_nonce(&mut OsRng); // 24 байта
        let mut out = Vec::with_capacity(24 + plaintext.len() + 16);
        out.extend_from_slice(&nonce);
        let ct = cipher
            .encrypt(
                &nonce,
                chacha20poly1305::aead::Payload {
                    msg: plaintext,
                    aad,
                },
            )
            .expect("AEAD encrypt failed");
        out.extend_from_slice(&ct);
        out
    }

    pub fn open(&self, aad: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 24 + 16 {
            anyhow::bail!("AEAD: buffer too short");
        }
        let (nonce_bytes, ct) = data.split_at(24);
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XNonce::from_slice(nonce_bytes);
        let pt = cipher
            .decrypt(nonce, chacha20poly1305::aead::Payload { msg: ct, aad })
            .map_err(|_| anyhow::anyhow!("AEAD decrypt failed"))?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=12177b)
```
use crate::types::*;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sled::{Db, IVec, Tree};
use std::convert::TryInto;
use std::path::Path;

// key helpers
fn be64(v: u64) -> [u8; 8] {
    v.to_be_bytes()
}
fn be32(v: u32) -> [u8; 4] {
    v.to_be_bytes()
}
fn rid_str(r: &Rid) -> &str {
    &r.0
}

#[derive(Clone)]
pub struct Ledger {
    #[allow(dead_code)]
    db: Db,

    // balances
    lg_tree: Tree,   // rid -> u64 (BE)
    rlgn_tree: Tree, // rid -> u64 (BE)
    head_tree: Tree, // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree: db.open_tree("lgn")?,
            rlgn_tree: db.open_tree("rlgn")?,
            head_tree: db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree: db.open_tree("txs")?,
            acct_tree: db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self
            .head_tree
            .get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self
            .head_tree
            .get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self
            .head_tree
            .get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(
        &self,
        height: u64,
        hash: &str,
        ts_ms: u128,
        txs: &[Tx],
    ) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx {
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to: rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce: tx.nonce,
                height,
                index: i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1 + txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1 + 8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock {
            height,
            hash: hash.to_string(),
            ts_ms,
            tx_ids: ids,
        };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1 + 8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self
            .blocks_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredBlock>(&v))
            .transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1 + txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self
            .tx_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredTx>(&v))
            .transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(
        &self,
        rid: &str,
        limit: usize,
        cursor: Option<String>,
    ) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a");
            k.extend_from_slice(rid.as_bytes());
            k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage {
            rid: rid.to_string(),
            items,
            next_cursor,
        })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? {
            return Ok(false);
        }
        self.head_tree
            .insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        if cur < amt {
            anyhow::bail!("insufficient rLGN");
        }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k = rid_str(&tx.to).as_bytes();

            let from_bal = self
                .lg_tree
                .get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);
            if from_bal < tx.amount {
                anyhow::bail!("insufficient funds");
            }
            let to_bal = self
                .lg_tree
                .get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k, &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h {
                Ok(BlockHeaderView {
                    block_hash: head_hash,
                })
            } else {
                anyhow::bail!("block not found")
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=727b)
```
/*!
 * LOGOS LRB — core crate
 * Экспорт модулей ядра L1: типы, консенсус, мемпул/баланс, резонанс, сигналы, защита.
 * Здесь только декларация модулей — реализация в соответствующих *.rs файлах.
 */

pub mod types;

pub mod anti_replay;
pub mod beacon;
pub mod heartbeat;

pub mod dynamic_balance;
pub mod spam_guard;

pub mod phase_consensus;
pub mod phase_filters;
pub mod phase_integrity;
pub mod quorum;
pub mod sigpool;

pub mod ledger;
pub mod rcp_engine;
pub mod resonance;

// Безопасный AEAD (XChaCha20-Poly1305) — общий хелпер для модулей
pub mod crypto;

```

## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=1806b)
```
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize {
        self.quorum_n
    }
    pub fn finalized(&self) -> u64 {
        self.finalized_h
    }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes
            .get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_filters.rs  (size=1780b)
```
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN")
        .ok()
        .map(|v| v == "1")
        .unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',')
        .filter_map(|s| s.trim().parse::<f64>().ok())
        .collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE")
        .ok()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() {
        return 1.0;
    }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() {
        return true;
    }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=553b)
```
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig)
        .map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=1250b)
```
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk =
        VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(
        &sig_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("bad sig"))?,
    );

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig)
        .map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=7224b)
```
use crate::sigpool::filter_valid_sigs_parallel;
use crate::{dynamic_balance::DynamicBalance, ledger::Ledger, spam_guard::SpamGuard, types::*};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use anyhow::Result;
use std::{
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{
    broadcast,
    mpsc::{unbounded_channel, UnboundedSender},
};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount = env_u64("LRB_MAX_AMOUNT", u64::MAX / 2);
        let slot_ms = env_u64("LRB_SLOT_MS", 500);
        let quorum_n = env_usize("LRB_QUORUM_N", 1);
        let sig_workers = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> {
        self.ledger.clone()
    }
    pub fn proposer(&self) -> Rid {
        self.proposer.clone()
    }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) {
        *self.commit_tx.lock().unwrap() = Some(sender);
    }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> {
        self.guard.check_amount(amount)
    }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> {
        self.mempool_tx.clone()
    }
    pub fn mempool_len(&self) -> usize {
        self.mempool.lock().unwrap().len()
    }
    pub fn finalized_height(&self) -> u64 {
        self.consensus.lock().unwrap().finalized()
    }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() {
                    continue;
                }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() {
                continue;
            }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() {
                continue;
            }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```

## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```

## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```

## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=3363b)
```
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String, // blake3 of canonical form
    pub from: Rid,  // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>, // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,  // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 {
            return Err(anyhow!("bad pubkey len"));
        }
        if self.signature.len() != 64 {
            return Err(anyhow!("bad signature len"));
        }
        if self.amount == 0 {
            return Err(anyhow!("amount must be > 0"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```

## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
```
use axum::{
    extract::State,
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, time::Duration};
use tower::{ServiceBuilder};
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
    timeout::TimeoutLayer,
    limit::{RequestBodyLimitLayer},
};
use tracing_subscriber::{EnvFilter, fmt};
use ed25519_dalek::{SigningKey, VerifyingKey, SignatureError};
use rand_core::OsRng;
use bs58;
use once_cell::sync::OnceCell;
use anyhow::Result;

mod api;
mod admin;
mod bridge;
mod gossip;
mod state;
mod peers;
mod fork;

#[derive(Clone)]
struct AppState {
    signing: SigningKey,
    verifying: VerifyingKey,
    rid_b58: String,
    admin_key: String,
    bridge_key: String,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(bytes.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(data.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}

fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}

fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!("missing env {}", n))?;
    Ok(v)
}

fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY","CHANGE_ME","", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys + env
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid = rid_from_vk(&vk);

    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid.clone(),
        admin_key,
        bridge_key,
    };
    APP_STATE.set(state.clone()).unwrap();

    // CORS
    let cors = {
        let allowed_origin = std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| String::from("https://wallet.example"));
        CorsLayer::new()
            .allow_origin(allowed_origin.parse::<axum::http::HeaderValue>().unwrap())
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([axum::http::header::CONTENT_TYPE, axum::http::header::AUTHORIZATION])
    };

    // limits/timeout
    let layers = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(RequestBodyLimitLayer::new(512 * 1024)) // 512 KiB
        .layer(cors)
        .into_inner();

    // маршруты
    let app = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet)) // dev-only
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify))
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .with_state(state)
        .layer(layers);

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```

## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=1719b)
```
//! Точка-точка фазовая связка: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseLink {
    aead: AeadBox,
    self_vk: VerifyingKey,
    peer_vk: VerifyingKey,
}

impl PhaseLink {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey, peer_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk, peer_vk }
    }

    pub fn encode(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_link: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_link: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```

## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```

## FILE: /root/logos_lrb/modules/__pycache__/env_impact_tracker.cpython-312.pyc  (size=8808b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/resonance_tutor.cpython-312.pyc  (size=9982b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/symbolic_parser.cpython-312.pyc  (size=6942b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```

## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```

## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```

## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```

## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```

## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/node/src/admin.rs  (size=1627b)
```
//! Админ-ручки: snapshot/restore и node_info.
//! Доступ защищается через заголовок X-Admin-Key = LRB_ADMIN_KEY.

use crate::AppState;
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

fn check_admin(st: &AppState, headers: &axum::http::HeaderMap) -> Result<(), StatusCode> {
    let got = headers
        .get("X-Admin-Key")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    if got == st.admin_key {
        Ok(())
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub height: u64,
    pub finalized: bool,
}

pub async fn node_info(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<NodeInfo>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(NodeInfo {
        rid: st.rid_b58.clone(),
        height: 0,
        finalized: false,
    }))
}

#[derive(Serialize)]
pub struct SnapshotResp {
    pub status: &'static str,
}

pub async fn snapshot(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

#[derive(Deserialize)]
#[allow(dead_code)]
pub struct RestoreReq {
    #[serde(default)]
    pub path: String,
}

pub async fn restore(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(_req): Json<RestoreReq>,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

```

## FILE: /root/logos_lrb/node/src/api.rs  (size=10642b)
```
use axum::{extract::{Path, Query, State}, http::StatusCode, Json};
use hex;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::metrics::{inc_total, Timer};
use crate::storage::TxIn;
use crate::AppState;

use bs58;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use parking_lot::Mutex;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

/* ========= liveness / readiness ========= */
#[derive(Serialize)] pub struct Healthz{ pub status: &'static str }
pub async fn healthz()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn livez()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn readyz(State(_st):State<AppState>)->Result<Json<Healthz>,StatusCode>{
    let t=Timer::new("/readyz","GET"); inc_total("/readyz","GET",StatusCode::OK); t.observe(); Ok(Json(Healthz{status:"ready"}))
}

/* ========= helpers ========= */
#[derive(Serialize,Deserialize,Clone)]
struct CanonTx<'a>{ from:&'a str,to:&'a str,amount:u64,nonce:u64 }
fn canon_bytes(tx:&TxIn)->Result<Vec<u8>,StatusCode>{
    let c=CanonTx{from:&tx.from,to:&tx.to,amount:tx.amount,nonce:tx.nonce};
    serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)
}
fn vk_from_rid(rid:&str)->Result<VerifyingKey,StatusCode>{
    let b=bs58::decode(rid).into_vec().map_err(|_|StatusCode::BAD_REQUEST)?; if b.len()!=32 {return Err(StatusCode::BAD_REQUEST);}
    VerifyingKey::from_bytes(b.as_slice().try_into().unwrap()).map_err(|_|StatusCode::BAD_REQUEST)
}
fn sig_from_hex(h:&str)->Result<Signature,StatusCode>{
    let raw=hex::decode(h).map_err(|_|StatusCode::BAD_REQUEST)?; let arr:[u8;64]=raw.as_slice().try_into().map_err(|_|StatusCode::BAD_REQUEST)?;
    Ok(Signature::from_bytes(&arr))
}

/* ========= head / balance ========= */
#[derive(Serialize)] pub struct HeadResp{ pub height:u64, pub finalized:bool }
pub async fn head(State(st):State<AppState>)->Json<HeadResp>{
    let t=Timer::new("/head","GET"); let h=st.store.get_height().unwrap_or(0); inc_total("/head","GET",StatusCode::OK); t.observe();
    Json(HeadResp{height:h,finalized:false})
}
#[derive(Serialize)] pub struct BalanceResp{ pub rid:String, pub balance:u64, pub nonce:u64 }
pub async fn balance(State(st):State<AppState>,Path(rid):Path<String>)->Json<BalanceResp>{
    let t=Timer::new("/balance/:rid","GET"); let a=st.store.get_account(&rid).unwrap_or_default(); inc_total("/balance/:rid","GET",StatusCode::OK); t.observe();
    Json(BalanceResp{rid, balance:a.balance, nonce:a.nonce})
}

/* ========= history / block ========= */
#[derive(Deserialize)] pub struct HistoryQuery{ #[serde(default)] pub from:u64, #[serde(default="def_limit")] pub limit:usize }
fn def_limit()->usize{20}
#[derive(Serialize)] pub struct HistoryResp{ pub rid:String, pub from:u64, pub limit:usize, pub next_from:Option<u64>, pub items:Vec<crate::storage::HistoryItem> }
pub async fn history(State(st):State<AppState>, Path(rid):Path<String>, Query(q):Query<HistoryQuery>)->Result<Json<HistoryResp>,StatusCode>{
    let t=Timer::new("/history/:rid","GET");
    let (items,next_from)=st.store.history_page(&rid,q.from,q.limit.min(1000)).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/history/:rid","GET",StatusCode::OK); t.observe();
    Ok(Json(HistoryResp{rid,from:q.from,limit:q.limit,next_from,items}))
}
#[derive(Serialize)] pub struct BlockResp{ pub height:u64,pub ts_ms:u64,pub txs:Vec<TxIn> }
pub async fn block(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<BlockResp>,StatusCode>{
    let t=Timer::new("/block/:height","GET"); let br=st.store.get_block(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; let br=br.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height","GET",StatusCode::OK); t.observe(); Ok(Json(BlockResp{height:br.height, ts_ms:br.ts_ms, txs:br.txs}))
}

/* ========= block mix (PhaseMix v1) ========= */
#[derive(Serialize)] pub struct MixResp{ pub height:u64, pub ts_ms:u64, pub deltas:Vec<(String,i128)> }
pub async fn block_mix(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<MixResp>,StatusCode>{
    let t=Timer::new("/block/:height/mix","GET");
    let m = st.store.get_mix(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    let m = m.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height/mix","GET",StatusCode::OK); t.observe();
    Ok(Json(MixResp{height:m.height, ts_ms:m.ts_ms, deltas:m.deltas}))
}

/* ========= submit_tx / batch ========= */
#[derive(Deserialize)] pub struct SubmitTxBatchReq{ #[serde(default)] pub txs:Vec<TxIn> }
#[derive(Serialize)]   pub struct TxResult{ pub idx:usize, pub status:&'static str, pub code:u16, pub reason:&'static str }
#[derive(Serialize)]   pub struct SubmitTxBatchResp{ pub accepted:usize, pub rejected:usize, pub new_height:u64, pub results:Vec<TxResult> }

pub async fn submit_tx_batch(State(st):State<AppState>, Json(req):Json<SubmitTxBatchReq>)
 -> Result<Json<SubmitTxBatchResp>,StatusCode>{
    let t=Timer::new("/submit_tx_batch","POST");
    if req.txs.is_empty(){ inc_total("/submit_tx_batch","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST); }
    let mut by_sender:BTreeMap<String,Vec<(usize,TxIn)>>=BTreeMap::new();
    for (i,tx) in req.txs.into_iter().enumerate(){ by_sender.entry(tx.from.clone()).or_default().push((i,tx)); }
    let mut results=Vec::new(); let mut acc_total=0usize; let mut rej_total=0usize; let mut last_h=st.store.get_height().unwrap_or(0);
    let mut cache:HashMap<String, crate::storage::AccountState>=HashMap::new();
    for (from,mut items) in by_sender.into_iter() {
        items.sort_by_key(|(_,tx)| tx.nonce);
        let lk = st.locks.entry(from.clone()).or_insert_with(||Arc::new(Mutex::new(()))).clone();
        let _g = lk.lock();
        let mut next = st.store.get_account(&from).unwrap_or_default().nonce;
        let mut valid:Vec<TxIn>=Vec::new();
        for (idx,tx) in items.into_iter(){
            let vk = match vk_from_rid(&tx.from){ Ok(v)=>v, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_rid"}); continue; } };
            let sig= match sig_from_hex(&tx.sig_hex){ Ok(s)=>s, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; } };
            let msg= match canon_bytes(&tx){ Ok(m)=>m, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_canon"}); continue; } };
            if vk.verify(&msg,&sig).is_err(){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; }
            if tx.nonce != next.saturating_add(1){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:409,reason:"bad_nonce"}); continue; }
            let fs = cache.get(&tx.from).cloned().unwrap_or_else(|| st.store.get_account(&tx.from).unwrap_or_default());
            let ts = cache.get(&tx.to).cloned().unwrap_or_else(|| st.store.get_account(&tx.to).unwrap_or_default());
            if tx.from != tx.to && fs.balance < tx.amount { rej_total+=1; results.push(TxResult{idx,status:"rejected",code:402,reason:"insufficient_funds"}); continue; }
            // simulate in cache
            let mut nf=fs; let mut nt=ts; next = next.saturating_add(1); nf.nonce = next;
            if tx.from != tx.to { nf.balance = nf.balance.saturating_sub(tx.amount); nt.balance = nt.balance.saturating_add(tx.amount); }
            cache.insert(tx.from.clone(), nf); cache.insert(tx.to.clone(), nt);
            valid.push(tx); acc_total+=1; results.push(TxResult{idx,status:"accepted",code:0,reason:"ok"});
        }
        if !valid.is_empty(){ last_h = st.store.apply_batch(&valid).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; }
    }
    let resp=SubmitTxBatchResp{accepted:acc_total,rejected:rej_total,new_height:last_h,results};
    inc_total("/submit_tx_batch","POST",StatusCode::OK); t.observe(); Ok(Json(resp))
}
#[inline] fn inc_tx_err(){}

/* ========= одиночная submit_tx ========= */
#[derive(Deserialize)] pub struct SubmitTxReq{ #[serde(default)] pub _payload:serde_json::Value }
#[derive(Serialize)]   pub struct SubmitTxResp{ pub status:&'static str }
pub async fn submit_tx(State(_st):State<AppState>, Json(_req):Json<SubmitTxReq>) -> Result<Json<SubmitTxResp>,StatusCode>{
    let t=Timer::new("/submit_tx","POST"); inc_total("/submit_tx","POST",StatusCode::OK); t.observe(); Ok(Json(SubmitTxResp{status:"accepted"}))
}

/* ========= debug_canon ========= */
#[derive(Deserialize)] pub struct DebugCanonReq{ #[serde(default)] pub tx:serde_json::Value }
#[derive(Serialize)]   pub struct DebugCanonResp{ pub canon_hex:String }
pub async fn debug_canon(Json(req):Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>,StatusCode>{
    let t=Timer::new("/debug_canon","POST");
    let from=req.tx.get("from").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let to  =req.tx.get("to").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let amount=req.tx.get("amount").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let nonce =req.tx.get("nonce").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let c=CanonTx{from,to,amount,nonce}; let bytes=serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)?;
    let canon_hex=hex::encode(bytes);
    inc_total("/debug_canon","POST",StatusCode::OK); t.observe(); Ok(Json(DebugCanonResp{canon_hex}))
}

/* ========= faucet (DEV) ========= */
#[derive(Deserialize)] pub struct FaucetReq{ #[serde(default)] pub rid:String, #[serde(default)] pub amount:u64 }
#[derive(Serialize)]   pub struct FaucetResp{ pub granted:u64, pub rid:String }
pub async fn faucet(State(st):State<AppState>, Json(req):Json<FaucetReq>) -> Result<Json<FaucetResp>,StatusCode>{
    if std::env::var("LRB_ENABLE_FAUCET").ok().as_deref()!=Some("1"){ return Err(StatusCode::FORBIDDEN); }
    let t=Timer::new("/faucet","POST");
    if req.rid.is_empty() || req.amount==0 { inc_total("/faucet","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST);}
    let _st = st.store.faucet(&req.rid, req.amount).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/faucet","POST",StatusCode::OK); t.observe(); Ok(Json(FaucetResp{granted:req.amount, rid:req.rid}))
}

/* ========= economy ========= */
#[derive(Serialize)] pub struct EconomyResp{ pub cap:u64, pub minted:u64, pub burned:u64, pub supply:u64 }
pub async fn economy(State(st):State<AppState>) -> Result<Json<EconomyResp>,StatusCode>{
    let snap = st.store.economy_snapshot().map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(EconomyResp{cap:snap.cap, minted:snap.minted, burned:snap.burned, supply:snap.supply}))
}

```

## FILE: /root/logos_lrb/node/src/auth.rs  (size=5131b)
```
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```

## FILE: /root/logos_lrb/node/src/bin/aead_selftest.rs  (size=1723b)
```
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use lrb_core::crypto::AeadBox;
use rand_core::{OsRng, RngCore};

fn main() {
    // 1) Ed25519: ключи + подпись/проверка
    let sk = SigningKey::generate(&mut OsRng);
    let vk = VerifyingKey::from(&sk);
    let msg = b"resonance-test-message";
    let sig = sk.sign(msg);
    assert!(vk.verify_strict(msg, &sig).is_ok(), "ed25519 verify failed");

    // 2) AEAD: XChaCha20-Poly1305, уникальный nonce внутри AeadBox
    let mut key32 = [0u8; 32];
    OsRng.fill_bytes(&mut key32);
    let aead = AeadBox::from_key(&key32);

    let aad = b"topic:external-phase|self-vk";
    let pt = "hello, Σ(t)!".as_bytes();

    let ct = aead.seal(aad, pt);
    let dec = aead.open(aad, &ct).expect("aead open failed");
    assert_eq!(dec.as_slice(), pt, "aead roundtrip mismatch");

    // 3) Негатив: порча шифротекста → ошибка
    let mut ct_bad = ct.clone();
    if let Some(last) = ct_bad.last_mut() {
        *last ^= 0xFF; // безопасно мутируем последний байт без двух заимствований
    }
    assert!(aead.open(aad, &ct_bad).is_err(), "aead must fail on tamper");

    // 4) Негатив: смена AAD → ошибка
    let aad_bad = b"topic:changed";
    assert!(
        aead.open(aad_bad, &ct).is_err(),
        "aead must fail on wrong AAD"
    );

    // 5) Подпись поверх шифротекста (seal-then-sign)
    let sig_ct = sk.sign(&ct);
    assert!(
        vk.verify_strict(&ct, &sig_ct).is_ok(),
        "sign(sealed) verify failed"
    );

    println!("OK: ed25519 + AeadBox(XChaCha20-Poly1305) self-test passed");
}

```

## FILE: /root/logos_lrb/node/src/bridge.rs  (size=4870b)
```
//! Bridge: rToken deposit/redeem/verify — prod-ready (single-node, idempotent).
//! Требует корректного X-Bridge-Key (см. LRB_BRIDGE_KEY).
//! Идемпотентность по внешнему ключу квитанции/билета через ledger.bridge_seen_mark().

use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

use crate::{AppState, auth::require_bridge};
use lrb_core::types::Rid;

#[derive(Deserialize)]
pub struct DepositReq {
    /// RID получателя в LOGOS (base58 от pubkey)
    pub rid: String,
    /// Сумма в rLGN
    pub amount: u64,
    /// Внешний уникальный id транзакции/квитанции (например, txid из ETH)
    pub ext_txid: String,
}

#[derive(Serialize)]
pub struct DepositResp {
    pub status: &'static str,
    pub rid: String,
    pub credited: u64,
    pub ext_txid: String,
}

pub async fn deposit(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<DepositReq>,
) -> Result<Json<DepositResp>, StatusCode> {
    require_bridge(&headers)?;

    if req.amount == 0 || req.rid.trim().is_empty() || req.ext_txid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Идемпотентность внешней транзакции
    let rk = format!("deposit:{}", req.ext_txid.trim());
    if !st.ledger.bridge_seen_mark(&rk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(DepositResp {
            status: "ok_repeat",
            rid: req.rid,
            credited: req.amount,
            ext_txid: req.ext_txid,
        }));
    }

    // Минтим rLGN
    let rid = Rid(req.rid.clone());
    st.ledger.mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(DepositResp {
        status: "ok",
        rid: req.rid,
        credited: req.amount,
        ext_txid: req.ext_txid,
    }))
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub rid: String,
    pub amount: u64,
    /// Целевая цепь (например, "ETH")
    #[serde(default)]
    pub target_chain: String,
    /// Адрес в целевой цепи
    #[serde(default)]
    pub target_address: String,
}

#[derive(Serialize)]
pub struct RedeemResp {
    pub status: &'static str,
    pub rid: String,
    pub debited: u64,
    /// Билет на вывод во внешней сети (используется оффчейн-исполнителем)
    pub redeem_ticket: String,
    pub target_chain: String,
    pub target_address: String,
}

pub async fn redeem(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<RedeemReq>,
) -> Result<Json<RedeemResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.amount == 0 || req.rid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Детерминированный билет — для идемпотентности и трекинга
    let redeem_ticket = format!(
        "redeem:{}:{}:{}:{}",
        req.rid.trim(),
        req.amount,
        req.target_chain.trim(),
        req.target_address.trim()
    );

    // Если билет уже «виден» — повтор
    if !st.ledger.bridge_seen_mark(&redeem_ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(RedeemResp {
            status: "ok_repeat",
            rid: req.rid,
            debited: req.amount,
            redeem_ticket,
            target_chain: req.target_chain,
            target_address: req.target_address,
        }));
    }

    // Сжигаем rLGN под вывод (если баланса не хватит — вернётся 400)
    let rid = Rid(req.rid.clone());
    st.ledger.burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;

    Ok(Json(RedeemResp {
        status: "ok",
        rid: req.rid,
        debited: req.amount,
        redeem_ticket,
        target_chain: req.target_chain,
        target_address: req.target_address,
    }))
}

#[derive(Deserialize)]
pub struct VerifyReq {
    pub ticket: String,
}

#[derive(Serialize)]
pub struct VerifyResp {
    pub status: &'static str,
    pub ok: bool,
    pub ticket: String,
}

pub async fn verify(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<VerifyReq>,
) -> Result<Json<VerifyResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.ticket.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Первая попытка помечает — ok:false; повтор — ok:true
    let existed = !st.ledger.bridge_seen_mark(&req.ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(VerifyResp { status: "ok", ok: existed, ticket: req.ticket }))
}

```

## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```

## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```

## FILE: /root/logos_lrb/node/src/guard.rs  (size=4933b)
```
//! Guard & Rate-Limit (prod) для Axum 0.7:
//! - Admin IP ACL (CIDR allowlist) через from_fn_with_state.
//! - Per-IP rate-limit (token bucket) с bypass по путям и по CIDR.
//! - PATH_BYPASS: /healthz, /livez, /readyz, /metrics, /openapi.json.

use axum::response::IntoResponse;  // ← ДОБАВИТЬ ЭТУ СТРОКУ
use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use dashmap::DashMap;
use ipnet::IpNet;
use parking_lot::Mutex;
use std::{
    net::{IpAddr, SocketAddr},
    str::FromStr,
    sync::Arc,
};
use tokio::time::Instant;

/// Пути, которые никогда не ограничиваются лимитером.
const PATH_BYPASS: &[&str] = &[
    "/healthz",
    "/livez",
    "/readyz",
    "/metrics",
    "/openapi.json",
];

/// ===== Admin IP ACL (используем from_fn_with_state) =====
pub async fn admin_ip_gate(
    State(allow): State<Arc<Vec<IpNet>>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    let Some(ip) = client_ip(&req) else {
        return StatusCode::FORBIDDEN.into_response();
    };
    if ip_in_allowlist(ip, &allow) {
        next.run(req).await
    } else {
        StatusCode::FORBIDDEN.into_response()
    }
}

/// ===== Rate Limiter (token bucket per IP) =====
pub struct RateLimiter {
    qps: f64,
    burst: f64,
    /// подсети, которым разрешён обход лимитера
    pub bypass: Arc<Vec<IpNet>>,
    buckets: DashMap<IpAddr, Mutex<TokenBucket>>,
}

struct TokenBucket {
    tokens: f64,
    last: Instant,
}

impl RateLimiter {
    pub fn new(qps: u64, burst: u64, bypass: Arc<Vec<IpNet>>) -> Self {
        let qps = qps as f64;
        let burst = if burst > 0 { burst as f64 } else { qps.max(1.0) * 2.0 };
        Self {
            qps,
            burst,
            bypass,
            buckets: DashMap::new(),
        }
    }

    /// true если IP клиента входит в bypass CIDR
    fn is_bypass(&self, req: &Request<Body>) -> bool {
        if let Some(ip) = client_ip(req) {
            return ip_in_allowlist(ip, &self.bypass);
        }
        false
    }

    /// Проверка и списание токена. false → 429.
    fn check(&self, req: &Request<Body>) -> bool {
        if self.qps <= 0.0 {
            return true;
        }
        let Some(ip) = client_ip(req) else { return false; };

        let entry = self
            .buckets
            .entry(ip)
            .or_insert_with(|| Mutex::new(TokenBucket { tokens: self.burst, last: Instant::now() }));
        let mut tb = entry.lock();

        // refill
        let now = Instant::now();
        let elapsed = now.saturating_duration_since(tb.last).as_secs_f64();
        if elapsed > 0.0 {
            tb.tokens = (tb.tokens + self.qps * elapsed).min(self.burst);
            tb.last = now;
        }

        if tb.tokens >= 1.0 {
            tb.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

/// Axum 0.7 middleware: rate-limit с bypass по путям и CIDR (from_fn_with_state).
pub async fn rate_limit_ip_gate(
    State(limiter): State<Arc<RateLimiter>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    // 1) Allowlist путей
    let path = req.uri().path();
    if PATH_BYPASS.iter().any(|p| *p == path) {
        return next.run(req).await;
    }

    // 2) CIDR bypass (напр., 127.0.0.1/32,::1/128)
    if limiter.is_bypass(&req) {
        return next.run(req).await;
    }

    // 3) Rate-limit
    if limiter.check(&req) {
        next.run(req).await
    } else {
        StatusCode::TOO_MANY_REQUESTS.into_response()
    }
}

/// ===== Утилиты IP/ACL =====

/// Разбор CSV-списка подсетей в Vec<IpNet>.
/// Пример: "127.0.0.1/32,::1/128,10.0.0.0/8"
pub fn parse_ip_allowlist(csv: &str) -> Vec<IpNet> {
    csv.split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .filter_map(|s| IpNet::from_str(s).ok())
        .collect()
}

/// Проверка, входит ли ip в allowlist.
pub fn ip_in_allowlist(ip: IpAddr, allow: &[IpNet]) -> bool {
    allow.iter().any(|net| net.contains(&ip))
}

/// IP клиента из X-Forwarded-For или ConnectInfo<SocketAddr>.
fn client_ip(req: &Request<Body>) -> Option<IpAddr> {
    // a) X-Forwarded-For: берём первый адрес
    if let Some(h) = req.headers().get("x-forwarded-for") {
        if let Ok(s) = h.to_str() {
            if let Some(first) = s.split(',').next() {
                if let Ok(ip) = first.trim().parse::<IpAddr>() {
                    return Some(ip);
                }
            }
        }
    }
    // b) ConnectInfo<SocketAddr> (Axum 0.7)
    if let Some(ci) = req.extensions().get::<axum::extract::ConnectInfo<SocketAddr>>() {
        return Some(ci.0.ip());
    }
    None
}

```

## FILE: /root/logos_lrb/node/src/JSON  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/LE  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/main.rs  (size=6999b)
```
use anyhow::Result;
use axum::{
    middleware::{from_fn_with_state},
    routing::{get, post},
    Router,
};
use bs58;
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::OnceCell;
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tower_http::{
    cors::CorsLayer, limit::RequestBodyLimitLayer, timeout::TimeoutLayer, trace::TraceLayer,
};
use tracing_subscriber::{fmt, EnvFilter};

use lrb_core::ledger::Ledger;
use lrb_core::rcp_engine::engine_with_channels;
use lrb_core::types::Rid;

mod admin;
mod api;
mod auth;
mod bridge;
mod fork;
mod guard;
mod metrics;
mod openapi;
mod peers;
mod state;
mod storage;
mod version;

use dashmap::DashMap;
use parking_lot::Mutex;

#[derive(Clone)]
pub struct AppState {
    pub signing: SigningKey,
    pub verifying: VerifyingKey,
    pub rid_b58: String,
    pub admin_key: String,
    pub bridge_key: String,
    pub ledger: Ledger,
    pub store: Arc<storage::Storage>,
    pub locks: Arc<DashMap<String, Arc<Mutex<()>>>>,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(
            bytes.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(
            data.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}
fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}
fn read_env_required(n: &str) -> Result<String> {
    Ok(std::env::var(n).map_err(|_| anyhow::anyhow!(format!("missing env {}", n)))?)
}
fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY", "CHANGE_ME", "", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys/ids
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid_b58 = rid_from_vk(&vk);
    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    // state
    let data_dir = std::env::var("LRB_DATA_DIR").unwrap_or_else(|_| "/var/lib/logos".into());
    std::fs::create_dir_all(&data_dir).ok();
    let ledger = Ledger::open(&data_dir)?;
    let store = Arc::new(storage::Storage::open(format!("{}/node_state", data_dir))?);

    let app_state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid_b58.clone(),
        admin_key,
        bridge_key,
        ledger: ledger.clone(),
        store,
        locks: Arc::new(DashMap::new()),
    };
    APP_STATE.set(app_state.clone()).ok();

    // engine
    let rid = Rid(rid_b58.clone());
    let _engine = engine_with_channels(ledger, rid);

    // CORS
    let allowed_origin =
        std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| "http://localhost".into());
    let cors = {
        let hv = allowed_origin
            .parse::<axum::http::HeaderValue>()
            .expect("bad LRB_WALLET_ORIGIN");
        CorsLayer::new()
            .allow_origin(hv)
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([
                axum::http::header::CONTENT_TYPE,
                axum::http::header::AUTHORIZATION,
            ])
    };

    // Rate-limit (env)
    let qps: u64 = std::env::var("LRB_RATE_QPS").ok().and_then(|s| s.parse().ok()).unwrap_or(20);
    let burst: u64 = std::env::var("LRB_RATE_BURST").ok().and_then(|s| s.parse().ok()).unwrap_or(40);
    let rl_enabled = qps > 0 && burst > 0;
    let bypass_cidr = std::env::var("LRB_RATE_BYPASS_CIDR")
        .unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let bypass = Arc::new(guard::parse_ip_allowlist(&bypass_cidr));
    let rl = Arc::new(guard::RateLimiter::new(qps, burst, bypass.clone()));

    // Admin IP ACL
    let admin_allow =
        std::env::var("LRB_ADMIN_IP_ALLOW").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let admin_nets = Arc::new(guard::parse_ip_allowlist(&admin_allow));

    // Public routes
    let public = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/livez", get(api::livez))
        .route("/readyz", get(api::readyz))
        .route("/version", get(version::version))
        .route("/openapi.json", get(openapi::spec))
        .route("/metrics", get(metrics::metrics_handler))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/history/:rid", get(api::history))
        .route("/block/:height", get(api::block))
        .route("/block/:height/mix", get(api::block_mix))
        .route("/economy", get(api::economy))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet));

    // Admin routes
    let admin_routes = Router::new()
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .layer(from_fn_with_state(admin_nets.clone(), guard::admin_ip_gate));

    // Bridge routes
    let bridge_routes = Router::new()
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify));

    // Build app
    let mut app = public
        .merge(admin_routes)
        .merge(bridge_routes)
        .with_state(app_state)
        .layer(cors)
        .layer(RequestBodyLimitLayer::new(512 * 1024))
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(TraceLayer::new_for_http());

    if rl_enabled {
        app = app.layer(from_fn_with_state(rl.clone(), guard::rate_limit_ip_gate));
    }

    // Start Axum 0.7
    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(addr).await?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid_b58);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/metrics.rs  (size=2923b)
```
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use prometheus::{
    histogram_opts, opts, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_gauge_with_registry, Encoder,
    HistogramVec, IntCounterVec, IntGauge, Registry, TextEncoder,
};
use std::time::Instant;

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static HTTP_REQ_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("http_requests_total", "Total HTTP requests"),
        &["endpoint", "method", "status"],
        &REGISTRY
    )
    .unwrap()
});
pub static HTTP_REQ_DUR: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec_with_registry!(
        histogram_opts!("http_request_duration_seconds", "HTTP duration").buckets(vec![
            0.001, 0.002, 0.005, 0.010, 0.020, 0.050, 0.100, 0.200, 0.500, 1.0, 2.0, 5.0
        ]),
        &["endpoint", "method"],
        &REGISTRY
    )
    .unwrap()
});
pub static INFLIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge_with_registry!(opts!("http_inflight_requests", "In-flight"), &REGISTRY)
        .unwrap()
});

// New app metrics
pub static HIST_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_history_requests_total", "History requests"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});
pub static BLOCKS_SERVED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_blocks_served_total", "Blocks served"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});

pub struct Timer {
    start: Instant,
    endpoint: &'static str,
    method: &'static str,
}
impl Timer {
    pub fn new(endpoint: &'static str, method: &'static str) -> Self {
        INFLIGHT.inc();
        Self {
            start: Instant::now(),
            endpoint,
            method,
        }
    }
    pub fn observe(self) {
        let dt = self.start.elapsed().as_secs_f64();
        HTTP_REQ_DUR
            .with_label_values(&[self.endpoint, self.method])
            .observe(dt);
        INFLIGHT.dec();
    }
}
pub fn inc_total(endpoint: &'static str, method: &'static str, status: StatusCode) {
    HTTP_REQ_TOTAL
        .with_label_values(&[endpoint, method, status.as_str()])
        .inc();
}
pub async fn metrics_handler() -> Response {
    let mf = REGISTRY.gather();
    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();
    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        [("Content-Type", enc.format_type().to_string())],
        buf,
    )
        .into_response()
}

```

## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi.rs  (size=341b)
```
use axum::{response::IntoResponse, http::StatusCode};

pub async fn spec() -> impl IntoResponse {
    // Компилируем JSON внутрь бинаря — стабильность и скорость
    const SPEC: &str = include_str!("../openapi/openapi.json");
    (StatusCode::OK, [("Content-Type", "application/json")], SPEC)
}

```

## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```

## FILE: /root/logos_lrb/node/src/state.rs  (size=211b)
```
//! Reserved for future network helpers (kept minimal to avoid dead_code warnings).
//! Прод-уровень: пустой модуль без неиспользуемых структур и функций.

```

## FILE: /root/logos_lrb/node/src/storage.rs  (size=12406b)
```
//! Узловое persistent-хранилище (sled, один Tree "kv"):
//!   accounts/<RID>                  -> JSON {balance, nonce}
//!   chain/height                    -> LE u64
//!   blocks/<height:016x>            -> JSON BlockRecord {height, ts_ms, txs}
//!   history/<RID>/<nonce:016x>      -> JSON HistoryItem {nonce, from, to, amount, height, ts_ms}
//!   economy/minted                  -> LE u64
//!   economy/burned                  -> LE u64
//!   mix/<height:016x>               -> JSON MixRecord {height, ts_ms, deltas: [(rid, i128)]}
//!
//! Комиссии v2: LRB_FEE_PER_TX (u64, по умолчанию 0) списываются с отправителя, суммируются и сжигаются.
//! PhaseMix v1: если LRB_PHASEMIX_ENABLE=1 — формируем агрегат Δ по RID и сохраняем в mix/<height>.
//!              По умолчанию fee в Δ не учитывается (LRB_PHASEMIX_INCLUDE_FEE=0).

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub nonce: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub height: u64,
    pub ts_ms: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct MixRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub deltas: Vec<(String, i128)>, // RID -> delta (i128 для симметрии)
}

pub struct Storage {
    db: sled::Db,
    kv: sled::Tree,
}

impl Storage {
    pub fn open<P: AsRef<std::path::Path>>(path: P) -> Result<Self> {
        std::fs::create_dir_all(&path).ok();
        let db = sled::open(path)?;
        let kv = db.open_tree("kv")?;
        let _ = kv.compare_and_swap(b"chain/height", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/minted", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/burned", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        Ok(Self { db, kv })
    }

    #[inline] fn k_account(rid: &str) -> String { format!("accounts/{}", rid) }
    #[inline] fn k_block(height: u64) -> String { format!("blocks/{:016x}", height) }
    #[inline] fn k_hist(rid: &str, nonce: u64) -> String { format!("history/{}/{:016x}", rid, nonce) }
    #[inline] fn k_mix(height: u64) -> String { format!("mix/{:016x}", height) }

    #[inline] fn now_ms() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis() as u64
    }

    // ======== Economy helpers ========
    fn read_u64(&self, key: &[u8]) -> Result<u64> {
        if let Some(v) = self.kv.get(key)? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }
    fn write_u64(&self, key: &[u8], val: u64) -> Result<()> { self.kv.insert(key, val.to_le_bytes().to_vec())?; Ok(()) }

    fn cap_env() -> u64 { std::env::var("LRB_SUPPLY_CAP").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(81_000_000) }
    fn fee_env() -> u64 { std::env::var("LRB_FEE_PER_TX").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(0) }
    fn phasemix_enabled() -> bool { std::env::var("LRB_PHASEMIX_ENABLE").ok().as_deref() == Some("1") }
    fn phasemix_include_fee() -> bool { std::env::var("LRB_PHASEMIX_INCLUDE_FEE").ok().as_deref() == Some("1") }

    pub fn economy_snapshot(&self) -> Result<EconomySnapshot> {
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let cap = Self::cap_env();
        let supply = minted.saturating_sub(burned);
        Ok(EconomySnapshot { cap, minted, burned, supply })
    }

    pub fn try_mint_under_cap(&self, amt: u64) -> Result<u64> {
        let cap = Self::cap_env();
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let supply = minted.saturating_sub(burned);
        let new_supply = supply.checked_add(amt).ok_or_else(|| anyhow!("supply overflow"))?;
        if new_supply > cap { return Err(anyhow!("supply cap exceeded: new_supply={} cap={}", new_supply, cap)); }
        let new_minted = minted.checked_add(amt).ok_or_else(|| anyhow!("minted overflow"))?;
        self.write_u64(b"economy/minted", new_minted)?;
        self.db.flush()?; Ok(new_minted)
    }

    pub fn inc_burned(&self, amt: u64) -> Result<u64> {
        if amt == 0 { return Ok(self.read_u64(b"economy/burned")?); }
        let burned = self.read_u64(b"economy/burned")?;
        let new_burn = burned.checked_add(amt).ok_or_else(|| anyhow!("burn overflow"))?;
        self.write_u64(b"economy/burned", new_burn)?;
        self.db.flush()?; Ok(new_burn)
    }

    // ======== Accounts / Faucet / Blocks / History / Mix ========
    pub fn get_account(&self, rid: &str) -> Result<AccountState> {
        if let Some(v) = self.kv.get(Self::k_account(rid).as_bytes())? {
            let st: AccountState = serde_json::from_slice(&v)?; Ok(st)
        } else { Ok(AccountState::default()) }
    }

    pub fn faucet(&self, rid: &str, amount: u64) -> Result<AccountState> {
        if amount == 0 { return Err(anyhow!("amount must be > 0")); }
        let _ = self.try_mint_under_cap(amount)?;
        let mut st = self.get_account(rid)?; st.balance = st.balance.saturating_add(amount);
        self.kv.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(&st)?)?;
        self.db.flush()?; Ok(st)
    }

    /// Применяем batch: учитываем комиссию, записываем блок/историю, формируем Mix (Δ по RID).
    pub fn apply_batch(&self, txs: &[TxIn]) -> Result<u64> {
        let fee = Self::fee_env();
        let include_fee_in_delta = Self::phasemix_include_fee();
        let mut total_fee: u64 = 0;

        let mut batch = sled::Batch::default();
        let mut acc_cache: HashMap<String, AccountState> = HashMap::new();
        let mut deltas: HashMap<String, i128> = HashMap::new(); // RID -> Δ

        for tx in txs {
            if tx.from == tx.to {
                // само-трансфер: только nonce (+ fee если задана)
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                // комиссию списываем
                if fee > 0 {
                    if from.balance < fee { continue; }
                    from.balance = from.balance.saturating_sub(fee);
                    total_fee = total_fee.saturating_add(fee);
                    if include_fee_in_delta { *deltas.entry(tx.from.clone()).or_default() -= fee as i128; }
                }
                from.nonce = from.nonce.saturating_add(1);
                acc_cache.insert(tx.from.clone(), from);
            } else {
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                let mut to   = acc_cache.remove(&tx.to).unwrap_or(self.get_account(&tx.to).unwrap_or_default());
                let need = tx.amount.saturating_add(fee);
                if from.balance >= need {
                    from.balance = from.balance.saturating_sub(need);
                    to.balance   = to.balance.saturating_add(tx.amount);
                    from.nonce   = from.nonce.saturating_add(1);
                    // Δ (без fee по умолчанию)
                    *deltas.entry(tx.from.clone()).or_default() -= tx.amount as i128;
                    *deltas.entry(tx.to.clone()).or_default()   += tx.amount as i128;
                    if fee > 0 {
                        total_fee = total_fee.saturating_add(fee);
                        if include_fee_in_delta {
                            *deltas.entry(tx.from.clone()).or_default() -= fee as i128;
                        }
                    }
                } else {
                    // недостаточно средств — пропускаем tx
                    continue;
                }
                acc_cache.insert(tx.from.clone(), from);
                acc_cache.insert(tx.to.clone(),   to);
            }
        }

        for (rid, st) in acc_cache.iter() {
            batch.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(st)?);
        }

        let cur_h = self.get_height()?;
        let new_h = cur_h + 1;
        let ts_ms = Self::now_ms();

        let block = BlockRecord { height: new_h, ts_ms, txs: txs.to_vec() };
        batch.insert(b"chain/height", new_h.to_le_bytes().to_vec());
        batch.insert(Self::k_block(new_h).as_bytes(), serde_json::to_vec(&block)?);

        for tx in txs {
            let item = HistoryItem { nonce: tx.nonce, from: tx.from.clone(), to: tx.to.clone(), amount: tx.amount, height: new_h, ts_ms };
            batch.insert(Self::k_hist(&tx.from, tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
            batch.insert(Self::k_hist(&tx.to,   tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
        }

        // Сохраняем MixRecord, если включён PhaseMix
        if Self::phasemix_enabled() {
            let mut vec: Vec<(String,i128)> = deltas.into_iter().collect();
            // отбрасываем нулевые Δ и сортируем для стабильности
            vec.retain(|(_,d)| *d != 0);
            vec.sort_by(|a,b| a.0.cmp(&b.0));
            let mix = MixRecord { height: new_h, ts_ms, deltas: vec };
            batch.insert(Self::k_mix(new_h).as_bytes(), serde_json::to_vec(&mix)?);
        }

        self.kv.apply_batch(batch)?;
        self.db.flush()?;

        if total_fee > 0 { let _ = self.inc_burned(total_fee)?; }

        Ok(new_h)
    }

    pub fn get_height(&self) -> Result<u64> {
        if let Some(v) = self.kv.get(b"chain/height")? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }

    pub fn get_block(&self, height: u64) -> Result<Option<BlockRecord>> {
        Ok(self.kv.get(Self::k_block(height).as_bytes())?.map(|v| serde_json::from_slice::<BlockRecord>(&v)).transpose()?)
    }

    pub fn get_mix(&self, height: u64) -> Result<Option<MixRecord>> {
        Ok(self.kv.get(Self::k_mix(height).as_bytes())?.map(|v| serde_json::from_slice::<MixRecord>(&v)).transpose()?)
    }

    pub fn history_page(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<(Vec<HistoryItem>, Option<u64>)> {
        let prefix = format!("history/{}/", rid);
        let start  = format!("{}{:016x}", prefix, from_nonce);
        let mut out = Vec::with_capacity(limit.min(1024));
        let mut last_nonce: Option<u64> = None;
        let mut iter = self.kv.range(start.as_bytes()..);
        while let Some(kv) = iter.next() {
            let (k, v) = kv?; if !k.starts_with(prefix.as_bytes()) { break; }
            let item: HistoryItem = serde_json::from_slice(&v)?; out.push(item.clone());
            last_nonce = Some(item.nonce); if out.len() >= limit { break; }
        }
        let next_from = if let Some(n) = last_nonce {
            let next_key = format!("{}{:016x}", prefix, n.saturating_add(1));
            if let Some(kv) = self.kv.range(next_key.as_bytes()..).next() {
                let (k, _) = kv?; if k.starts_with(prefix.as_bytes()) { Some(n.saturating_add(1)) } else { None }
            } else { None }
        } else { None };
        Ok((out, next_from))
    }

    pub fn history_from(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<Vec<HistoryItem>> {
        Ok(self.history_page(rid, from_nonce, limit)?.0)
    }
}

#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    #[serde(default)]
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,
}

#[derive(Serialize)]
pub struct EconomySnapshot {
    pub cap: u64,
    pub minted: u64,
    pub burned: u64,
    pub supply: u64,
}

```

## FILE: /root/logos_lrb/node/src/version.rs  (size=520b)
```
use axum::Json;
use serde::Serialize;

#[derive(Serialize)]
pub struct VersionInfo {
    pub name: &'static str,
    pub version: &'static str,
    pub git_commit: &'static str,
    pub build_time_utc: &'static str,
    pub rustc: &'static str,
}

pub async fn version() -> Json<VersionInfo> {
    Json(VersionInfo {
        name: "logos_node",
        version: env!("CARGO_PKG_VERSION"),
        git_commit: env!("GIT_COMMIT"),
        build_time_utc: env!("BUILD_TIME_UTC"),
        rustc: env!("RUSTC_VER"),
    })
}

```

## FILE: /root/logos_lrb/README.md  (size=841b)
```
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```

## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
```
#!/usr/bin/env bash
set -euo pipefail
DOMAIN="${DOMAIN:-example.com}"
INSTANCE="${INSTANCE:-a}"

sudo apt-get update -y
sudo apt-get install -y git curl jq build-essential pkg-config libssl-dev nginx

/usr/bin/id logos >/dev/null 2>&1 || sudo useradd -r -m -d /var/lib/logos -s /usr/sbin/nologin logos
sudo mkdir -p /opt/logos /etc/logos /var/lib/logos /opt/logos/www/wallet

cd "$(dirname "$0")/.."
cargo build --release -p logos_node
sudo cp ./target/release/logos_node /opt/logos/logos_node
sudo chown logos:logos /opt/logos/logos_node
sudo chmod 755 /opt/logos/logos_node

sudo cp ./infra/systemd/logos-node@.service /etc/systemd/system/logos-node@.service
sudo systemctl daemon-reload

sudo cp ./infra/nginx/logos-api-lb.conf.example /etc/nginx/sites-available/logos-api-lb.conf
sudo sed -i "s/YOUR_DOMAIN/${DOMAIN}/" /etc/nginx/sites-available/logos-api-lb.conf
sudo ln -sf /etc/nginx/sites-available/logos-api-lb.conf /etc/nginx/sites-enabled/logos-api-lb.conf
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

sudo cp -r ./www/wallet/* /opt/logos/www/wallet/
sudo chown -R logos:logos /opt/logos/www

if [ ! -f "/etc/logos/node-${INSTANCE}.env" ]; then
  sudo cp ./configs/env/node.env.example "/etc/logos/node-${INSTANCE}.env"
  echo ">>> EDIT /etc/logos/node-${INSTANCE}.env (LRB_NODE_SK_HEX/LRB_ADMIN_KEY/LRB_WALLET_ORIGIN)"
fi

sudo systemctl enable --now "logos-node@${INSTANCE}"
systemctl --no-pager status "logos-node@${INSTANCE}"

echo "API: http://127.0.0.1:8080   Wallet: http://${DOMAIN}/wallet/"

```

## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
```
#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="/root/logos_lrb"
GIT_REMOTE="${GIT_REMOTE:-origin}"
GIT_BRANCH="${GIT_BRANCH:-main}"
INCLUDE_SNAPSHOT="${INCLUDE_SNAPSHOT:-0}"

echo "[i] collecting from live system → $REPO_ROOT"
cd "$REPO_ROOT"

# .gitignore (если нет)
[ -f .gitignore ] || cat > .gitignore <<'EOF'
target/
**/target/
node_modules/
dist/
.DS_Store
*.swp
*.swo
/etc/logos/*.env
*.pem
*.key
*.crt
*.p12
/var/lib/logos/
/var/run/logos_health.json
/usr/local/bin/lrb_bench*
/usr/local/bin/logos_healthcheck.sh
/etc/letsencrypt/
*.log
/var/log/nginx/*.log
www/wallet/*.map
tools/**/go/bin/
EOF

# каталоги в репо
mkdir -p configs/env infra/systemd infra/nginx scripts tools/bench/go www/wallet docs

# wallet → www/wallet
if [ -d /opt/logos/www/wallet ]; then
  rsync -a --delete /opt/logos/www/wallet/ www/wallet/
  echo "[i] wallet synced"
fi

# systemd → infra/systemd
[ -f /etc/systemd/system/logos-node@.service ]       && cp -f /etc/systemd/system/logos-node@.service        infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.service ] && cp -f /etc/systemd/system/logos-healthcheck.service   infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.timer ]   && cp -f /etc/systemd/system/logos-healthcheck.timer     infra/systemd/

# nginx → infra/nginx (example)
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && cp -f /etc/nginx/sites-available/logos-api-lb.conf infra/nginx/logos-api-lb.conf.example

# healthcheck → scripts (если установлен в /usr/local/bin)
if [ -f /usr/local/bin/logos_healthcheck.sh ]; then
  cp -f /usr/local/bin/logos_healthcheck.sh scripts/logos_healthcheck.sh
  chmod +x scripts/logos_healthcheck.sh
fi

# env → *.example (обезличиваем секреты)
mkdir -p configs/env
shopt -s nullglob
for f in /etc/logos/node-*.env; do
  bn="$(basename "$f")"
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    "$f" > "configs/env/${bn}.example"
  echo "[i] env example: configs/env/${bn}.example"
done
# общий пример, если ничего не найдено
if [ -z "$(ls -1 configs/env/*.example 2>/dev/null || true)" ]; then
cat > configs/env/node.env.example <<'EEX'
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_DATA_DIR=/var/lib/logos
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_WALLET_ORIGIN=http://localhost
LRB_RATE_QPS=20
LRB_RATE_BURST=40
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
LRB_ENABLE_FAUCET=0
LRB_ADMIN_IP_ALLOW=127.0.0.1/32,::1/128
EEX
fi

# snapshots (опционально)
if [ "${INCLUDE_SNAPSHOT}" = "1" ]; then
  mkdir -p snapshots
  cp -f /root/logos_snapshot/*.txt snapshots/ 2>/dev/null || true
fi

# git add/commit/push
git add -A
if ! git diff --cached --quiet; then
  git commit -m "sync(live): full system snapshot (code+infra+wallet+scripts), env → *.example"
else
  echo "[i] nothing to commit"
fi

# пуш
git push "${GIT_REMOTE}" "${GIT_BRANCH}"
echo "[✓] pushed to ${GIT_REMOTE}/${GIT_BRANCH}"

```

## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```

## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```

## FILE: /root/logos_lrb/tools/batch.json  (SKIPPED, empty)

## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```

## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```

## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```

## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```

## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```

## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```

## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```

## FILE: /root/logos_lrb/tools/make_codebook.sh  (size=4676b)
```
#!/usr/bin/env sh
set -eu

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT_DIR="docs"
STAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
OUT_FILE_TMP="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt.tmp"
OUT_FILE="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt"
SIZE_LIMIT="${SIZE_LIMIT:-2000000}"   # 2 МБ
REPO_ROOT="/root/logos_lrb"

REPO_GLOBS='
Cargo.toml
README.md
lrb_core/src
node/src
modules
www/wallet
www/explorer
infra/nginx
infra/systemd
scripts
tools
configs
'

INFRA_FILES='
/etc/nginx/nginx.conf
/etc/nginx/conf.d/*.conf
/etc/nginx/sites-enabled/*
/etc/systemd/system/logos-node.service
/etc/systemd/system/*.service
/etc/systemd/system/*.timer
/etc/systemd/system/logos-node.service.d/*.conf
/etc/prometheus/prometheus.yml
/etc/prometheus/rules/*.yml
/etc/alertmanager/alertmanager.yml
/etc/alertmanager/secrets.env
/etc/grafana/grafana.ini
/etc/grafana/provisioning/datasources/*.yaml
/etc/grafana/provisioning/dashboards/*.yaml
/var/lib/grafana/dashboards/*.json
/opt/logos/www/wallet/*
/opt/logos/www/explorer/*
'

EXCLUDES_REPO='
.git
target
node_modules
venv
__pycache__
*.pyc
data.sled
var
*.log
*.pem
*.der
*.crt
*.key
*.zip
*.tar
*.tar.gz
*.7z
LOGOS_LRB_FULL_BOOK.md
'

lang_for() {
  case "${1##*.}" in
    rs) echo "rust";; toml) echo "toml";; json) echo "json";;
    yml|yaml) echo "yaml";; sh|bash) echo "bash";; py) echo "python";;
    js) echo "javascript";; ts) echo "typescript";; tsx|jsx) echo "tsx";;
    html|htm) echo "html";; css) echo "css";; md) echo "markdown";;
    conf|ini|service|timer|env) echo "";; *) echo "";;
  esac
}

looks_text() {
  case "$1" in
    *.rs|*.toml|*.json|*.yml|*.yaml|*.sh|*.bash|*.py|*.js|*.ts|*.tsx|*.jsx|*.html|*.htm|*.css|*.md|*.conf|*.ini|*.service|*.timer|*.env) return 0;;
    *) LC_ALL=C grep -Iq . "$1";;
  esac
}

should_exclude_repo() {
  f="$1"
  # выкинуть любые пути с двоеточиями (мусор типа main.rs:30:18)
  echo "$f" | grep -q ":" && return 0
  # остальные исключения
  echo "$EXCLUDES_REPO" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    case "$f" in */$pat/*|*/$pat|$pat) exit 0;; esac
  done; return 1
}

mask_secrets() {
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED***/g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_BRIDGE_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_JWT_SECRET=)[A-Za-z0-9._-]+/\1***MASKED***/g'
}

write_header() {
  {
    echo "# FULL LIVE SNAPSHOT — $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "# sources: $REPO_ROOT + infra (/etc, /opt)"
    echo "# size limit per file: ${SIZE_LIMIT} bytes"
    echo
  } >>"$OUT_FILE_TMP"
}

dump_file() {
  f="$1"
  [ -f "$f" ] || return 0
  # пропускаем любые пути с двоеточием (мусор)
  echo "$f" | grep -q ":" && return 0

  sz="$(wc -c <"$f" | tr -d ' ' || echo 0)"
  [ "$sz" -eq 0 ] && { printf "\n## FILE: %s  (SKIPPED, empty)\n" "$f" >>"$OUT_FILE_TMP"; return 0; }
  [ "$sz" -gt "$SIZE_LIMIT" ] && { printf "\n## FILE: %s  (SKIPPED, size=%sb > limit)\n" "$f" "$sz" >>"$OUT_FILE_TMP"; return 0; }

  printf "\n## FILE: %s  (size=%sb)\n" "$f" "$sz" >>"$OUT_FILE_TMP"
  if looks_text "$f"; then
    printf '```\n' >>"$OUT_FILE_TMP"
    case "$f" in
      */alertmanager/secrets.env|*/logos-node.service.d/*|*/nginx/*.conf|*/conf.d/*.conf|*/sites-enabled/*|*/prometheus*.yml|*/grafana/*.ini|*/provisioning/*|*/dashboards/*.json)
        mask_secrets < "$f" >>"$OUT_FILE_TMP" ;;
      *) cat "$f" >>"$OUT_FILE_TMP" ;;
    esac
    printf '\n```\n' >>"$OUT_FILE_TMP"
  else
    printf "\n(SKIPPED, binary/non-text)\n" >>"$OUT_FILE_TMP"
  fi
}

collect_repo() {
  echo "$REPO_GLOBS" | while IFS= read -r rel; do
    [ -z "$rel" ] && continue
    [ "${rel#\#}" != "$rel" ] && continue
    p="$REPO_ROOT/$rel"
    if [ -d "$p" ]; then
      find "$p" -type f
    elif [ -f "$p" ]; then
      echo "$p"
    fi
  done
}

collect_infra() {
  echo "$INFRA_FILES" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    for f in $pat; do [ -f "$f" ] && echo "$f"; done
  done
}

main() {
  mkdir -p "$OUT_DIR"
  : >"$OUT_FILE_TMP"
  write_header

  # repo
  collect_repo | sort -u | while IFS= read -r p; do
    if should_exclude_repo "$p"; then continue; fi
    dump_file "$p"
  done

  # infra
  collect_infra | sort -u | while IFS= read -r p; do
    dump_file "$p"
  done

  mv -f "$OUT_FILE_TMP" "$OUT_FILE"
  echo "✅ Сформировано: $OUT_FILE"
  cp -f "$OUT_FILE" "${ROOT}/LOGOS_LRB_FULL_BOOK.md" 2>/dev/null || true
}

main "$@"

```

## FILE: /root/logos_lrb/tools/make_full_book.sh  (size=5023b)
```
#!/usr/bin/env bash
# LOGOS LRB — Полная книга: исходники из репозитория + ключевые прод-конфиги
set -euo pipefail

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT="${ROOT}/LOGOS_LRB_FULL_BOOK.md"
TS="$(date -u +'%Y-%m-%d %H:%M:%S UTC')"
GIT_SHA="$(git -C "$ROOT" rev-parse --short=7 HEAD 2>/dev/null || echo 'no-git')"

# ---------- Параметры ----------
# исключаем мусор/бинарь/секреты
EXCLUDES_REPO=(
  ".git" "target" "node_modules" "venv" "__pycache__" "data.sled" "var"
  "LOGOS_LRB_FULL_BOOK.md" "*.log" "*.pem" "*.der" "*.crt" "*.key" "*.zip" "*.tar" "*.tar.gz" "*.7z"
)
# включаем infra из whitelist-путей
INFRA_FILES=(
  "/etc/nginx/conf.d/*.conf"
  "/etc/systemd/system/logos-node.service"
  "/etc/systemd/system/logos-node.service.d/*.conf"
  "/etc/prometheus/prometheus.yml"
  "/etc/prometheus/rules/*.yml"
  "/etc/alertmanager/alertmanager.yml"
  "/etc/alertmanager/secrets.env"
  "/etc/grafana/provisioning/datasources/*.yaml"
  "/etc/grafana/provisioning/dashboards/*.yaml"
  "/var/lib/grafana/dashboards/*.json"
)
MAX_SIZE=$((2*1024*1024))  # 2 МБ на файл

lang_for() {
  case "${1##*.}" in
    rs) echo "rust" ;; toml) echo "toml" ;; json) echo "json" ;;
    yml|yaml) echo "yaml" ;; sh|bash) echo "bash" ;; py) echo "python" ;;
    js) echo "javascript" ;; ts) echo "typescript" ;; tsx|jsx) echo "tsx" ;;
    html|htm) echo "html" ;; css) echo "css" ;; md) echo "markdown" ;;
    conf|ini|service|timer) echo "" ;;  *) echo "" ;;
  esac
}

exclude_match() {
  local f="$1"
  for p in "${EXCLUDES_REPO[@]}"; do
    case "$p" in
      *"*") [[ "$f" == $p ]] && return 0 ;;
      *)    [[ "$f" == */$p/* || "$f" == */$p || "$f" == $p ]] && return 0 ;;
    esac
  done
  return 1
}

# маскировка секретов для infra (телеграм токены, и т.п.)
mask_infra() {
  # stdin -> stdout
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED*** /g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED*** /g'
}

# ---------- Заголовок ----------
{
  echo "# LOGOS LRB — Полная книга (исходники + прод-конфиги)"
  echo
  echo "_Generated: ${TS} • Commit: ${GIT_SHA}_"
  echo
  echo "> В книге: весь код из репозитория + основные конфиги из /etc. Исключены бинарные/ключевые файлы; секреты замаскированы."
  echo
  echo "## Оглавление"
} > "$OUT"

TMP_LIST="$(mktemp)"
( cd "$ROOT" && find . -type f -print0 ) >"$TMP_LIST"

# ---------- Оглавление: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && continue
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  echo "- [repo:$f](#$anchor)" >> "$OUT"
done < "$TMP_LIST"

# ---------- Оглавление: infra ----------
for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && continue
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    echo "- [infra:$f](#$anchor)" >> "$OUT"
  done
done

{
  echo
  echo "---"
  echo
  echo "## Раздел I. Исходники репозитория"
  echo
} >> "$OUT"

# ---------- Контент: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
  rel="${f#./}"
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  lang="$(lang_for "$rel")"
  {
    echo "### $rel"
    echo "<a id=\"$anchor\"></a>"
    echo
    echo '```'"$lang"
    cat "$ROOT/$f"
    echo
    echo '```'
    echo
  } >> "$OUT"
done < "$TMP_LIST"

rm -f "$TMP_LIST"

# ---------- Контент: infra ----------
{
  echo
  echo "## Раздел II. Инфраструктурные конфиги (прод)"
  echo
} >> "$OUT"

for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    lang="$(lang_for "$f")"
    {
      echo "### $f"
      echo "<a id=\"$anchor\"></a>"
      echo
      echo '```'"$lang"
      # маскируем секреты в alertmanager/secrets.env и похожем
      case "$f" in
        */alertmanager/secrets.env) mask_infra < "$f" ;;
        *) cat "$f" ;;
      esac
      echo
      echo '```'
      echo
    } >> "$OUT"
  done
done

echo "✅ Сформировано: $OUT"

```

## FILE: /root/logos_lrb/tools/make_full_snapshot_live.sh  (size=4401b)
```
#!/usr/bin/env bash
set -euo pipefail

OUTDIR="${OUTDIR:-/root/logos_snapshot}"
STAMP=$(date +%Y%m%d_%H%M)
OUT="$OUTDIR/LRB_FULL_LIVE_${STAMP}.txt"
MAX=${MAX:-800000}  # макс размер включаемого файла (байт)

mkdir -p "$OUTDIR"

say(){ echo "$@" >&2; }
add_head(){
  echo -e "\n\n## FILE: $1  (size=${2}b)\n\`\`\`" >> "$OUT"
}
add_tail(){
  echo -e "\n\`\`\`" >> "$OUT"
}

# Источники (живые пути)
SRC_LIST=(
  "/root/logos_lrb"                   # весь код репо
  "/opt/logos/www/wallet"             # кошелёк
  "/etc/systemd/system/logos-node@.service"
  "/etc/systemd/system/logos-healthcheck.service"
  "/etc/systemd/system/logos-healthcheck.timer"
  "/etc/nginx/sites-available/logos-api-lb.conf"
  "/usr/local/bin/logos_healthcheck.sh"
)

# Заголовок
{
  echo "# FULL LIVE SNAPSHOT — $(date -u +%FT%TZ)"
  echo "# sources:"
  for s in "${SRC_LIST[@]}"; do echo "#  - $s"; done
  echo "# size limit per file: ${MAX} bytes"
  echo
} > "$OUT"

# Вспомогательные функции
is_text(){
  # бинарники/картинки отсекаем простым тестом: попытка вывести «без нулевых байтов»
  # или используем file(1) если есть
  if command -v file >/dev/null 2>&1; then
    file -b --mime "$1" | grep -qiE 'text|json|xml|yaml|toml|javascript|html|css' && return 0 || return 1
  else
    grep -Iq . "$1" && return 0 || return 1
  fi
}

emit_file(){
  local f="$1"
  [ -f "$f" ] || return 0
  # исключения
  case "$f" in
    *.pem|*.key|*.crt|*.p12|*.so|*.bin|*.png|*.jpg|*.jpeg|*.gif|*.svg|*.woff|*.woff2|*.ttf) return 0;;
  esac
  local sz
  sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
  if [ "$sz" -gt "$MAX" ]; then
    echo -e "\n\n## FILE: $f  (SKIPPED, size=${sz}b > ${MAX})" >> "$OUT"
    return 0
  fi
  if ! is_text "$f"; then
    echo -e "\n\n## FILE: $f  (SKIPPED, binary/non-text size=${sz}b)" >> "$OUT"
    return 0
  fi
  add_head "$f" "$sz"
  sed -e 's/\r$//' "$f" >> "$OUT"
  add_tail
}

# 1) Репозиторий: только текстовые файлы, игнорим target/node_modules/dist
if [ -d /root/logos_lrb ]; then
  say "[*] collecting /root/logos_lrb"
  cd /root/logos_lrb
  # берём отслеживаемые git'ом; если git недоступен — найдём все текстовые расширения
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    git ls-files | while read -r f; do
      case "$f" in target/*|**/target/*|node_modules/*|dist/*) continue;; esac
      emit_file "/root/logos_lrb/$f"
    done
  else
    find . -type f ! -path "./target/*" ! -path "./node_modules/*" ! -path "./dist/*" \
      -regextype posix-extended -regex '.*\.(rs|toml|md|sh|bash|zsh|service|timer|conf|nginx|yaml|yml|json|ts|tsx|js|mjs|jsx|html|htm|css|go|py|proto|ini|cfg|txt)$' \
      -print0 | xargs -0 -I{} bash -c 'emit_file "{}"'
  fi
  cd - >/dev/null
fi

# 2) Статика кошелька
if [ -d /opt/logos/www/wallet ]; then
  say "[*] collecting /opt/logos/www/wallet"
  find /opt/logos/www/wallet -type f -print0 | while IFS= read -r -d '' f; do emit_file "$f"; done
fi

# 3) systemd units
for u in /etc/systemd/system/logos-node@.service /etc/systemd/system/logos-healthcheck.service /etc/systemd/system/logos-healthcheck.timer; do
  [ -f "$u" ] && emit_file "$u"
done

# 4) nginx site
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && emit_file /etc/nginx/sites-available/logos-api-lb.conf

# 5) healthcheck script
[ -f /usr/local/bin/logos_healthcheck.sh ] && emit_file /usr/local/bin/logos_healthcheck.sh

# 6) Живые .env → в слепок как обезличенные *.example
sanitize_env(){
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(HOT_WALLET_PRIVATE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_TOKEN)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_CHAT_ID)=.*/\1=CHANGE_ME/' \
    "$1"
}
if ls /etc/logos/node-*.env >/dev/null 2>&1; then
  for f in /etc/logos/node-*.env; do
    tmp="$(mktemp)"; sanitize_env "$f" > "$tmp"
    sz=$(stat -c%s "$tmp" 2>/dev/null || echo 0)
    add_head "${f}.example" "$sz"
    cat "$tmp" >> "$OUT"
    add_tail
    rm -f "$tmp"
  done
fi

echo "[ok] wrote $OUT"

```

## FILE: /root/logos_lrb/tools/repo_audit.sh  (size=3155b)
```
#!/usr/bin/env bash
set -euo pipefail

fail=0
pass(){ printf "  [OK]  %s\n" "$1"; }
err(){  printf "  [FAIL] %s\n" "$1"; fail=1; }

echo "== GIT STATUS =="
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "not a git repo"; exit 1; }
git status --porcelain

echo "== CORE CODE =="
[ -d lrb_core/src ] && pass "lrb_core/src" || err "lrb_core/src missing"
[ -f lrb_core/src/ledger.rs ] && pass "lrb_core ledger.rs" || err "ledger.rs missing"
[ -f lrb_core/src/rcp_engine.rs ] && pass "lrb_core rcp_engine.rs" || err "rcp_engine.rs missing"
[ -f lrb_core/src/phase_filters.rs ] && pass "lrb_core phase_filters.rs" || err "phase_filters.rs missing"
[ -f lrb_core/src/crypto.rs ] && pass "lrb_core crypto.rs (AEAD)" || err "crypto.rs missing"

echo "== NODE =="
for f in node/src/main.rs node/src/api.rs node/src/metrics.rs node/src/guard.rs node/src/storage.rs node/src/version.rs; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done
[ -f node/src/openapi.json ] && pass "node/src/openapi.json" || err "openapi.json missing"
[ -f node/build.rs ] && pass "node/build.rs" || err "node/build.rs missing"
[ -f node/Cargo.toml ] && pass "node/Cargo.toml" || err "node/Cargo.toml missing"

echo "== MODULES DIR =="
[ -d modules ] && pass "modules/ present" || err "modules/ missing"

echo "== WALLET =="
for f in www/wallet/index.html www/wallet/wallet.css www/wallet/wallet.js; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== INFRA =="
for f in infra/systemd/logos-node@.service infra/systemd/logos-healthcheck.service infra/systemd/logos-healthcheck.timer \
         infra/nginx/logos-api-lb.conf.example; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== SCRIPTS =="
[ -f scripts/bootstrap_node.sh ] && pass "scripts/bootstrap_node.sh" || err "bootstrap_node.sh missing"
[ -f scripts/logos_healthcheck.sh ] && pass "scripts/logos_healthcheck.sh" || err "logos_healthcheck.sh missing"

echo "== TOOLS =="
[ -f tools/bench/go/bench.go ] && pass "bench v4: tools/bench/go/bench.go" || err "bench.go missing"
[ -f tools/sdk/ts/index.mjs ] && pass "TS SDK: tools/sdk/ts/index.mjs" || err "TS SDK missing"
[ -f tools/sdk/ts/sdk_test.mjs ] && pass "TS SDK test" || err "TS SDK test missing"
[ -f tools/sdk/go/logosapi.go ] && pass "Go SDK: tools/sdk/go/logosapi.go" || err "Go SDK missing"

echo "== CONFIGS / EXAMPLES =="
ls -1 configs/env/*.example >/dev/null 2>&1 && pass "env examples present" || err "env examples missing"
# убедимся что реальные .env не попали
if git ls-files | grep -E '^configs/env/.*\.env$' >/dev/null; then
  err "real .env found in repo"
else
  pass "no real .env tracked"
fi

echo "== SNAPSHOTS (optional) =="
[ -d snapshots ] && echo "  [info] snapshots/ exists (ok)"; true

echo "== SIZE / SUMMARY =="
echo "  tracked files: $(git ls-files | wc -l)"
echo "  repo disk size: $(du -sh . | cut -f1)"

echo "== SECRET LEAK SCAN (quick) =="
git grep -nE '(PRIVATE|SECRET|BEGIN (RSA|EC) PRIVATE KEY)' || true
git grep -nE 'LRB_NODE_SK_HEX=[0-9a-fA-F]{64}$' || true

echo
if [ $fail -eq 0 ]; then
  echo "[RESULT] REPO OK"
else
  echo "[RESULT] FAILS PRESENT"; exit 1
fi

```

## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```

## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```

## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```

## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```

## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```

## FILE: /root/logos_lrb/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /root/logos_lrb/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /root/logos_lrb/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /root/logos_lrb/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /root/logos_lrb/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /root/logos_lrb/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /etc/alertmanager/alertmanager.yml  (size=603b)
```
route:
  receiver: 'telegram'
  group_wait: 10s
  group_interval: 1m
  repeat_interval: 2h

receivers:
- name: 'telegram'
  telegram_configs:
  - bot_token: '8317523208:AAH29EJG6H0BurJ4J74Bdb2XLjcDYcK9vIc'  # ← токен в КАВЫЧКАХ
    chat_id: 6355622860                                       # ← ЦЕЛОЕ ЧИСЛО (без кавычек)
    parse_mode: HTML
    message: |
      <b>{{ .Status | toUpper }}</b> — {{ .CommonLabels.alertname }}
      {{ range .Alerts -}}
      • <b>{{ .Labels.severity }}</b> @ {{ .StartsAt }}\n
        {{ .Annotations.summary }}
      {{ end }}

```

## FILE: /etc/alertmanager/secrets.env  (size=94b)
```
TELEGRAM_BOT_TOKEN=***MASKED***
TELEGRAM_CHAT_ID=***MASKED***

```

## FILE: /etc/grafana/grafana.ini  (size=191b)
```
[server]
http_addr = 0.0.0.0
http_port = 3000
# Grafana на корне, HTTPS домен:
root_url = https://45-159-248-232.sslip.io/
# без префикса
# serve_from_sub_path = false

```

## FILE: /etc/grafana/provisioning/dashboards/lrb.yaml  (size=151b)
```
apiVersion: 1
providers:
- name: LRB
  type: file
  updateIntervalSeconds: 10
  allowUiUpdates: false
  options:
    path: /var/lib/grafana/dashboards

```

## FILE: /etc/grafana/provisioning/datasources/prom.yaml  (size=146b)
```
apiVersion: 1
datasources:
- name: Prometheus
  type: prometheus
  access: proxy
  url: http://127.0.0.1:9094
  isDefault: true
  editable: false

```

## FILE: /etc/nginx/conf.d/00_redirect_80.conf  (size=118b)
```
server {
  listen 80 default_server;
  server_name 45-159-248-232.sslip.io;
  return 301 https://$host$request_uri;
}

```

## FILE: /etc/nginx/conf.d/10_lrb_https.conf  (size=2484b)
```
# === LOGOS LRB: HTTPS сайт ===
server {
  listen 443 ssl http2;
  server_name 45-159-248-232.sslip.io;

  # TLS
  ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;
  ssl_session_cache   shared:SSL:10m;
  ssl_protocols       TLSv1.2 TLSv1.3;
  ssl_ciphers         HIGH:!aNULL:!MD5;

  # Безопасные заголовки
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
  add_header X-Frame-Options        SAMEORIGIN       always;
  add_header X-Content-Type-Options nosniff          always;
  add_header Referrer-Policy        strict-origin-when-cross-origin always;

  # Базовая CSP
  add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

  # Grafana на корне
  location / {
    proxy_pass         http://127.0.0.1:3000/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }

  # Explorer (inline, без кэша)
  location /explorer/ {
    root /opt/logos/www;
    index index.html;

    expires off;
    etag off;
    add_header Cache-Control "no-store, no-cache, must-revalidate, max-age=0" always;
    add_header Pragma "no-cache" always;
    add_header Expires "0" always;

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

    try_files $uri $uri/ /explorer/index.html;
  }

  # Wallet
  location /wallet/ {
    root /opt/logos/www;
    index index.html;
    try_files $uri $uri/ /wallet/index.html;
  }

  # API (Axum 8080)
  location /api/ {
    proxy_pass         http://127.0.0.1:8080/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }
}

```

## FILE: /etc/nginx/nginx.conf  (size=1446b)
```
user www-data;
worker_processes auto;
pid /run/nginx.pid;
error_log /var/log/nginx/error.log;
include /etc/nginx/modules-enabled/*.conf;

events {
	worker_connections 768;
	# multi_accept on;
}

http {

	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}


#mail {
#	# See sample authentication script at:
#	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
#
#	# auth_http localhost/auth.php;
#	# pop3_capabilities "TOP" "USER";
#	# imap_capabilities "IMAP4rev1" "UIDPLUS";
#
#	server {
#		listen     localhost:110;
#		protocol   pop3;
#		proxy      on;
#	}
#
#	server {
#		listen     localhost:143;
#		protocol   imap;
#		proxy      on;
#	}
#}

```

## FILE: /etc/prometheus/prometheus.yml  (size=507b)
```
rule_files:
  - /etc/prometheus/rules/*.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
  - static_configs:
    - targets: ["127.0.0.1:9093"]

scrape_configs:
  # Метрики ноды LOGOS (Axum) — /metrics
  - job_name: logos_node
    static_configs:
      - targets: ['127.0.0.1:8080']
    metrics_path: /metrics

  # Node Exporter (включая lrb_exporter через textfile)
  - job_name: node
    static_configs:
      - targets: ['127.0.0.1:9100']

```

## FILE: /etc/prometheus/rules/lrb_alerts.yml  (size=1691b)
```
groups:
- name: lrb-core
  rules:
  # 1) Нода упала
  - alert: LogosNodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is down"
      description: "Target {{ $labels.instance }} is not scraping."

  # 2) Высокий процент 5xx за 5 минут
  - alert: HighErrorRatio
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m])) 
      / clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1) > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio (>2%)"
      description: "Instance {{ $labels.instance }} 5xx > 2%."

  # 3) Высокая латентность p95 > 1.5s
  - alert: HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "Instance {{ $labels.instance }} p95 high."

  # 4) Застряла высота (нет роста 10 минут)
  - alert: HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is not increasing"
      description: "No new blocks for 10m."

  # 5) Supply превышает cap (инвариант нарушен)
  - alert: SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap."

```

## FILE: /etc/prometheus/rules/lrb_core.yml  (size=3347b)
```
groups:

# ===================== LRB — Health =====================
- name: lrb-health
  rules:
  - alert: LRB_NodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is DOWN"
      description: "Target {{ $labels.instance }} is not scraping."

  - alert: LRB_HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is NOT increasing"
      description: "No new blocks on {{ $labels.instance }} for 10 minutes."

  - alert: LRB_HighHTTP5xx
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m]))
      /
      clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1)
      > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio >2%"
      description: "Instance {{ $labels.instance }} 5xx ratio is high."

# ===================== LRB — Performance =====================
- name: lrb-perf
  rules:
  - alert: LRB_HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "{{ $labels.instance }} p95={{ $value | printf \"%.2f\" }}s"

  - alert: LRB_LowRPS
    expr: |
      sum(rate(http_requests_total{job="logos_node"}[5m])) < 0.05
      and increase(lrb_head_height[10m]) >= 1
    for: 10m
    labels: { severity: warning }
    annotations:
      summary: "Logos API RPS is near zero"
      description: "Requests are almost zero while chain progresses."

# ===================== LRB — Economy =====================
- name: lrb-economy
  rules:
  - alert: LRB_SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap on {{ $labels.instance }}"

  - alert: LRB_EconomyMetricsMissing
    expr: absent(lrb_supply_total) or absent(lrb_cap_total)
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "Economy metrics are missing"
      description: "lrb_* economy metrics absent on {{ $labels.instance }}"

# ===================== Infra — Node Exporter =====================
- name: infra-node
  rules:
  - alert: HostLowMemory
    expr: node_memory_MemAvailable_bytes < 200 * 1024 * 1024
    for: 3m
    labels: { severity: warning }
    annotations:
      summary: "Low memory on host"
      description: "Available memory {{ $value | printf \"%.0f\" }} bytes"

  - alert: HostLowDisk
    expr: min(node_filesystem_avail_bytes{mountpoint="/",fstype!~"tmpfs|overlay"}) < 2 * 1024 * 1024 * 1024
    for: 5m
    labels: { severity: critical }
    annotations:
      summary: "Low disk space on /"
      description: "Free bytes {{ $value | printf \"%.0f\" }} on {{ $labels.instance }}"

  - alert: HostHighCPU
    expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 85
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High CPU usage"
      description: "CPU usage {{ $value | printf \"%.1f\" }}% on {{ $labels.instance }}"

```

## FILE: /etc/systemd/system/alertmanager.service  (size=400b)
```
[Unit]
Description=Alertmanager
After=network-online.target

[Service]
EnvironmentFile=/etc/alertmanager/secrets.env
ExecStart=/usr/local/bin/alertmanager \
  --config.file=/etc/alertmanager/alertmanager.yml \
  --storage.path=/var/lib/alertmanager \
  --web.listen-address=127.0.0.1:9093 \
  --cluster.listen-address=127.0.0.1:19094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.ModemManager1.service  (size=515b)
```
[Unit]
Description=Modem Manager
After=polkit.service
Requires=polkit.service
ConditionVirtualization=!container

[Service]
Type=dbus
BusName=org.freedesktop.ModemManager1
ExecStart=/usr/sbin/ModemManager
StandardError=null
Restart=on-abort
CapabilityBoundingSet=CAP_SYS_ADMIN CAP_NET_ADMIN
ProtectSystem=true
ProtectHome=true
PrivateTmp=true
RestrictAddressFamilies=AF_NETLINK AF_UNIX AF_QIPCRTR
NoNewPrivileges=true
User=root

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.ModemManager1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.resolve1.service  (size=1898b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Name Resolution
Documentation=man:systemd-resolved.service(8)
Documentation=man:org.freedesktop.resolve1(5)
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients

DefaultDependencies=no
After=systemd-sysctl.service systemd-sysusers.service
Before=sysinit.target network.target nss-lookup.target shutdown.target initrd-switch-root.target
Conflicts=shutdown.target initrd-switch-root.target
Wants=nss-lookup.target

[Service]
AmbientCapabilities=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
BusName=org.freedesktop.resolve1
CapabilityBoundingSet=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
ExecStart=!!/usr/lib/systemd/systemd-resolved
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectClock=yes
ProtectControlGroups=yes
ProtectHome=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/resolve
RuntimeDirectoryPreserve=yes
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service
Type=notify
User=systemd-resolve
ImportCredential=network.dns
ImportCredential=network.search_domains
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.resolve1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.thermald.service  (size=309b)
```
[Unit]
Description=Thermal Daemon Service
ConditionVirtualization=no

[Service]
Type=dbus
SuccessExitStatus=2
BusName=org.freedesktop.thermald
ExecStart=/usr/sbin/thermald --systemd --dbus-enable --adaptive
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.thermald.service


```

## FILE: /etc/systemd/system/dbus-org.freedesktop.timesync1.service  (size=1768b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Time Synchronization
Documentation=man:systemd-timesyncd.service(8)
ConditionCapability=CAP_SYS_TIME
ConditionVirtualization=!container
DefaultDependencies=no
After=systemd-sysusers.service
Before=time-set.target sysinit.target shutdown.target
Conflicts=shutdown.target
Wants=time-set.target

[Service]
AmbientCapabilities=CAP_SYS_TIME
BusName=org.freedesktop.timesync1
CapabilityBoundingSet=CAP_SYS_TIME
# Turn off DNSSEC validation for hostname look-ups, since those need the
# correct time to work, but we likely won't acquire that without NTP. Let's
# break this chicken-and-egg cycle here.
Environment=SYSTEMD_NSS_RESOLVE_VALIDATE=0
ExecStart=!!/usr/lib/systemd/systemd-timesyncd
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectProc=invisible
ProtectControlGroups=yes
ProtectHome=yes
ProtectHostname=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/timesync
StateDirectory=systemd/timesync
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service @clock
Type=notify
User=systemd-timesync
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.timesync1.service

```

## FILE: /etc/systemd/system/grafana.service  (size=333b)
```
[Unit]
Description=Grafana
After=network-online.target

[Service]
User=grafana
Group=grafana
ExecStart=/usr/share/grafana/bin/grafana-server \
  --homepath=/usr/share/grafana \
  --config=/etc/grafana/grafana.ini
WorkingDirectory=/usr/share/grafana
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/iscsi.service  (size=1003b)
```
[Unit]
Description=Login to default iSCSI targets
Documentation=man:iscsiadm(8) man:iscsid(8)
Wants=network-online.target remote-fs-pre.target
After=network-online.target iscsid.service
Before=remote-fs-pre.target
DefaultDependencies=no
Conflicts=shutdown.target
Before=shutdown.target
# Must have some pre-defined targets to login to
ConditionDirectoryNotEmpty=|/etc/iscsi/nodes
# or have a session to use via iscsid
ConditionDirectoryNotEmpty=|/sys/class/iscsi_session

[Service]
Type=oneshot
RemainAfterExit=true
# iscsiadm --login will return 21 if no nodes are configured,
# and 15 if a session is alread logged in (which we do not
# consider an error)
SuccessExitStatus=15 21
# Note: iscsid will be socket activated by iscsiadm
ExecStart=/usr/sbin/iscsiadm -m node --loginall=automatic
ExecStart=/usr/lib/open-iscsi/activate-storage.sh
ExecStop=/usr/lib/open-iscsi/umountiscsi.sh
ExecStop=/bin/sync
ExecStop=/usr/lib/open-iscsi/logout-all.sh

[Install]
WantedBy=sysinit.target
Alias=iscsi.service

```

## FILE: /etc/systemd/system/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /etc/systemd/system/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/logos-node.service  (size=293b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/bin/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node.service.d/cors.conf  (size=72b)
```
[Service]
Environment=LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io

```

## FILE: /etc/systemd/system/logos-node.service.d/data.conf  (size=61b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled

```

## FILE: /etc/systemd/system/logos-node.service.d/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /etc/systemd/system/logos-node.service.d/faucet.conf  (size=42b)
```
[Service]
Environment=LRB_ENABLE_FAUCET=1

```

## FILE: /etc/systemd/system/logos-node.service.d/keys.conf  (size=46b)
```
[Service]
EnvironmentFile=/etc/logos/keys.env

```

## FILE: /etc/systemd/system/logos-node.service.d/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /etc/systemd/system/logos-node.service.d/phasemix.conf  (size=44b)
```
[Service]
Environment=LRB_PHASEMIX_ENABLE=1

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit_bypass.conf  (size=53b)
```
[Service]
Environment=LRB_RATE_BYPASS_CIDR=0.0.0.0/0

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit.conf  (size=122b)
```
[Service]
Environment=LRB_RATE_QPS=30
Environment=LRB_RATE_BURST=60
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /etc/systemd/system/logos-node.service.d/runas.conf  (size=166b)
```
[Service]
User=logos
Group=logos
# Разрешаем запись туда, где нужно (данные/секреты)
ReadWritePaths=/var/lib/logos /etc/logos

```

## FILE: /etc/systemd/system/logos-node.service.d/security.conf  (size=106b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true

```

## FILE: /etc/systemd/system/logos-node.service.d/tuning.conf  (size=422b)
```
[Service]
Environment=LRB_NODE_LISTEN=0.0.0.0:8080
Environment=LRB_DATA_DIR=/var/lib/logos
Environment=LRB_WALLET_ORIGIN=http://127.0.0.1
Environment=LRB_RATE_QPS=20
Environment=LRB_RATE_BURST=40
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-keys.conf  (size=610b)
```
[Service]
# Читаем файл с секретами (на будущее, если захочешь использовать keys.env)
EnvironmentFile=-/etc/logos/keys.env

# Узловые параметры (жёстко, чтобы сервис точно стартовал)
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_SK_HEX=31962399e9b0e278af3b328bc6e30bbd17d90c700a5f6c7ad3c4d4418ed8fd83
Environment=LRB_ADMIN_KEY=***MASKED***
Environment=LRB_BRIDGE_KEY=***MASKED***

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /etc/systemd/system/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-exporter.service  (size=148b)
```
[Unit]
Description=LRB textfile exporter (economy/head)

[Service]
Type=oneshot
ExecStart=/usr/local/bin/lrb_exporter.sh
User=nodeexp
Group=nodeexp

```

## FILE: /etc/systemd/system/lrb-exporter.timer  (size=120b)
```
[Unit]
Description=Run LRB exporter every 15s

[Timer]
OnBootSec=5
OnUnitActiveSec=15

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/node-exporter.service  (size=284b)
```
[Unit]
Description=Node Exporter (Prometheus)
After=network-online.target

[Service]
User=nodeexp
Group=nodeexp
ExecStart=/usr/local/bin/node_exporter \
  --collector.textfile.directory=/var/lib/node_exporter/textfile
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/prometheus.service  (size=352b)
```
[Unit]
Description=Prometheus
After=network-online.target

[Service]
User=prom
Group=prom
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus \
  --web.enable-lifecycle \
  --web.listen-address=127.0.0.1:9094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/syslog.service  (size=890b)
```
[Unit]
Description=System Logging Service
Requires=syslog.socket
Documentation=man:rsyslogd(8)
Documentation=man:rsyslog.conf(5)
Documentation=https://www.rsyslog.com/doc/

[Service]
Type=notify
ExecStartPre=/usr/lib/rsyslog/reload-apparmor-profile
ExecStart=/usr/sbin/rsyslogd -n -iNONE
StandardOutput=null
StandardError=journal
Restart=on-failure

# Increase the default a bit in order to allow many simultaneous
# files to be monitored, we might need a lot of fds.
LimitNOFILE=16384

CapabilityBoundingSet=CAP_BLOCK_SUSPEND CAP_CHOWN CAP_DAC_OVERRIDE CAP_LEASE CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SYS_RESOURCE CAP_SYSLOG CAP_MAC_ADMIN CAP_SETGID CAP_SETUID
SystemCallFilter=@system-service
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
NoNewPrivileges=yes
ProtectHome=no
ProtectClock=yes
ProtectHostname=yes

[Install]
WantedBy=multi-user.target
Alias=syslog.service

```

## FILE: /etc/systemd/system/vmtoolsd.service  (size=489b)
```
[Unit]
Description=Service for virtual machines hosted on VMware
Documentation=http://open-vm-tools.sourceforge.net/about.php
ConditionVirtualization=vmware
DefaultDependencies=no
Before=cloud-init-local.service
After=vgauth.service
After=apparmor.service
RequiresMountsFor=/tmp
After=systemd-remount-fs.service systemd-tmpfiles-setup.service systemd-modules-load.service

[Service]
ExecStart=/usr/bin/vmtoolsd
TimeoutStopSec=5

[Install]
WantedBy=multi-user.target
Alias=vmtoolsd.service

```

## FILE: /opt/logos/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /opt/logos/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /opt/logos/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /opt/logos/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /opt/logos/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /opt/logos/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /var/lib/grafana/dashboards/lrb_core.json  (size=920b)
```
{
  "title": "LOGOS LRB — Core",
  "panels": [
    { "type": "stat", "title": "Head Height", "targets": [ { "expr": "lrb_head_height" } ] },
    { "type": "stat", "title": "Supply", "targets": [ { "expr": "lrb_supply_total" } ] },
    { "type": "stat", "title": "Minted", "targets": [ { "expr": "lrb_minted_total" } ] },
    { "type": "stat", "title": "Burned", "targets": [ { "expr": "lrb_burned_total" } ] },
    { "type": "graph", "title": "HTTP p95 (s)", "targets": [ { "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))" } ] },
    { "type": "graph", "title": "HTTP RPS", "targets": [ { "expr": "sum(rate(http_requests_total[1m])) by (status)" } ] },
    { "type": "graph", "title": "5xx ratio (%)", "targets": [ { "expr": "100 * sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))" } ] }
  ],
  "schemaVersion": 36, "version": 1
}

```
